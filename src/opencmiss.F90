!> \file opencmiss.F90
!> \brief The top level OpenCMISS module.
!>
!> \mainpage OpenCMISS Documentation
!>
!> https://www.opencmiss.org/
!>
!> An open source interactive computer program for Continuum Mechanics, Image analysis, Signal processing and System
!> Identification. Target usage: Bioengineering application of finite element analysis, boundary element and collocation
!> techniques.
!>
!> The Original Code is OpenCMISS
!>
!> LICENSE
!>
!> \rtfinclude ../LICENSE
!>
!> Contributor(s): Chris Bradley
!>

! Eclipse regular expressions to add the DLLEXPORT macro:
! Find: ^( *)(SUBROUTINE *)([^\(]*)(\([^\)]*\))
! Replace: $1$2$3$4\R$1  !DLLEXPORT($3)

!> \defgroup OpenCMISS OpenCMISS
!> \brief The top level OpenCMISS module. This module is the buffer Fortran module between the OpenCMISS library and user code
MODULE OpenCMISS

  USE AnalyticAnalysisRoutines
  USE BaseRoutines
  USE BasisRoutines
  USE BasisAccessRoutines
  USE BioelectricFiniteElasticityRoutines
  USE BoundaryConditionsRoutines
  USE BoundaryConditionAccessRoutines
  USE CellMLAccessRoutines
  USE ComputationRoutines
  USE ComputationAccessRoutines
  USE Constants
  USE ContextRoutines
  USE ContextAccessRoutines
  USE ControlLoopRoutines
  USE ControlLoopAccessRoutines
  USE CoordinateSystemRoutines
  USE CoordinateSystemAccessRoutines
  USE DataPointRoutines
  USE DataPointAccessRoutines
  USE DataProjectionRoutines
  USE DataProjectionAccessRoutines
  USE DecompositionRoutines
  USE DecompositionAccessRoutines
  USE DistributedMatrixVector
  USE DistributedMatrixVectorAccessRoutines
  USE EquationsRoutines
  USE EquationsMappingAccessRoutines
  USE EquationsMatricesAccessRoutines
  USE EquationsSetRoutines
  USE EquationsSetAccessRoutines
  USE ExportRoutines
  USE ExportAccessRoutines
  USE FieldRoutines
  USE FieldAccessRoutines
#ifdef WITH_FIELDML
  USE FIELDML_TYPES
  USE FIELDML_INPUT_ROUTINES
  USE FIELDML_OUTPUT_ROUTINES
  USE FIELDML_UTIL_ROUTINES
#endif
  USE FIELD_IO_ROUTINES
  USE FiniteElasticityRoutines
  USE GeneratedMeshRoutines
  USE GeneratedMeshAccessRoutines
  USE HamiltonJacobiRoutines
  USE HISTORY_ROUTINES
  USE InputOutput
  USE InterfaceRoutines
  USE InterfaceAccessRoutines
  USE InterfaceConditionRoutines
  USE InterfaceConditionAccessRoutines
  USE InterfaceEquationsRoutines
  USE InterfaceMatricesRoutines
  USE InterfaceMatricesAccessRoutines
  USE ISO_C_BINDING, ONLY: C_INT,C_PTR,C_ASSOCIATED, C_F_POINTER
  USE ISO_VARYING_STRING
  USE Kinds
  USE MeshRoutines
  USE MeshAccessRoutines
#ifdef WITH_MPI
#ifdef WITH_F08_MPI
  USE MPI_F08
#endif
#endif  
  USE NodeRoutines
  USE OpenCMISSCellML
  USE OpenCMISSInit
#ifdef WITH_PETSC  
  USE OpenCMISSPETSc
#endif  
  USE ProblemRoutines
  USE ProblemAccessRoutines
  USE RegionRoutines
  USE RegionAccessRoutines
  USE SolverRoutines
  USE SolverAccessRoutines
  USE SolverMatricesAccessRoutines
  USE Strings
  USE Types

#include "opencmiss_version.h"  
#include "macros.h"
#include "dllexport.h"

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !> \addtogroup OpenCMISS_Constants OpenCMISS::Constants
  !> \brief OpenCMISS constants.
  !>@{
  !> \addtogroup OpenCMISS_KindConstants OpenCMISS::Constants::Kinds
  !> \brief OpenCMISS Fortran kind constants.
  !>@{
  !> \addtogroup OpenCMISS_IntegerKinds OpenCMISS::Constants::Kinds::Integers
  !> \brief Kind parameters for integer data types.
  !> \see OpenCMISS::Constants::Kinds,OpenCMISS::Constants
  !>@{
  INTEGER, PARAMETER :: OC_Intg = INTG !<Standard integer kind. \see OpenCMISS_IntegerKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_SIntg = SINTG !<Short integer kind. \see OpenCMISS_IntegerKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_LIntg = LINTG !<Long integer kind. \see OpenCMISS_IntegerKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_Ptr = PTR !<Pointer integer kind. \see OpenCMISS_IntegerKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_Idx = IDX !<Index integer kind. \see OpenCMISS_IntegerKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_LIdx = LIDX !<Long index integer kind. \see OpenCMISS_IntegerKinds,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_RealKinds OpenCMISS::Constants::Kinds::Reals
  !> \brief Kind parameters for real data types.
  !> \see OpenCMISS::Constants::Kinds,OpenCMISS::Constants
  !>@{
  INTEGER, PARAMETER :: OC_SP = SP !<Single precision real kind. \see OpenCMISS_RealKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_DP = DP !<Double precision real kind. \see OpenCMISS_RealKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_QP = QP !<Quadruple precision real kind. \see OpenCMISS_RealKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_RP = RP !<Working precision real kind. \see OpenCMISS_RealKinds,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_ComplexKinds OpenCMISS::Constants::Kinds::Complex
  !> \brief Kind parameters for complex data types
  !> \see OpenCMISS::Constants::Kinds,OpenCMISS::Constants
  !>@{
  INTEGER, PARAMETER :: OC_SPC = SPC !<Single precision complex kind. \see OpenCMISS_ComplexKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_DPC = DPC !<Double precision complex kind. \see OpenCMISS_ComplexKinds,OpenCMISS
  INTEGER, PARAMETER :: OC_RPC = RPC !<Working precision complex kind. \see OpenCMISS_ComplexKinds,OpenCMISS
  !>@}
  !>@}
  !> \defgroup OpenCMISS_VersionConstants OpenCMISS::Constants::Version
  !> \brief OpenCMISS version constants.
  !> \see OpenCMISS::Constants
  !>@{
  INTEGER(INTG), PARAMETER :: OC_MAJOR_VERSION = OpenCMISS_MAJOR_VERSION !<OpenCMISS major version number. \see OpenCMISS_VersionContants
  INTEGER(INTG), PARAMETER :: OC_MINOR_VERSION = OpenCMISS_MINOR_VERSION !<OpenCMISS minor version number. \see OpenCMISS_VersionContants
  INTEGER(INTG), PARAMETER :: OC_PATCH_VERSION = OpenCMISS_PATCH_VERSION !<OpenCMISS patch version number. \see OpenCMISS_VersionContants
  !>@}
  !>@}
  
  !Module types

  !> \addtogroup OpenCMISS_Basis OpenCMISS::Basis
  !>@{
  
  !>Contains information about a basis function.
  TYPE OC_BasisType
    PRIVATE
    TYPE(BasisType), POINTER :: basis
  END TYPE OC_BasisType
  
  !>@}

  !> \addtogroup OpenCMISS_BoundaryConditions OpenCMISS::BoundaryConditions
  !>@{
  !>Contains information on the boundary conditions for the equations set.
  TYPE OC_BoundaryConditionsType
    PRIVATE
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
  END TYPE OC_BoundaryConditionsType
  !>@}

  !>Contains information on a CellML environment.
  TYPE OC_CellMLType
    PRIVATE
    TYPE(CellMLType), POINTER :: cellml
  END TYPE OC_CellMLType

  !>Contains information about the CellML equations for a solver.
  TYPE OC_CellMLEquationsType
    PRIVATE
    TYPE(CellMLEquationsType), POINTER :: cellmlEquations
  END TYPE OC_CellMLEquationsType

  !>Contains information on a computation environment
  TYPE OC_ComputationEnvironmentType
    PRIVATE
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
  END TYPE OC_ComputationEnvironmentType

  !>Contains information on a context.
  TYPE OC_ContextType
    PRIVATE
    TYPE(ContextType), POINTER :: context
  END TYPE OC_ContextType

  !>Contains information on a control loop.
  TYPE OC_ControlLoopType
    PRIVATE
    TYPE(ControlLoopType), POINTER :: controlLoop
  END TYPE OC_ControlLoopType

  !>Contains information on a coordinate system.
  TYPE OC_CoordinateSystemType
    PRIVATE
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
  END TYPE OC_CoordinateSystemType

  !>Contains information on the data points defined on a region.
  TYPE OC_DataPointsType
    PRIVATE
    TYPE(DataPointsType), POINTER :: dataPoints
  END TYPE OC_DataPointsType

  !>Contains information about a data projection.
  TYPE OC_DataProjectionType
    PRIVATE
    TYPE(DataProjectionType), POINTER :: dataProjection
  END TYPE OC_DataProjectionType

  !>Contains information on the mesh decomposition.
  TYPE OC_DecompositionType
    PRIVATE
    TYPE(DecompositionType), POINTER :: decomposition
  END TYPE OC_DecompositionType

  !>Contains information on the mesh decomposition topology
  TYPE OC_DecompositionTopologyType
    PRIVATE
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
  END TYPE OC_DecompositionTopologyType

  !>Contains information on the mesh decomposition element.
  TYPE OC_DecompositionElementType
    PRIVATE
    TYPE(DecompositionElementType), POINTER :: decompositionElement
  END TYPE OC_DecompositionElementType

  !>Contains information on the mesh decomposition elements.
  TYPE OC_DecompositionElementsType
    PRIVATE
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
  END TYPE OC_DecompositionElementsType

  !>Contains information on the mesh decomposition face.
  TYPE OC_DecompositionFaceType
    PRIVATE
    TYPE(DecompositionFaceType), POINTER :: decompositionFace
  END TYPE OC_DecompositionFaceType

  !>Contains information on the mesh decomposition faces.
  TYPE OC_DecompositionFacesType
    PRIVATE
    TYPE(DecompositionFacesType), POINTER :: decompositionFaces
  END TYPE OC_DecompositionFacesType

  !>Contains information on the mesh decomposition line.
  TYPE OC_DecompositionLineType
    PRIVATE
    TYPE(DecompositionLineType), POINTER :: decompositionLine
  END TYPE OC_DecompositionLineType

  !>Contains information on the mesh decomposition lines.
  TYPE OC_DecompositionLinesType
    PRIVATE
    TYPE(DecompositionLinesType), POINTER :: decompositionLines
  END TYPE OC_DecompositionLinesType

  !>Contains information on the decomposer.
  TYPE OC_DecomposerType
    PRIVATE
    TYPE(DecomposerType), POINTER :: decomposer
  END TYPE OC_DecomposerType

  !>Contains information on the decomposition domain.
  TYPE OC_DomainType
    PRIVATE
    TYPE(DomainType), POINTER :: domain
  END TYPE OC_DomainType

  !>Contains information on the decomposition domain element.
  TYPE OC_DomainElementType
    PRIVATE
    TYPE(DomainElementType), POINTER :: domainElement
  END TYPE OC_DomainElementType

  !>Contains information on the decomposition domain elements.
  TYPE OC_DomainElementsType
    PRIVATE
    TYPE(DomainElementsType), POINTER :: domainElements
  END TYPE OC_DomainElementsType

  !>Contains information on the decomposition domain faces.
  TYPE OC_DomainFacesType
    PRIVATE
    TYPE(DomainFacesType), POINTER :: domainFaces
  END TYPE OC_DomainFacesType

  !>Contains information on the decomposition domain face.
  TYPE OC_DomainFaceType
    PRIVATE
    TYPE(DomainFaceType), POINTER :: domainFace
  END TYPE OC_DomainFaceType

  !>Contains information on the decomposition domain line.
  TYPE OC_DomainLineType
    PRIVATE
    TYPE(DomainLineType), POINTER :: domainLine
  END TYPE OC_DomainLineType

  !>Contains information on the decomposition domain lines.
  TYPE OC_DomainLinesType
    PRIVATE
    TYPE(DomainLinesType), POINTER :: domainLines
  END TYPE OC_DomainLinesType

  !>Contains information on the decomposition domain node.
  TYPE OC_DomainNodeType
    PRIVATE
    TYPE(DomainNodeType), POINTER :: domainNode
  END TYPE OC_DomainNodeType

  !>Contains information on the decomposition domain nodes.
  TYPE OC_DomainNodesType
    PRIVATE
    TYPE(DomainNodesType), POINTER :: domainNodes
  END TYPE OC_DomainNodesType

  !>Contains information on the decomposition domain topology.
  TYPE OC_DomainTopologyType
    PRIVATE
    TYPE(DomainTopologyType), POINTER :: domainTopology
  END TYPE OC_DomainTopologyType

  !>Contains information about the equations in an equations set.
  TYPE OC_EquationsType
    PRIVATE
    TYPE(EquationsType), POINTER :: equations
  END TYPE OC_EquationsType

  !>Contains information on an equations set defined on a region.
  TYPE OC_EquationsSetType
    PRIVATE
    TYPE(EquationsSetType), POINTER :: equationsSet
  END TYPE OC_EquationsSetType

  !>Contains information for an export
  TYPE OC_ExportType
    PRIVATE
    TYPE(ExportType), POINTER :: export
  END TYPE OC_ExportType

  !>Contains information for a field defined on a region.
  TYPE OC_FieldType
    PRIVATE
    TYPE(FieldType), POINTER :: field
  END TYPE OC_FieldType

  !>Contains information for a fields defined on a region.
  TYPE OC_FieldsType
    !PRIVATE
    TYPE(FieldsType), POINTER :: fields
  END TYPE OC_FieldsType

  !>Contains information on a generated mesh.
  TYPE OC_GeneratedMeshType
    PRIVATE
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
  END TYPE OC_GeneratedMeshType

  !>Contains information about a history file for a control loop.
  TYPE OC_HistoryType
    PRIVATE
    TYPE(HISTORY_TYPE), POINTER :: history
  END TYPE OC_HistoryType

  !>Contains information about an interface.
  TYPE OC_InterfaceType
    PRIVATE
    TYPE(InterfaceType), POINTER :: interface
  END TYPE OC_InterfaceType

  !>Contains information about an interface condition.
  TYPE OC_InterfaceConditionType
    PRIVATE
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
  END TYPE OC_InterfaceConditionType

  !>Contains information about an interface condition.
  TYPE OC_InterfaceEquationsType
    PRIVATE
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
  END TYPE OC_InterfaceEquationsType

  !>Contains information on an interfaces meshes connectivity.
  TYPE OC_InterfaceMeshConnectivityType
    PRIVATE
    TYPE(InterfaceMeshConnectivityType), POINTER :: meshConnectivity
  END TYPE OC_InterfaceMeshConnectivityType

  !>Contains information on an interfaces points connectivity.
  TYPE OC_InterfacePointsConnectivityType
    PRIVATE
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
  END TYPE OC_InterfacePointsConnectivityType

  !>A matrix that may be distributed across multiple computation nodes
  !>and may use sparse or full storage.
  TYPE OC_DistributedMatrixType
    PRIVATE
    TYPE(DistributedMatrixType), POINTER :: distributedMatrix
  END TYPE OC_DistributedMatrixType

  !>A vector that may be distributed across multiple computation nodes
  TYPE OC_DistributedVectorType
    PRIVATE
    TYPE(DistributedVectorType), POINTER :: distributedVector
  END TYPE OC_DistributedVectorType

  !>Contains information on a mesh defined on a region.
  TYPE OC_MeshType
    PRIVATE
    TYPE(MeshType), POINTER :: mesh
  END TYPE OC_MeshType

  !>Contains information on a mesh elements defined in a mesh
  TYPE OC_MeshElementsType
    PRIVATE
    TYPE(MeshElementsType), POINTER :: meshElements
  END TYPE OC_MeshElementsType

  !>Contains information on an embedded mesh
  TYPE OC_MeshEmbeddingType
    PRIVATE
    TYPE(MESH_EMBEDDING_TYPE), POINTER :: meshEmbedding
  END TYPE OC_MeshEmbeddingType

  !>Contains information on a mesh nodes defined in a mesh
  TYPE OC_MeshNodesType
    PRIVATE
    TYPE(MeshNodesType), POINTER :: meshNodes
  END TYPE OC_MeshNodesType

  !>Contains information on the nodes defined on a region.
  TYPE OC_NodesType
    PRIVATE
    TYPE(NodesType), POINTER :: nodes
  END TYPE OC_NodesType

  !>Contains information for a problem.
  TYPE OC_ProblemType
    PRIVATE
    TYPE(ProblemType), POINTER :: problem
  END TYPE OC_ProblemType

  !>Contains information for a particular quadrature scheme for a basis.
  TYPE OC_QuadratureType
    PRIVATE
    TYPE(QuadratureType), POINTER :: quadrature
  END TYPE OC_QuadratureType

  !>Contains information for a region.
  TYPE OC_RegionType
    PRIVATE
    TYPE(RegionType), POINTER :: region
  END TYPE OC_RegionType

  !>Contains information about a solver.
  TYPE OC_SolverType
    PRIVATE
    TYPE(SolverType), POINTER :: solver
  END TYPE OC_SolverType

  !>Contains information about the solver equations for a solver.
  TYPE OC_SolverEquationsType
    PRIVATE
    TYPE(SolverEquationsType), POINTER :: solverEquations
  END TYPE OC_SolverEquationsType

  !>Contains information on a work group
  TYPE OC_WorkGroupType
    PRIVATE
    TYPE(WorkGroupType), POINTER :: workGroup
  END TYPE OC_WorkGroupType

  !Module variables

  TYPE(VARYING_STRING) :: error

  PUBLIC OC_MAJOR_VERSION,OC_MINOR_VERSION,OC_PATCH_VERSION

  PUBLIC OC_Intg,OC_SIntg,OC_LIntg,OC_Ptr,OC_Idx,OC_LIdx

  PUBLIC OC_SP,OC_DP,OC_QP,OC_RP

  PUBLIC OC_SPC,OC_DPC,OC_RPC

  INTERFACE OC_Fields_Create
    MODULE PROCEDURE OC_Fields_CreateInterface
    MODULE PROCEDURE OC_Fields_CreateRegion
  END INTERFACE OC_Fields_Create

  PUBLIC OC_Finalise,OC_Initialise

  PUBLIC OC_ComponentToTensorTwoComponentsGet
  
  PUBLIC OC_NumberOfTensorTwoComponentsGet

  PUBLIC OC_NumberOfVoigtComponentsGet

  PUBLIC OC_PetscOptionsSetValue

  PUBLIC OC_TensorTwoComponentsToComponentGet

  PUBLIC OC_TensorComponentsToVoigtComponentGet

  PUBLIC OC_VoigtComponentToTensorComponentsGet
  
  PUBLIC OC_WorkingRealPrecisionGet
  
  PUBLIC OC_BasisType,OC_BasisTypesCopy,OC_Basis_Finalise,OC_Basis_Initialise

  PUBLIC OC_BoundaryConditionsType,OC_BoundaryConditions_Finalise,OC_BoundaryConditions_Initialise

  PUBLIC OC_CellMLType,OC_CellML_Finalise,OC_CellML_Initialise

  PUBLIC OC_CellMLEquationsType,OC_CellMLEquations_Finalise,OC_CellMLEquations_Initialise

  PUBLIC OC_ComputationEnvironmentType,OC_ComputationEnvironment_Initialise,OC_ComputationEnvironment_Finalise

  PUBLIC OC_ContextType,OC_Context_Finalise,OC_Context_Initialise

  PUBLIC OC_ControlLoopType,OC_ControlLoop_Finalise,OC_ControlLoop_Initialise

  PUBLIC OC_CoordinateSystemType,OC_CoordinateSystem_Finalise,OC_CoordinateSystem_Initialise

  PUBLIC OC_DataPointsType,OC_DataPoints_Finalise,OC_DataPoints_Initialise

  PUBLIC OC_DataProjectionType,OC_DataProjection_Finalise,OC_DataProjection_Initialise

  PUBLIC OC_DecompositionType,OC_Decomposition_Finalise,OC_Decomposition_Initialise

  PUBLIC OC_DecompositionElementType,OC_DecompositionElement_Finalise,OC_DecompositionElement_Initialise
  
  PUBLIC OC_DecompositionElementsType,OC_DecompositionElements_Finalise,OC_DecompositionElements_Initialise
  
  PUBLIC OC_DecompositionFaceType,OC_DecompositionFace_Finalise,OC_DecompositionFace_Initialise
  
  PUBLIC OC_DecompositionFacesType,OC_DecompositionFaces_Finalise,OC_DecompositionFaces_Initialise

  PUBLIC OC_DecompositionLineType,OC_DecompositionLine_Finalise,OC_DecompositionLine_Initialise
  
  PUBLIC OC_DecompositionLinesType,OC_DecompositionLines_Finalise,OC_DecompositionLines_Initialise

  PUBLIC OC_DecompositionTopologyType,OC_DecompositionTopology_Finalise,OC_DecompositionTopology_Initialise

  PUBLIC OC_DecomposerType,OC_Decomposer_Finalise,OC_Decomposer_Initialise

  PUBLIC OC_DistributedMatrixType,OC_DistributedVectorType

  PUBLIC OC_DistributedMatrix_Initialise,OC_DistributedVector_Initialise

  PUBLIC OC_DomainType,OC_Domain_Finalise,OC_Domain_Initialise

  PUBLIC OC_DomainElementType,OC_DomainElement_Finalise,OC_DomainElement_Initialise
  
  PUBLIC OC_DomainElementsType,OC_DomainElements_Finalise,OC_DomainElements_Initialise
  
  PUBLIC OC_DomainFaceType,OC_DomainFace_Finalise,OC_DomainFace_Initialise
  
  PUBLIC OC_DomainFacesType,OC_DomainFaces_Finalise,OC_DomainFaces_Initialise
  
  PUBLIC OC_DomainLineType,OC_DomainLine_Finalise,OC_DomainLine_Initialise

  PUBLIC OC_DomainLinesType,OC_DomainLines_Finalise,OC_DomainLines_Initialise

  PUBLIC OC_DomainNodeType,OC_DomainNode_Finalise,OC_DomainNode_Initialise

  PUBLIC OC_DomainNodesType,OC_DomainNodes_Finalise,OC_DomainNodes_Initialise

  PUBLIC OC_DomainTopologyType,OC_DomainTopology_Finalise,OC_DomainTopology_Initialise

  PUBLIC OC_EquationsType,OC_Equations_Finalise,OC_Equations_Initialise

  PUBLIC OC_EquationsSetType,OC_EquationsSet_Finalise,OC_EquationsSet_Initialise

  PUBLIC OC_ExportType,OC_Export_Finalise,OC_Export_Initialise

  PUBLIC OC_FieldType,OC_Field_Finalise,OC_Field_Initialise

  PUBLIC OC_FieldsType,OC_Fields_AddField,OC_Fields_Create,OC_Fields_Finalise,OC_Fields_Initialise

  PUBLIC OC_GeneratedMeshType,OC_GeneratedMesh_Finalise,OC_GeneratedMesh_Initialise

  PUBLIC OC_HistoryType,OC_History_Finalise,OC_History_Initialise

  PUBLIC OC_InterfaceType,OC_Interface_Finalise,OC_Interface_Initialise

  PUBLIC OC_InterfaceConditionType,OC_InterfaceCondition_Finalise,OC_InterfaceCondition_Initialise

  PUBLIC OC_InterfaceEquationsType,OC_InterfaceEquations_Finalise,OC_InterfaceEquations_Initialise

  PUBLIC OC_InterfaceMeshConnectivityType,OC_InterfaceMeshConnectivity_Finalise,OC_InterfaceMeshConnectivity_Initialise

  PUBLIC OC_InterfacePointsConnectivityType,OC_InterfacePointsConnectivity_Initialise,OC_InterfacePointsConnectivity_Finalise

  PUBLIC OC_MeshType,OC_Mesh_Finalise,OC_Mesh_Initialise

  PUBLIC OC_MeshElementsType,OC_MeshElements_Finalise,OC_MeshElements_Initialise

  PUBLIC OC_MeshNodesType,OC_MeshNodes_Finalise,OC_MeshNodes_Initialise

  PUBLIC OC_NodesType,OC_Nodes_Finalise,OC_Nodes_Initialise

  PUBLIC OC_ProblemType,OC_Problem_Finalise,OC_Problem_Initialise

  PUBLIC OC_QuadratureType,OC_Quadrature_Finalise,OC_Quadrature_Initialise

  PUBLIC OC_RegionType,OC_Region_Finalise,OC_Region_Initialise

  PUBLIC OC_SolverType,OC_Solver_Finalise,OC_Solver_Initialise

  PUBLIC OC_SolverEquationsType,OC_SolverEquations_Finalise,OC_SolverEquations_Initialise

  PUBLIC OC_WorkGroupType,OC_WorkGroup_Initialise,OC_WorkGroup_Finalise

  !==================================================================================================================================
  !
  ! AnalyticAnalysisRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_AnalyticAnalysisConstants OpenCMISS::AnalyticAnalysis::Constants
  !> \brief Analytic analysis constants.
  !>@{
  !> \addtogroup OpenCMISS_AnalyticErrorTypes OpenCMISS::AnalyticAnalysis::ErrorTypes
  !> \brief Analytic analysis error type parameters.
  !> \see OpenCMISS::AnalyticAnalysis,OpenCMISS
  !>@{ 
  INTEGER(OC_INTG), PARAMETER :: OC_ANALYTIC_ABSOLUTE_ERROR_TYPE = ANALYTIC_ABSOLUTE_ERROR_TYPE !<Analytic analysis absolute error type \see OpenCMISS_AnalyticErrorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ANALYTIC_PERCENTAGE_ERROR_TYPE = ANALYTIC_PERCENTAGE_ERROR_TYPE !<Analytic analysis percentage error type \see OpenCMISS_AnalyticErrorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ANALYTIC_RELATIVE_ERROR_TYPE = ANALYTIC_RELATIVE_ERROR_TYPE !<Analytic analysis relative error type \see OpenCMISS_AnalyticErrorTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Output the analytic error analysis for a field compared to the analytic values parameter set.
  INTERFACE OC_AnalyticAnalysis_Output
    MODULE PROCEDURE OC_AnalyticAnalysis_OutputNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_OutputObj
  END INTERFACE OC_AnalyticAnalysis_Output

  !>Get the absolute error of the node.
  INTERFACE OC_AnalyticAnalysis_AbsoluteErrorGetNode
    MODULE PROCEDURE OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj
  END INTERFACE OC_AnalyticAnalysis_AbsoluteErrorGetNode

  !>Get the percentage error of the node.
  INTERFACE OC_AnalyticAnalysis_PercentageErrorGetNode
    MODULE PROCEDURE OC_AnalyticAnalysis_PercentageErrorGetNodeNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_PercentageErrorGetNodeObj
  END INTERFACE OC_AnalyticAnalysis_PercentageErrorGetNode

  !>Get the relative error of the node.
  INTERFACE OC_AnalyticAnalysis_RelativeErrorGetNode
    MODULE PROCEDURE OC_AnalyticAnalysis_RelativeErrorGetNodeNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_RelativeErrorGetNodeObj
  END INTERFACE OC_AnalyticAnalysis_RelativeErrorGetNode

  !>Get the absolute error of the element.
  INTERFACE OC_AnalyticAnalysis_AbsoluteErrorGetElement
    MODULE PROCEDURE OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_AbsoluteErrorGetElementObj
  END INTERFACE OC_AnalyticAnalysis_AbsoluteErrorGetElement

  !>Get the percentage error of the element.
  INTERFACE OC_AnalyticAnalysis_PercentageErrorGetElement
    MODULE PROCEDURE OC_AnalyticAnalysis_PercentageErrorGetElementNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_PercentageErrorGetElementObj
  END INTERFACE OC_AnalyticAnalysis_PercentageErrorGetElement

  !>Get the relative error of the element.
  INTERFACE OC_AnalyticAnalysis_RelativeErrorGetElement
    MODULE PROCEDURE OC_AnalyticAnalysis_RelativeErrorGetElementNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_RelativeErrorGetElementObj
  END INTERFACE OC_AnalyticAnalysis_RelativeErrorGetElement

  !>Get the absolute error of the constant.
  INTERFACE OC_AnalyticAnalysis_AbsoluteErrorGetConstant
    MODULE PROCEDURE OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj
  END INTERFACE OC_AnalyticAnalysis_AbsoluteErrorGetConstant

  !>Get the percentage error of the constant.
  INTERFACE OC_AnalyticAnalysis_PercentageErrorGetConstant
    MODULE PROCEDURE OC_AnalyticAnalysis_PercentageErrorGetConstantNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_PercentageErrorGetConstantObj
  END INTERFACE OC_AnalyticAnalysis_PercentageErrorGetConstant

  !>Get the relative error of the constant.
  INTERFACE OC_AnalyticAnalysis_RelativeErrorGetConstant
    MODULE PROCEDURE OC_AnalyticAnalysis_RelativeErrorGetConstantNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_RelativeErrorGetConstantObj
  END INTERFACE OC_AnalyticAnalysis_RelativeErrorGetConstant

  !>Get the RMS error of nodes.
  INTERFACE OC_AnalyticAnalysis_RMSErrorGetNode
    MODULE PROCEDURE OC_AnalyticAnalysis_RMSErrorGetNodeNumber0
    MODULE PROCEDURE OC_AnalyticAnalysis_RMSErrorGetNodeNumber1
    MODULE PROCEDURE OC_AnalyticAnalysis_RMSErrorGetNodeObj0
    MODULE PROCEDURE OC_AnalyticAnalysis_RMSErrorGetNodeObj1
  END INTERFACE OC_AnalyticAnalysis_RMSErrorGetNode

  !>Get the RMS error of elements.
  INTERFACE OC_AnalyticAnalysis_RMSErrorGetElement
    MODULE PROCEDURE OC_AnalyticAnalysis_RMSErrorGetElementNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_RMSErrorGetElementObj
  END INTERFACE OC_AnalyticAnalysis_RMSErrorGetElement

  !>Get integral of numerical values.
  INTERFACE OC_AnalyticAnalysis_IntegralNumericalValueGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralNumericalValueGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralNumericalValueGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralNumericalValueGet

  !>Get integral of analytical values.
  INTERFACE OC_AnalyticAnalysis_IntegralAnalyticValueGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralAnalyticValueGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralAnalyticValueGet

  !>Get integral of percentage errors.
  INTERFACE OC_AnalyticAnalysis_IntegralPercentageErrorGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralPercentageErrorGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralPercentageErrorGet

  !>Get integral of absolute errors.
  INTERFACE OC_AnalyticAnalysis_IntegralAbsoluteErrorGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralAbsoluteErrorGet

  !>Get integral of relative errors.
  INTERFACE OC_AnalyticAnalysis_IntegralRelativeErrorGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralRelativeErrorGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralRelativeErrorGet

  !>Get integral of NID numerical errors.
  INTERFACE OC_AnalyticAnalysis_IntegralNIDNumericalValueGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralNIDNumericalValueGet

  !>Get integral of NID errors.
  INTERFACE OC_AnalyticAnalysis_IntegralNIDErrorGet
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralNIDErrorGetNumber
    MODULE PROCEDURE OC_AnalyticAnalysis_IntegralNIDErrorGetObj
  END INTERFACE OC_AnalyticAnalysis_IntegralNIDErrorGet

  PUBLIC OC_ANALYTIC_ABSOLUTE_ERROR_TYPE,OC_ANALYTIC_PERCENTAGE_ERROR_TYPE,OC_ANALYTIC_RELATIVE_ERROR_TYPE

  PUBLIC OC_AnalyticAnalysis_Output

  PUBLIC OC_AnalyticAnalysis_AbsoluteErrorGetNode,OC_AnalyticAnalysis_PercentageErrorGetNode, &
    & OC_AnalyticAnalysis_RelativeErrorGetNode

  PUBLIC OC_AnalyticAnalysis_AbsoluteErrorGetElement,OC_AnalyticAnalysis_PercentageErrorGetElement, &
    & OC_AnalyticAnalysis_RelativeErrorGetElement

  PUBLIC OC_AnalyticAnalysis_AbsoluteErrorGetConstant,OC_AnalyticAnalysis_PercentageErrorGetConstant, &
    & OC_AnalyticAnalysis_RelativeErrorGetConstant

  PUBLIC OC_AnalyticAnalysis_RMSErrorGetNode,OC_AnalyticAnalysis_RMSErrorGetElement

  PUBLIC OC_AnalyticAnalysis_IntegralNumericalValueGet,OC_AnalyticAnalysis_IntegralAnalyticValueGet, &
    & OC_AnalyticAnalysis_IntegralPercentageErrorGet,OC_AnalyticAnalysis_IntegralAbsoluteErrorGet, &
    & OC_AnalyticAnalysis_IntegralRelativeErrorGet,OC_AnalyticAnalysis_IntegralNIDNumericalValueGet, &
    & OC_AnalyticAnalysis_IntegralNIDErrorGet

  !==================================================================================================================================
  !
  ! BaseRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_DiagnosticAndTimingConstants OpenCMISS::DiagnosticAndTiming::Constants
  !> \brief Diagnostic and Timing constants.
  !>@{
  !> \addtogroup OpenCMISS_DiagnosticTypes OpenCMISS::DiagnosticAndTiming::DiagnosticTypes
  !> \brief Diganostic constants.
  !> \see OpenCMISS::DiagnosticTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_ALL_DIAG_TYPE = ALL_DIAG_TYPE !<Type for setting diagnostic output in all routines \see OpenCMISS_DiagnosticTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_IN_DIAG_TYPE = IN_DIAG_TYPE !<Type for setting diagnostic output in one routine \see OpenCMISS_DiagnosticTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FROM_DIAG_TYPE = FROM_DIAG_TYPE !<Type for setting diagnostic output in one routine downwards \see OpenCMISS_DiagnosticTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_TimingTypes OpenCMISS::DiagnosticAndTiming::TimingTypes
  !> \brief Timing constants.
  !> \see OpenCMISS::TimingTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_ALL_TIMING_TYPE = ALL_TIMING_TYPE !<Type for setting timing output in all routines \see OpenCMISS_TimingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_IN_TIMING_TYPE = IN_TIMING_TYPE !<Type for setting timing output in one routine \see OpenCMISS_TimingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FROM_TIMING_TYPE = FROM_TIMING_TYPE !<Type for setting timing output from one routine downwards \see OpenCMISS_TimingTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC OC_ALL_DIAG_TYPE,OC_IN_DIAG_TYPE,OC_FROM_DIAG_TYPE

  PUBLIC OC_ALL_TIMING_TYPE,OC_IN_TIMING_TYPE,OC_FROM_TIMING_TYPE

  PUBLIC OC_DiagnosticsSetOff,OC_DiagnosticsSetOn

  PUBLIC OC_OutputSetOff,OC_OutputSetOn

  PUBLIC OC_TimingSetOff,OC_TimingSetOn,OC_TimingSummaryOutput

  !==================================================================================================================================
  !
  ! BasisRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_BasisConstants OpenCMISS::Basis::Constants
  !> \brief Basis function constants.
  !>@{
  !> \addtogroup OpenCMISS_BasisTypes OpenCMISS::Basis::Constants::BasisTypes
  !> \brief Basis definition type parameters.
  !> \see OpenCMISS::Basis::Constants,OpenCMISS::Basis
  !>@{ 
  INTEGER(INTG), PARAMETER :: OC_BASIS_LAGRANGE_HERMITE_TP_TYPE = BASIS_LAGRANGE_HERMITE_TP_TYPE !<Lagrange-Hermite tensor product basis type \see OpenCMISS_BasisTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_SIMPLEX_TYPE = BASIS_SIMPLEX_TYPE !<Simplex basis type \see OpenCMISS_BasisTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_SERENDIPITY_TYPE = BASIS_SERENDIPITY_TYPE !<Serendipity basis type \see OpenCMISS_BasisTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_AUXILLIARY_TYPE = BASIS_AUXILLIARY_TYPE !<Auxillary basis type \see OpenCMISS_BasisTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_B_SPLINE_TP_TYPE = BASIS_B_SPLINE_TP_TYPE !<B-spline basis type \see OpenCMISS_BasisTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE = BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE !<Fourier-Lagrange tensor product basis type \see OpenCMISS_BasisTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_EXTENDED_LAGRANGE_TP_TYPE = BASIS_EXTENDED_LAGRANGE_TP_TYPE !< Extendend Lagrange tensor product basis type \see OpenCMISS_BasisTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_BasisInterpolationSpecifications OpenCMISS::Basis::Constants::InterpolationSpecifications
  !> \brief Interpolation specification parameters
  !> \see OpenCMISS::Basis::Constants,OpenCMISS::Basis
  !>@{
  INTEGER(INTG), PARAMETER :: OC_BASIS_LINEAR_LAGRANGE_INTERPOLATION = BASIS_LINEAR_LAGRANGE_INTERPOLATION !<Linear Lagrange interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION = BASIS_QUADRATIC_LAGRANGE_INTERPOLATION !<Quadratic Lagrange interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_CUBIC_LAGRANGE_INTERPOLATION = BASIS_CUBIC_LAGRANGE_INTERPOLATION !<Cubic Lagrange interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_CUBIC_HERMITE_INTERPOLATION = BASIS_CUBIC_HERMITE_INTERPOLATION !<Cubic Hermite interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_QUADRATIC1_HERMITE_INTERPOLATION = BASIS_QUADRATIC1_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=0) interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_QUADRATIC2_HERMITE_INTERPOLATION = BASIS_QUADRATIC2_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=1) interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_LINEAR_SIMPLEX_INTERPOLATION = BASIS_LINEAR_SIMPLEX_INTERPOLATION !<Linear Simplex interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION = BASIS_QUADRATIC_SIMPLEX_INTERPOLATION !<Quadratic Simplex interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_CUBIC_SIMPLEX_INTERPOLATION = BASIS_CUBIC_SIMPLEX_INTERPOLATION !<Cubic Simplex interpolation specification \see OpenCMISS_BasisInterpolationSpecifications,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_BasisQuadratureSchemes OpenCMISS::Basis::Constants::QuadratureSchemes
  !> \brief Quadrature scheme parameters
  !> \see OpenCMISS::Basis::Constants,OpenCMISS::Basis
  !>@{
  INTEGER(INTG), PARAMETER :: OC_BASIS_DEFAULT_QUADRATURE_SCHEME = BASIS_DEFAULT_QUADRATURE_SCHEME !<Identifier for the default quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_LOW_QUADRATURE_SCHEME = BASIS_LOW_QUADRATURE_SCHEME !<Identifier for a low order quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_MID_QUADRATURE_SCHEME = BASIS_MID_QUADRATURE_SCHEME !<Identifier for a mid order quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_HIGH_QUADRATURE_SCHEME = BASIS_HIGH_QUADRATURE_SCHEME !<Identifier for a high order quadrature scheme \see OpenCMISS_BasisQuadratureSchemes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_BasisQuadratureTypes OpenCMISS::Basis::Constants::QuadratureTypes
  !> \brief Basis quadrature type parameters.
  !> \see OpenCMISS::Basis::Constants,OpenCMISS::Basis
  !>@{
  INTEGER(INTG), PARAMETER :: OC_BASIS_GAUSS_LEGENDRE_QUADRATURE = BASIS_GAUSS_LEGENDRE_QUADRATURE !<Gauss-Legendre quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_GAUSS_LAGUERRE_QUADRATURE = BASIS_GAUSS_LAGUERRE_QUADRATURE !<Gauss-Laguerre quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_GUASS_HERMITE_QUADRATURE = BASIS_GUASS_HERMITE_QUADRATURE !<Gauss-Hermite quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE = BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE !<Adaptive Gauss-Legendre quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_GAUSS_SIMPLEX_QUADRATURE = BASIS_GAUSS_SIMPLEX_QUADRATURE !<Gauss-Legendre for Simplex elements quadrature \see OpenCMISS_BasisQuadratureTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_BasisXiCollapse OpenCMISS::Basis::Constants::XiCollapse
  !> \brief Basis Xi collapse parameters.
  !> \see OpenCMISS::Basis::Constants,OpenCMISS::Basis
  !>@{
  INTEGER(INTG), PARAMETER :: OC_BASIS_XI_COLLAPSED = BASIS_XI_COLLAPSED !<The Xi direction is collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_COLLAPSED_AT_XI0 = BASIS_COLLAPSED_AT_XI0 !<The Xi direction at the xi=0 end of this Xi direction is collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_COLLAPSED_AT_XI1 = BASIS_COLLAPSED_AT_XI1 !<The Xi direction at the xi=1 end of this Xi direction is collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_BASIS_NOT_COLLAPSED = BASIS_NOT_COLLAPSED !<The Xi direction is not collapsed \see OpenCMISS_BasisXiCollapse,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !> \addtogroup OpenCMISS_Basis OpenCMISS::Basis
  !>@{
  !>Returns the collapsed Xi flags for a basis.
  INTERFACE OC_Basis_CollapsedXiGet
    MODULE PROCEDURE OC_Basis_CollapsedXiGetNumber
    MODULE PROCEDURE OC_Basis_CollapsedXiGetObj
  END INTERFACE OC_Basis_CollapsedXiGet

  !>Sets/changes the collapsed Xi flags for a basis.
  INTERFACE OC_Basis_CollapsedXiSet
    MODULE PROCEDURE OC_Basis_CollapsedXiSetNumber
    MODULE PROCEDURE OC_Basis_CollapsedXiSetObj
  END INTERFACE OC_Basis_CollapsedXiSet

  !>Finishes the creation of a new basis. \see OpenCMISS::OC_Basis_CreateStart
  INTERFACE OC_Basis_CreateFinish
    MODULE PROCEDURE OC_Basis_CreateFinishNumber
    MODULE PROCEDURE OC_Basis_CreateFinishObj
  END INTERFACE OC_Basis_CreateFinish

  !>Starts the creation of a new basis. \see OpenCMISS::OC_Basis_CreateFinish
  INTERFACE OC_Basis_CreateStart
    MODULE PROCEDURE OC_Basis_CreateStartNumber
    MODULE PROCEDURE OC_Basis_CreateStartObj
  END INTERFACE OC_Basis_CreateStart

  !>Destroys a basis.
  INTERFACE OC_Basis_Destroy
    MODULE PROCEDURE OC_Basis_DestroyNumber
    MODULE PROCEDURE OC_Basis_DestroyObj
  END INTERFACE OC_Basis_Destroy

  !>Get the interpolation type in each Xi directions for a basis.
  INTERFACE OC_Basis_InterpolationXiGet
    MODULE PROCEDURE OC_Basis_InterpolationXiGetNumber
    MODULE PROCEDURE OC_Basis_InterpolationXiGetObj
  END INTERFACE OC_Basis_InterpolationXiGet

  !>Sets/changes the interpolation type in each Xi directions for a basis.
  INTERFACE OC_Basis_InterpolationXiSet
    MODULE PROCEDURE OC_Basis_InterpolationXiSetNumber0
    MODULE PROCEDURE OC_Basis_InterpolationXiSetNumber1
    MODULE PROCEDURE OC_Basis_InterpolationXiSetObj0
    MODULE PROCEDURE OC_Basis_InterpolationXiSetObj1
  END INTERFACE OC_Basis_InterpolationXiSet

  !>Returns the number of local nodes in a basis.
  INTERFACE OC_Basis_NumberOfLocalNodesGet
    MODULE PROCEDURE OC_Basis_NumberOfLocalNodesGetNumber
    MODULE PROCEDURE OC_Basis_NumberOfLocalNodesGetObj
  END INTERFACE OC_Basis_NumberOfLocalNodesGet

  !>Returns the number of Xi directions in a basis.
  INTERFACE OC_Basis_NumberOfXiGet
    MODULE PROCEDURE OC_Basis_NumberOfXiGetNumber
    MODULE PROCEDURE OC_Basis_NumberOfXiGetObj
  END INTERFACE OC_Basis_NumberOfXiGet

  !>Sets/changes the number of Xi directions in a basis.
  INTERFACE OC_Basis_NumberOfXiSet
    MODULE PROCEDURE OC_Basis_NumberOfXiSetNumber
    MODULE PROCEDURE OC_Basis_NumberOfXiSetObj
  END INTERFACE OC_Basis_NumberOfXiSet

  !>Returns the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE OC_Basis_QuadratureNumberOfGaussXiGet
    MODULE PROCEDURE OC_Basis_QuadratureNumberOfGaussXiGetNumber
    MODULE PROCEDURE OC_Basis_QuadratureNumberOfGaussXiGetObj
  END INTERFACE OC_Basis_QuadratureNumberOfGaussXiGet

  !>Sets/changes the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE OC_Basis_QuadratureNumberOfGaussXiSet
    MODULE PROCEDURE OC_Basis_QuadratureNumberOfGaussXiSetNumber0
    MODULE PROCEDURE OC_Basis_QuadratureNumberOfGaussXiSetNumber1
    MODULE PROCEDURE OC_Basis_QuadratureNumberOfGaussXiSetObj0
    MODULE PROCEDURE OC_Basis_QuadratureNumberOfGaussXiSetObj1
  END INTERFACE OC_Basis_QuadratureNumberOfGaussXiSet

  !>Returns the xi positions of Gauss points on a basis quadrature.
  INTERFACE OC_Basis_QuadratureGaussXiGet
    MODULE PROCEDURE OC_Basis_QuadratureGaussXiGetNumber0
    MODULE PROCEDURE OC_Basis_QuadratureGaussXiGetObj0
    MODULE PROCEDURE OC_Basis_QuadratureGaussXiGetNumber1
    MODULE PROCEDURE OC_Basis_QuadratureGaussXiGetObj1
  END INTERFACE OC_Basis_QuadratureGaussXiGet

  !>Returns the order of quadrature for a basis quadrature.
  INTERFACE OC_Basis_QuadratureOrderGet
    MODULE PROCEDURE OC_Basis_QuadratureOrderGetNumber
    MODULE PROCEDURE OC_Basis_QuadratureOrderGetObj
  END INTERFACE OC_Basis_QuadratureOrderGet

  !>Sets/changes the order of quadrature for a basis quadrature.
  INTERFACE OC_Basis_QuadratureOrderSet
    MODULE PROCEDURE OC_Basis_QuadratureOrderSetNumber
    MODULE PROCEDURE OC_Basis_QuadratureOrderSetObj
  END INTERFACE OC_Basis_QuadratureOrderSet

  !>Returns the quadrature type for a basis quadrature.
  INTERFACE OC_Basis_QuadratureTypeGet
    MODULE PROCEDURE OC_Basis_QuadratureTypeGetNumber
    MODULE PROCEDURE OC_Basis_QuadratureTypeGetObj
  END INTERFACE OC_Basis_QuadratureTypeGet

  !>Sets/changes the quadrature type for a basis quadrature.
  INTERFACE OC_Basis_QuadratureTypeSet
    MODULE PROCEDURE OC_Basis_QuadratureTypeSetNumber
    MODULE PROCEDURE OC_Basis_QuadratureTypeSetObj
  END INTERFACE OC_Basis_QuadratureTypeSet

  !>Sets/changes the local face gauss evaluatoin flag for a basis quadrature.
  INTERFACE OC_Basis_QuadratureLocalFaceGaussEvaluateSet
    MODULE PROCEDURE OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber
    MODULE PROCEDURE OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj
  END INTERFACE OC_Basis_QuadratureLocalFaceGaussEvaluateSet

  !>Returns the type of a basis.
  INTERFACE OC_Basis_TypeGet
    MODULE PROCEDURE OC_Basis_TypeGetNumber
    MODULE PROCEDURE OC_Basis_TypeGetObj
  END INTERFACE OC_Basis_TypeGet

  !>Sets/changes the type of a basis.
  INTERFACE OC_Basis_TypeSet
    MODULE PROCEDURE OC_Basis_TypeSetNumber
    MODULE PROCEDURE OC_Basis_TypeSetObj
  END INTERFACE OC_Basis_TypeSet
  
  !>@}
  
  PUBLIC OC_BASIS_LAGRANGE_HERMITE_TP_TYPE,OC_BASIS_SIMPLEX_TYPE,OC_BASIS_SERENDIPITY_TYPE,OC_BASIS_AUXILLIARY_TYPE, &
    & OC_BASIS_B_SPLINE_TP_TYPE,OC_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE,OC_BASIS_EXTENDED_LAGRANGE_TP_TYPE

  PUBLIC OC_BASIS_LINEAR_LAGRANGE_INTERPOLATION,OC_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION, &
    & OC_BASIS_CUBIC_LAGRANGE_INTERPOLATION, &
    & OC_BASIS_CUBIC_HERMITE_INTERPOLATION,OC_BASIS_QUADRATIC1_HERMITE_INTERPOLATION, &
    & OC_BASIS_QUADRATIC2_HERMITE_INTERPOLATION, &
    & OC_BASIS_LINEAR_SIMPLEX_INTERPOLATION,OC_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION,OC_BASIS_CUBIC_SIMPLEX_INTERPOLATION

  PUBLIC OC_BASIS_DEFAULT_QUADRATURE_SCHEME,OC_BASIS_LOW_QUADRATURE_SCHEME,OC_BASIS_MID_QUADRATURE_SCHEME, &
    & OC_BASIS_HIGH_QUADRATURE_SCHEME

  PUBLIC OC_BASIS_GAUSS_LEGENDRE_QUADRATURE,OC_BASIS_GAUSS_LAGUERRE_QUADRATURE,OC_BASIS_GUASS_HERMITE_QUADRATURE, &
    & OC_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE,OC_BASIS_GAUSS_SIMPLEX_QUADRATURE

  PUBLIC OC_BASIS_XI_COLLAPSED,OC_BASIS_COLLAPSED_AT_XI0,OC_BASIS_COLLAPSED_AT_XI1,OC_BASIS_NOT_COLLAPSED

  PUBLIC OC_Basis_CollapsedXiGet,OC_Basis_CollapsedXiSet

  PUBLIC OC_Basis_CreateFinish,OC_Basis_CreateStart,OC_Basis_Destroy

  PUBLIC OC_Basis_InterpolationXiGet,OC_Basis_InterpolationXiSet

  PUBLIC OC_Basis_NumberOfLocalNodesGet

  PUBLIC OC_Basis_NumberOfXiGet,OC_Basis_NumberOfXiSet

  PUBLIC OC_Basis_QuadratureNumberOfGaussXiGet,OC_Basis_QuadratureNumberOfGaussXiSet

  PUBLIC OC_Basis_QuadratureGaussXiGet

  PUBLIC OC_Basis_QuadratureOrderGet,OC_Basis_QuadratureOrderSet

  PUBLIC OC_Basis_QuadratureTypeGet,OC_Basis_QuadratureTypeSet,OC_Basis_QuadratureLocalFaceGaussEvaluateSet

  PUBLIC OC_Basis_TypeGet,OC_Basis_TypeSet

  !==================================================================================================================================
  !
  ! BoundaryConditionsRoutines
  !
  !==================================================================================================================================

  !Module parameters


  !> \addtogroup OpenCMISS_BoundaryConditionsConstants OpenCMISS::BoundaryConditions::Constants
  !> \brief Boundary conditions constants.
  !>@{
  !> \addtogroup OpenCMISS_BoundaryConditionsTypes OpenCMISS::BoundaryConditions::Types
  !> \brief Specific boundary condition types, which might only be applicable to certain equation sets.
  !> \see OpenCMISS::BoundaryConditions,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_NONE = BOUNDARY_CONDITION_NONE !<The dof is free.
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED = BOUNDARY_CONDITION_FIXED !<The dof is fixed as a boundary condition.
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_WALL = BOUNDARY_CONDITION_FIXED_WALL
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_INLET = BOUNDARY_CONDITION_FIXED_INLET
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_OUTLET = BOUNDARY_CONDITION_FIXED_OUTLET
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_MOVED_WALL = BOUNDARY_CONDITION_MOVED_WALL
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED = BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FREE_WALL = BOUNDARY_CONDITION_FREE_WALL
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_NEUMANN_POINT = BOUNDARY_CONDITION_NEUMANN_POINT !<Specify the normal derivative at a node, which is then integrated to find the nodal load term
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED = BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED !<Specify the normal derivative at a node, which is then integrated to find the nodal load term. The value is incremented inside a load incremented control loop.
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_NEUMANN_INTEGRATED = BOUNDARY_CONDITION_NEUMANN_INTEGRATED !<Set the integrated right hand side load value directly
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_DIRICHLET = BOUNDARY_CONDITION_DIRICHLET
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_CAUCHY = BOUNDARY_CONDITION_CAUCHY
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_ROBIN = BOUNDARY_CONDITION_ROBIN

  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_INCREMENTED = BOUNDARY_CONDITION_FIXED_INCREMENTED
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_PRESSURE = BOUNDARY_CONDITION_PRESSURE
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_PRESSURE = BOUNDARY_CONDITION_FIXED_PRESSURE
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_PRESSURE_INCREMENTED = BOUNDARY_CONDITION_PRESSURE_INCREMENTED

  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE = BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_IMPERMEABLE_WALL = BOUNDARY_CONDITION_IMPERMEABLE_WALL
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY = BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY !<A Neumann integrated boundary condition, and no point values will be integrated over a face or line that includes this dof
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_FITTED = BOUNDARY_CONDITION_FIXED_FITTED
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_NONREFLECTING = BOUNDARY_CONDITION_FIXED_NONREFLECTING
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_CELLML = BOUNDARY_CONDITION_FIXED_CELLML
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FIXED_STREE = BOUNDARY_CONDITION_FIXED_STREE
  !>@}
  !> \addtogroup OpenCMISS_BoundaryConditionSparsityTypes OpenCMISS::BoundaryConditions::SparsityTypes
  !> \brief Storage type for matrices used by boundary conditions.
  !> \see OpenCMISS::BoundaryConditions,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_SPARSE_MATRICES = BOUNDARY_CONDITION_SPARSE_MATRICES
  INTEGER(INTG), PARAMETER :: OC_BOUNDARY_CONDITION_FULL_MATRICES = BOUNDARY_CONDITION_FULL_MATRICES
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys boundary conditions.
  INTERFACE OC_BoundaryConditions_Destroy
    MODULE PROCEDURE OC_BoundaryConditions_DestroyNumber0
    MODULE PROCEDURE OC_BoundaryConditions_DestroyNumber1
    MODULE PROCEDURE OC_BoundaryConditions_DestroyObj
  END INTERFACE OC_BoundaryConditions_Destroy

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant.
  INTERFACE OC_BoundaryConditions_AddConstant
    MODULE PROCEDURE OC_BoundaryConditions_AddConstantNumber
    MODULE PROCEDURE OC_BoundaryConditions_AddConstantObj
  END INTERFACE OC_BoundaryConditions_AddConstant

  !>Sets the value of the specified constant as a boundary condition on the specified constant.
  INTERFACE OC_BoundaryConditions_SetConstant
    MODULE PROCEDURE OC_BoundaryConditions_SetConstantNumber
    MODULE PROCEDURE OC_BoundaryConditions_SetConstantObj
  END INTERFACE OC_BoundaryConditions_SetConstant

  !>Adds to the value of the element constant and sets this as a boundary condition on the specified element.
  INTERFACE OC_BoundaryConditions_AddElement
    MODULE PROCEDURE OC_BoundaryConditions_AddElementNumber
    MODULE PROCEDURE OC_BoundaryConditions_AddElementObj
  END INTERFACE OC_BoundaryConditions_AddElement

  !>Sets the value of the specified element as a boundary condition on the specified element.
  INTERFACE OC_BoundaryConditions_SetElement
    MODULE PROCEDURE OC_BoundaryConditions_SetElementNumber
    MODULE PROCEDURE OC_BoundaryConditions_SetElementObj
  END INTERFACE OC_BoundaryConditions_SetElement

  !>Adds to the value of the node constant and sets this as a boundary condition on the specified node.
  INTERFACE OC_BoundaryConditions_AddNode
    MODULE PROCEDURE OC_BoundaryConditions_AddNodeNumber
    MODULE PROCEDURE OC_BoundaryConditions_AddNodeObj
  END INTERFACE OC_BoundaryConditions_AddNode

  !>Sets the value of the specified node as a boundary condition on the specified node.
  INTERFACE OC_BoundaryConditions_SetNode
    MODULE PROCEDURE OC_BoundaryConditions_SetNodeNumber0
    MODULE PROCEDURE OC_BoundaryConditions_SetNodeNumber1
    MODULE PROCEDURE OC_BoundaryConditions_SetNodeObj
  END INTERFACE OC_BoundaryConditions_SetNode

  !>Sets the matrix sparsity type for Neumann integration matrices, used when integrating Neumann point values.
  INTERFACE OC_BoundaryConditions_NeumannSparsityTypeSet
    MODULE PROCEDURE OC_BoundaryConditions_NeumannSparsityTypeSetNumber0
    MODULE PROCEDURE OC_BoundaryConditions_NeumannSparsityTypeSetNumber1
    MODULE PROCEDURE OC_BoundaryConditions_NeumannSparsityTypeSetObj
  END INTERFACE OC_BoundaryConditions_NeumannSparsityTypeSet

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  INTERFACE OC_BoundaryConditions_ConstrainNodeDofsEqual
    MODULE PROCEDURE OC_BoundaryConditions_ConstrainNodeDofsEqualNumber
    MODULE PROCEDURE OC_BoundaryConditions_ConstrainNodeDofsEqualObj
  END INTERFACE OC_BoundaryConditions_ConstrainNodeDofsEqual

  PUBLIC OC_BOUNDARY_CONDITION_NONE,OC_BOUNDARY_CONDITION_FIXED, &
    & OC_BOUNDARY_CONDITION_FIXED_WALL,OC_BOUNDARY_CONDITION_FIXED_INLET,OC_BOUNDARY_CONDITION_MOVED_WALL, &
    & OC_BOUNDARY_CONDITION_FREE_WALL,OC_BOUNDARY_CONDITION_FIXED_OUTLET,OC_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED, &
    & OC_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE,OC_BOUNDARY_CONDITION_IMPERMEABLE_WALL, &
    & OC_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY,OC_BOUNDARY_CONDITION_FIXED_FITTED, &
    & OC_BOUNDARY_CONDITION_FIXED_NONREFLECTING,OC_BOUNDARY_CONDITION_FIXED_CELLML,OC_BOUNDARY_CONDITION_FIXED_STREE

  PUBLIC OC_BOUNDARY_CONDITION_NEUMANN_POINT,OC_BOUNDARY_CONDITION_NEUMANN_INTEGRATED,OC_BOUNDARY_CONDITION_DIRICHLET
  PUBLIC OC_BOUNDARY_CONDITION_CAUCHY,OC_BOUNDARY_CONDITION_ROBIN,OC_BOUNDARY_CONDITION_FIXED_INCREMENTED
  PUBLIC OC_BOUNDARY_CONDITION_PRESSURE,OC_BOUNDARY_CONDITION_FIXED_PRESSURE,OC_BOUNDARY_CONDITION_PRESSURE_INCREMENTED
  PUBLIC OC_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED

  PUBLIC OC_BOUNDARY_CONDITION_SPARSE_MATRICES,OC_BOUNDARY_CONDITION_FULL_MATRICES

  PUBLIC OC_BoundaryConditions_Destroy

  PUBLIC OC_BoundaryConditions_AddConstant,OC_BoundaryConditions_SetConstant

  PUBLIC OC_BoundaryConditions_AddElement,OC_BoundaryConditions_SetElement

  PUBLIC OC_BoundaryConditions_AddNode,OC_BoundaryConditions_SetNode

  PUBLIC OC_BoundaryConditions_NeumannSparsityTypeSet

  PUBLIC OC_BoundaryConditions_ConstrainNodeDofsEqual

  !==================================================================================================================================
  !
  ! CMISS
  !
  !==================================================================================================================================

  !Module parameters
  !> \addtogroup OpenCMISS_Constants OpenCMISS::Constants
  !> \brief CMISS constants.
  !>@{
  !> \addtogroup OpenCMISS_ErrorHandlingModes OpenCMISS::Constants::ErrorHandlingModes
  !> \brief CMISS error handling mode parameters
  !> \see OpenCMISS::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_ERRORS_RETURN_ERROR_CODE = OC_RETURN_ERROR_CODE !<Just return the error code \see OpenCMISS_ErrorHandlingModes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ERRORS_OUTPUT_ERROR = OC_OUTPUT_ERROR !<Output the error traceback and return the error code \see OpenCMISS_ErrorHandlingModes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ERRORS_TRAP_ERROR = OC_TRAP_ERROR!<Trap the error by outputing the error traceback and stopping the program \see OpenCMISS_ErrorHandlingModes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Extracts the OpenCMISS error message.
  INTERFACE OC_ExtractErrorMessage
    MODULE PROCEDURE OC_ExtractErrorMessageC
    MODULE PROCEDURE OC_ExtractErrorMessageVS
  END INTERFACE OC_ExtractErrorMessage

  !>Extracts the OpenCMISS error stack.
  INTERFACE OC_ExtractErrorStack
    MODULE PROCEDURE OC_ExtractErrorStackC
    MODULE PROCEDURE OC_ExtractErrorStackVS
  END INTERFACE OC_ExtractErrorStack

  PUBLIC OC_ERRORS_RETURN_ERROR_CODE,OC_ERRORS_OUTPUT_ERROR,OC_ERRORS_TRAP_ERROR

  PUBLIC OC_ErrorHandlingModeGet,OC_ErrorHandlingModeSet

  PUBLIC OC_ExtractErrorMessage,OC_ExtractErrorStack

  !==================================================================================================================================
  !
  ! CellML
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_CellMLConstants OpenCMISS::CellML::Constants
  !> \brief CellML constants.
  !>@{
  !> \addtogroup OpenCMISS_CellMLFieldTypes OpenCMISS::CellML::FieldTypes
  !> \brief CellML field type parameters.
  !> \see OpenCMISS::CellML,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_CELLML_MODELS_FIELD = CELLML_MODELS_FIELD !<CellML models field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CELLML_STATE_FIELD = CELLML_STATE_FIELD !<CellML state field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CELLML_INTERMEDIATE_FIELD = CELLML_INTERMEDIATE_FIELD !<CellML intermediate field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CELLML_PARAMETERS_FIELD = CELLML_PARAMETERS_FIELD !<CellML parameters field type \see OpenCMISS_CellMLFieldTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Set a CellML model variable as being known (the value will be set from an OpenCMISS field)
  INTERFACE OC_CellML_VariableSetAsKnown
    MODULE PROCEDURE OC_CellML_VariableSetAsKnownNumberC
    MODULE PROCEDURE OC_CellML_VariableSetAsKnownObjC
    MODULE PROCEDURE OC_CellML_VariableSetAsKnownNumberVS
    MODULE PROCEDURE OC_CellML_VariableSetAsKnownObjVS
  END INTERFACE OC_CellML_VariableSetAsKnown

  !>Set a CellML model variable as being wanted (the value will be extracted from the model to an OpenCMISS field)
  INTERFACE OC_CellML_VariableSetAsWanted
    MODULE PROCEDURE OC_CellML_VariableSetAsWantedNumberC
    MODULE PROCEDURE OC_CellML_VariableSetAsWantedObjC
    MODULE PROCEDURE OC_CellML_VariableSetAsWantedNumberVS
    MODULE PROCEDURE OC_CellML_VariableSetAsWantedObjVS
  END INTERFACE OC_CellML_VariableSetAsWanted

  !>Map a CellML model variable to a field variable component in this CellML environment.
  INTERFACE OC_CellML_CreateCellMLToFieldMap
    MODULE PROCEDURE OC_CellML_CreateCellMLToFieldMapNumberC
    MODULE PROCEDURE OC_CellML_CreateCellMLToFieldMapObjC
    MODULE PROCEDURE OC_CellML_CreateCellMLToFieldMapNumberVS
    MODULE PROCEDURE OC_CellML_CreateCellMLToFieldMapObjVS
  END INTERFACE OC_CellML_CreateCellMLToFieldMap

  !>Map a field variable component to a CellML model variable in this CellML environment.
  INTERFACE OC_CellML_CreateFieldToCellMLMap
    MODULE PROCEDURE OC_CellML_CreateFieldToCellMLMapNumberC
    MODULE PROCEDURE OC_CellML_CreateFieldToCellMLMapObjC
    MODULE PROCEDURE OC_CellML_CreateFieldToCellMLMapNumberVS
    MODULE PROCEDURE OC_CellML_CreateFieldToCellMLMapObjVS
  END INTERFACE OC_CellML_CreateFieldToCellMLMap

  !>Finishes the creation of a CellML environment. \see OpenCMISS::OC_CellML_CreateStart
  INTERFACE OC_CellML_CreateFinish
    MODULE PROCEDURE OC_CellML_CreateFinishNumber
    MODULE PROCEDURE OC_CellML_CreateFinishObj
  END INTERFACE OC_CellML_CreateFinish

  !>Starts the creation of a CellML environment. \see OpenCMISS::OC_CellML_CreateFinish
  INTERFACE OC_CellML_CreateStart
    MODULE PROCEDURE OC_CellML_CreateStartNumber
    MODULE PROCEDURE OC_CellML_CreateStartObj
  END INTERFACE OC_CellML_CreateStart

  !>Destroys a CellML environment.
  INTERFACE OC_CellML_Destroy
    MODULE PROCEDURE OC_CellML_DestroyNumber
    MODULE PROCEDURE OC_CellML_DestroyObj
  END INTERFACE OC_CellML_Destroy

  !>Finishes the creation of field maps for a CellML environment. \see OpenCMISS::OC_CellML_FieldMapsCreateStart
  INTERFACE OC_CellML_FieldMapsCreateFinish
    MODULE PROCEDURE OC_CellML_FieldMapsCreateFinishNumber
    MODULE PROCEDURE OC_CellML_FieldMapsCreateFinishObj
  END INTERFACE OC_CellML_FieldMapsCreateFinish

  !>Starts the creation of field maps for a CellML environment. \see OpenCMISS::OC_CellML_FieldMapsCreateFinish
  INTERFACE OC_CellML_FieldMapsCreateStart
    MODULE PROCEDURE OC_CellML_FieldMapsCreateStartNumber
    MODULE PROCEDURE OC_CellML_FieldMapsCreateStartObj
  END INTERFACE OC_CellML_FieldMapsCreateStart

  !>Imports the specified CellML model into a CellML models environment.
  INTERFACE OC_CellML_ModelImport
    MODULE PROCEDURE OC_CellML_ModelImportNumberC
    MODULE PROCEDURE OC_CellML_ModelImportObjC
    MODULE PROCEDURE OC_CellML_ModelImportNumberVS
    MODULE PROCEDURE OC_CellML_ModelImportObjVS
  END INTERFACE OC_CellML_ModelImport

  !>Finishes the creation of CellML models field. \see OpenCMISS::OC_CellML_ModelsFieldCreateStart
  INTERFACE OC_CellML_ModelsFieldCreateFinish
    MODULE PROCEDURE OC_CellML_ModelsFieldCreateFinishNumber
    MODULE PROCEDURE OC_CellML_ModelsFieldCreateFinishObj
  END INTERFACE OC_CellML_ModelsFieldCreateFinish

  !>Starts the creation of CellML models field. \see OpenCMISS::OC_CellML_ModelsFieldCreateFinish
  INTERFACE OC_CellML_ModelsFieldCreateStart
    MODULE PROCEDURE OC_CellML_ModelsFieldCreateStartNumber
    MODULE PROCEDURE OC_CellML_ModelsFieldCreateStartObj
  END INTERFACE OC_CellML_ModelsFieldCreateStart

  !>Returns the CellML models field for a CellML environment.
  INTERFACE OC_CellML_ModelsFieldGet
    MODULE PROCEDURE OC_CellML_ModelsFieldGetNumber
    MODULE PROCEDURE OC_CellML_ModelsFieldGetObj
  END INTERFACE OC_CellML_ModelsFieldGet

  !>Finishes the creation of CellML state field. \see OpenCMISS::OC_CellML_StateFieldCreateStart
  INTERFACE OC_CellML_StateFieldCreateFinish
    MODULE PROCEDURE OC_CellML_StateFieldCreateFinishNumber
    MODULE PROCEDURE OC_CellML_StateFieldCreateFinishObj
  END INTERFACE OC_CellML_StateFieldCreateFinish

  !>Starts the creation of CellML state field. \see OpenCMISS::OC_CellML_StateFieldCreateFinish
  INTERFACE OC_CellML_StateFieldCreateStart
    MODULE PROCEDURE OC_CellML_StateFieldCreateStartNumber
    MODULE PROCEDURE OC_CellML_StateFieldCreateStartObj
  END INTERFACE OC_CellML_StateFieldCreateStart

  !>Returns the CellML state field for a CellML environment.
  INTERFACE OC_CellML_StateFieldGet
    MODULE PROCEDURE OC_CellML_StateFieldGetNumber
    MODULE PROCEDURE OC_CellML_StateFieldGetObj
  END INTERFACE OC_CellML_StateFieldGet

  !>Returns the component for a given CellML field that corresponds to the specified CellML variable ID.
  INTERFACE OC_CellML_FieldComponentGet
    MODULE PROCEDURE OC_CellML_FieldComponentGetNumberC
    MODULE PROCEDURE OC_CellML_FieldComponentGetObjC
    MODULE PROCEDURE OC_CellML_FieldComponentGetNumberVS
    MODULE PROCEDURE OC_CellML_FieldComponentGetObjVS
  END INTERFACE OC_CellML_FieldComponentGet

  !>Finishes the creation of CellML intermediate field. \see OpenCMISS::OC_CellML_IntermediateFieldCreateStart
  INTERFACE OC_CellML_IntermediateFieldCreateFinish
    MODULE PROCEDURE OC_CellML_IntermediateFieldCreateFinishNumber
    MODULE PROCEDURE OC_CellML_IntermediateFieldCreateFinishObj
  END INTERFACE OC_CellML_IntermediateFieldCreateFinish

  !>Starts the creation of CellML intermediate field. \see OpenCMISS::OC_CellML_IntermediateFieldCreateFinish
  INTERFACE OC_CellML_IntermediateFieldCreateStart
    MODULE PROCEDURE OC_CellML_IntermediateFieldCreateStartNumber
    MODULE PROCEDURE OC_CellML_IntermediateFieldCreateStartObj
  END INTERFACE OC_CellML_IntermediateFieldCreateStart

  !>Returns the CellML intermediate field for a CellML environment.
  INTERFACE OC_CellML_IntermediateFieldGet
    MODULE PROCEDURE OC_CellML_IntermediateFieldGetNumber
    MODULE PROCEDURE OC_CellML_IntermediateFieldGetObj
  END INTERFACE OC_CellML_IntermediateFieldGet

  !>Finishes the creation of CellML parameters field. \see OpenCMISS::OC_CellML_ParametersFieldCreateStart
  INTERFACE OC_CellML_ParametersFieldCreateFinish
    MODULE PROCEDURE OC_CellML_ParametersFieldCreateFinishNumber
    MODULE PROCEDURE OC_CellML_ParametersFieldCreateFinishObj
  END INTERFACE OC_CellML_ParametersFieldCreateFinish

  !>Starts the creation of CellML parameters field. \see OpenCMISS::OC_CellML_ParametersFieldCreateFinish
  INTERFACE OC_CellML_ParametersFieldCreateStart
    MODULE PROCEDURE OC_CellML_ParametersFieldCreateStartNumber
    MODULE PROCEDURE OC_CellML_ParametersFieldCreateStartObj
  END INTERFACE OC_CellML_ParametersFieldCreateStart

  !>Returns the CellML parameters field for a CellML environment.
  INTERFACE OC_CellML_ParametersFieldGet
    MODULE PROCEDURE OC_CellML_ParametersFieldGetNumber
    MODULE PROCEDURE OC_CellML_ParametersFieldGetObj
  END INTERFACE OC_CellML_ParametersFieldGet

  !>Validate and instantiate the specified CellML environment.
  INTERFACE OC_CellML_Generate
    MODULE PROCEDURE OC_CellML_GenerateNumber
    MODULE PROCEDURE OC_CellML_GenerateObj
  END INTERFACE OC_CellML_Generate

  PUBLIC OC_CELLML_MODELS_FIELD,OC_CELLML_STATE_FIELD,OC_CELLML_INTERMEDIATE_FIELD,OC_CELLML_PARAMETERS_FIELD

  PUBLIC OC_CellML_VariableSetAsKnown,OC_CellML_VariableSetAsWanted

  PUBLIC OC_CellML_CreateCellMLToFieldMap,OC_CellML_CreateFieldToCellMLMap

  PUBLIC OC_CellML_CreateFinish,OC_CellML_CreateStart

  PUBLIC OC_CellML_Destroy

  PUBLIC OC_CellML_FieldMapsCreateStart,OC_CellML_FieldMapsCreateFinish

  PUBLIC OC_CellML_ModelImport

  PUBLIC OC_CellML_ModelsFieldCreateFinish,OC_CellML_ModelsFieldCreateStart,OC_CellML_ModelsFieldGet

  PUBLIC OC_CellML_StateFieldCreateFinish,OC_CellML_StateFieldCreateStart,OC_CellML_StateFieldGet

  PUBLIC OC_CellML_FieldComponentGet

  PUBLIC OC_CellML_IntermediateFieldCreateFinish,OC_CellML_IntermediateFieldCreateStart

  PUBLIC OC_CellML_IntermediateFieldGet

  PUBLIC OC_CellML_ParametersFieldCreateFinish,OC_CellML_ParametersFieldCreateStart,OC_CellML_ParametersFieldGet

  PUBLIC OC_CellML_Generate

  !==================================================================================================================================
  !
  ! Computation
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Returns the number of world nodes in the computation environment
  INTERFACE OC_ComputationEnvironment_NumberOfWorldNodesGet
    MODULE PROCEDURE OC_ComputationEnvironment_NumberOfWorldNodesGetNumber
    MODULE PROCEDURE OC_ComputationEnvironment_NumberOfWorldNodesGetObj
  END INTERFACE OC_ComputationEnvironment_NumberOfWorldNodesGet

  !>Returns the world communicator for the computation environment
  INTERFACE OC_ComputationEnvironment_WorldCommunicatorGet
    MODULE PROCEDURE OC_ComputationEnvironment_WorldCommunicatorGetNumber
    MODULE PROCEDURE OC_ComputationEnvironment_WorldCommunicatorGetObj
  END INTERFACE OC_ComputationEnvironment_WorldCommunicatorGet

  !>Returns the world node number for the computation environment
  INTERFACE OC_ComputationEnvironment_WorldNodeNumberGet
    MODULE PROCEDURE OC_ComputationEnvironment_WorldNodeNumberGetNumber
    MODULE PROCEDURE OC_ComputationEnvironment_WorldNodeNumberGetObj
  END INTERFACE OC_ComputationEnvironment_WorldNodeNumberGet

  !>Returns the world work group for the computation environment
  INTERFACE OC_ComputationEnvironment_WorldWorkGroupGet
    MODULE PROCEDURE OC_ComputationEnvironment_WorldWorkGroupGetNumber
    MODULE PROCEDURE OC_ComputationEnvironment_WorldWorkGroupGetObj
  END INTERFACE OC_ComputationEnvironment_WorldWorkGroupGet

  !>Starts the creation of a work group
  INTERFACE OC_WorkGroup_CreateStart
    MODULE PROCEDURE OC_WorkGroup_CreateStartNumber
    MODULE PROCEDURE OC_WorkGroup_CreateStartObj
  END INTERFACE OC_WorkGroup_CreateStart

  !>Finishes the creation of a work group
  INTERFACE OC_WorkGroup_CreateFinish
    MODULE PROCEDURE OC_WorkGroup_CreateFinishNumber
    MODULE PROCEDURE OC_WorkGroup_CreateFinishObj
  END INTERFACE OC_WorkGroup_CreateFinish

  !>Destroys a work group
  INTERFACE OC_WorkGroup_Destroy
    MODULE PROCEDURE OC_WorkGroup_DestroyNumber
    MODULE PROCEDURE OC_WorkGroup_DestroyObj
  END INTERFACE OC_WorkGroup_Destroy

  !>Gets the group communicator for a work group
  INTERFACE OC_WorkGroup_GroupCommunicatorGet
    MODULE PROCEDURE OC_WorkGroup_GroupCommunicatorGetNumber
    MODULE PROCEDURE OC_WorkGroup_GroupCommunicatorGetObj
  END INTERFACE OC_WorkGroup_GroupCommunicatorGet

  !>Returns the label of a work group.
  INTERFACE OC_WorkGroup_LabelGet
    MODULE PROCEDURE OC_WorkGroup_LabelGetCNumber
    MODULE PROCEDURE OC_WorkGroup_LabelGetCObj
    MODULE PROCEDURE OC_WorkGroup_LabelGetVSNumber
    MODULE PROCEDURE OC_WorkGroup_LabelGetVSObj
  END INTERFACE OC_WorkGroup_LabelGet

  !>Sets/changes the label of a work group.
  INTERFACE OC_WorkGroup_LabelSet
    MODULE PROCEDURE OC_WorkGroup_LabelSetCNumber
    MODULE PROCEDURE OC_WorkGroup_LabelSetCObj
    MODULE PROCEDURE OC_WorkGroup_LabelSetVSNumber
    MODULE PROCEDURE OC_WorkGroup_LabelSetVSObj
  END INTERFACE OC_WorkGroup_LabelSet

  !>Gets the group node number in a work group
  INTERFACE OC_WorkGroup_GroupNodeNumberGet
    MODULE PROCEDURE OC_WorkGroup_GroupNodeNumberGetNumber
    MODULE PROCEDURE OC_WorkGroup_GroupNodeNumberGetObj
  END INTERFACE OC_WorkGroup_GroupNodeNumberGet

  !>Gets the number of group nodes in a work group
  INTERFACE OC_WorkGroup_NumberOfGroupNodesGet
    MODULE PROCEDURE OC_WorkGroup_NumberOfGroupNodesGetNumber
    MODULE PROCEDURE OC_WorkGroup_NumberOfGroupNodesGetObj
  END INTERFACE OC_WorkGroup_NumberOfGroupNodesGet

  !>Sets/changes the number of group nodes in a work group
  INTERFACE OC_WorkGroup_NumberOfGroupNodesSet
    MODULE PROCEDURE OC_WorkGroup_NumberOfGroupNodesSetNumber
    MODULE PROCEDURE OC_WorkGroup_NumberOfGroupNodesSetObj
  END INTERFACE OC_WorkGroup_NumberOfGroupNodesSet

  PUBLIC OC_ComputationEnvironment_NumberOfWorldNodesGet

  PUBLIC OC_ComputationEnvironment_WorldCommunicatorGet

  PUBLIC OC_ComputationEnvironment_WorldNodeNumberGet

  PUBLIC OC_ComputationEnvironment_WorldWorkGroupGet

  PUBLIC OC_WorkGroup_CreateStart

  PUBLIC OC_WorkGroup_CreateFinish

  PUBLIC OC_WorkGroup_Destroy

  PUBLIC OC_WorkGroup_GroupCommunicatorGet

  PUBLIC OC_WorkGroup_GroupNodeNumberGet

  PUBLIC OC_WorkGroup_LabelGet,OC_WorkGroup_LabelSet

  PUBLIC OC_WorkGroup_NumberOfGroupNodesGet,OC_WorkGroup_NumberOfGroupNodesSet

  !==================================================================================================================================
  !
  ! ContextRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Create a context
  INTERFACE OC_Context_Create
    MODULE PROCEDURE OC_Context_CreateNumber
    MODULE PROCEDURE OC_Context_CreateObj
  END INTERFACE OC_Context_Create

  !>Destroy a context
  INTERFACE OC_Context_Destroy
    MODULE PROCEDURE OC_Context_DestroyNumber
    MODULE PROCEDURE OC_Context_DestroyObj
  END INTERFACE OC_Context_Destroy

  !>Gets the computation environment for an OpenCMISS context.
  INTERFACE OC_Context_ComputationEnvironmentGet
    MODULE PROCEDURE OC_Context_ComputationEnvironmentGetNumber
    MODULE PROCEDURE OC_Context_ComputationEnvironmentGetObj
  END INTERFACE OC_Context_ComputationEnvironmentGet

  !>Gets the random seeds for an OpenCMISS context.
  INTERFACE OC_Context_RandomSeedsGet    
    MODULE PROCEDURE OC_Context_RandomSeedsGetNumber0
    MODULE PROCEDURE OC_Context_RandomSeedsGetNumber1
    MODULE PROCEDURE OC_Context_RandomSeedsGetObj0
    MODULE PROCEDURE OC_Context_RandomSeedsGetObj1
  END INTERFACE OC_Context_RandomSeedsGet

  !>Gets the size of the random seeds for an OpenCMISS context.
  INTERFACE OC_Context_RandomSeedsSizeGet    
    MODULE PROCEDURE OC_Context_RandomSeedsSizeGetNumber
    MODULE PROCEDURE OC_Context_RandomSeedsSizeGetObj
  END INTERFACE OC_Context_RandomSeedsSizeGet

  !>Sets the random seeds for an OpenCMISS context.
  INTERFACE OC_Context_RandomSeedsSet    
    MODULE PROCEDURE OC_Context_RandomSeedsSetNumber0
    MODULE PROCEDURE OC_Context_RandomSeedsSetNumber1
    MODULE PROCEDURE OC_Context_RandomSeedsSetObj0
    MODULE PROCEDURE OC_Context_RandomSeedsSetObj1
  END INTERFACE OC_Context_RandomSeedsSet

  !>Gets the world region for an OpenCMISS context.
  INTERFACE OC_Context_WorldRegionGet
    MODULE PROCEDURE OC_Context_WorldRegionGetNumber
    MODULE PROCEDURE OC_Context_WorldRegionGetObj
  END INTERFACE OC_Context_WorldRegionGet

  PUBLIC OC_Context_Create,OC_Context_Destroy

  PUBLIC OC_Context_ComputationEnvironmentGet

  PUBLIC OC_Context_RandomSeedsGet,OC_Context_RandomSeedsSizeGet,OC_Context_RandomSeedsSet

  PUBLIC OC_Context_UserNumberGet

  PUBLIC OC_Context_WorldRegionGet

  !==================================================================================================================================
  !
  ! Constants
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_Constants OpenCMISS::Constants
  !> \brief OpeCMISS constants.
  !>@{
  !> \addtogroup OpenCMISS_DataTypeConstants OpenCMISS::Constants::DataTypeConstants
  !> \brief Data type constants for base data types
  !> \see OpenCMISS_Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTEGER_TYPE = INTEGER_TYPE !<Integer data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SHORT_INTEGER_TYPE = SHORT_INTEGER_TYPE !<Short integer data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_LONG_INTEGER_TYPE = LONG_INTEGER_TYPE !<Long integer data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SINGLE_REAL_TYPE = SINGLE_REAL_TYPE !<Single precision real data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DOUBLE_REAL_TYPE = DOUBLE_REAL_TYPE !<Double precision real data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_QUADRAUPLE_REAL_TYPE = QUADRUPLE_REAL_TYPE !<Quadruple precision real data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CHARACTER_TYPE = CHARACTER_TYPE !<Character data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_LOGICAL_TYPE = LOGICAL_TYPE !<Logical data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SINGLE_COMPLEX_TYPE = SINGLE_COMPLEX_TYPE !<Single precision complex data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DOUBLE_COMPLEX_TYPE = DOUBLE_COMPLEX_TYPE !<Double precision complex data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_QUADRUPLE_COMPLEX_TYPE = QUADRUPLE_COMPLEX_TYPE !<Quadruple precision complex data type \see OpenCMISS_DataTypeConstants,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_GlobalDerivativeConstants OpenCMISS::Constants::GlobalDerivativeConstants
  !> \brief Global derivative constant identifiers
  !> \see OpenCMISS_Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_NO_GLOBAL_DERIV = NO_GLOBAL_DERIV !<No global derivative i.e., u \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S1 = GLOBAL_DERIV_S1 !<First global derivative in the s1 direction i.e., du/ds1 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S2 = GLOBAL_DERIV_S2 !<First global derivative in the s2 direction i.e., du/ds2 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S1_S2 = GLOBAL_DERIV_S1_S2 !<Global Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S3 = GLOBAL_DERIV_S3 !<First global derivative in the s3 direction i.e., du/ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S1_S3 = GLOBAL_DERIV_S1_S3 !<Global Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S2_S3 = GLOBAL_DERIV_S2_S3 !<Global Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GLOBAL_DERIV_S1_S2_S3 = GLOBAL_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OpenCMISS_GlobalDerivativeConstants,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_PartialDerivativeConstants OpenCMISS::Constants::PartialDerivativeConstants
  !> \brief Partial derivative constant identifiers
  !> \see OpenCMISS_Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_NO_PARTIAL_DERIV=NO_PART_DERIV !<No partial derivative i.e., u \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1=PART_DERIV_S1 !<First partial derivative in the s1 direction i.e., du/ds1 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S1=PART_DERIV_S1_S1 !<Second partial derivative in the s1 direction i.e., d^2u/ds1ds1 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S2=PART_DERIV_S2 !<First partial derivative in the s2 direction i.e., du/ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S2_S2=PART_DERIV_S2_S2 !<Second partial derivative in the s2 direction i.e., d^2u/ds2ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S2=PART_DERIV_S1_S2 !<Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S3=PART_DERIV_S3 !<First partial derivative in the s3 direction i.e., du/ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S3_S3=PART_DERIV_S3_S3 !<Second partial derivative in the s3 direction i.e., d^2u/ds3ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S3=PART_DERIV_S1_S3 !<Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S2_S3=PART_DERIV_S2_S3 !<Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S2_S3=PART_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S4=PART_DERIV_S4 !<First partial derivative in the s4 direction i.e., du/ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S4_S4=PART_DERIV_S4_S4 !<Second partial derivative in the s4 direction i.e., d^2u/ds4ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S4=PART_DERIV_S1_S4 !<Cross derivative in the s1 and s4 direction i.e., d^2u/ds1ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S2_S4=PART_DERIV_S2_S4 !<Cross derivative in the s2 and s4 direction i.e., d^2u/ds2ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S3_S4=PART_DERIV_S3_S4 !<Cross derivative in the s3 and s4 direction i.e., d^2u/ds3ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S2_S4=PART_DERIV_S1_S2_S4 !<Cross derivative in the s1, s2 and s4 direction i.e., d^3u/ds1ds2ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S3_S4=PART_DERIV_S1_S3_S4 !<Cross derivative in the s1, s3 and s4 direction i.e., d^3u/ds1ds3ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S2_S3_S4=PART_DERIV_S2_S3_S4 !<Cross derivative in the s2, s3 and s4 direction i.e., d^3u/ds2ds3ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S1_S2=PART_DERIV_S1_S1_S2 !<Cross derivative in the s1, s1 and s2 direction i.e., d^3u/ds1^2ds2 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS  
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S1_S3=PART_DERIV_S1_S1_S3 !<Cross derivative in the s1, s1 and s3 direction i.e., d^3u/ds1^2ds3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS  
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S1_S4=PART_DERIV_S1_S1_S4 !<Cross derivative in the s1, s1 and s4 direction i.e., d^3u/ds1^2ds4 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS  
  INTEGER(INTG), PARAMETER :: OC_PARTIAL_DERIV_S1_S1_S1=PART_DERIV_S1_S1_S1 !<Third partial derivative in the s1 direction i.e., d^3u/ds1^3 \see OpenCMISS_PartialDerivativeConstants,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_ElementNormalXiDirections OpenCMISS::Constants::ElementNormalXiDirections
  !> \brief Xi directions normal to element faces and lines.
  !> \see OpenCMISS_CONSTANTS,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_MINUS_XI1 = ELEMENT_NORMAL_MINUS_XI1 !<Negative xi 1 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_MINUS_XI2 = ELEMENT_NORMAL_MINUS_XI2 !<Negative xi 2 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_MINUS_XI3 = ELEMENT_NORMAL_MINUS_XI3 !<Negative xi 3 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_MINUS_XI4 = ELEMENT_NORMAL_MINUS_XI4 !<Negative xi 4 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_PLUS_XI1 = ELEMENT_NORMAL_PLUS_XI1 !<Positive xi 1 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_PLUS_XI2 = ELEMENT_NORMAL_PLUS_XI2 !<Positive xi 2 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_PLUS_XI3 = ELEMENT_NORMAL_PLUS_XI3 !<Positive xi 3 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_ELEMENT_NORMAL_PLUS_XI4 = ELEMENT_NORMAL_PLUS_XI4 !<Positive xi 4 element normal direction \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC OC_INTEGER_TYPE,OC_SHORT_INTEGER_TYPE,OC_LONG_INTEGER_TYPE,OC_SINGLE_REAL_TYPE,OC_DOUBLE_REAL_TYPE, &
    & OC_QUADRAUPLE_REAL_TYPE,OC_CHARACTER_TYPE,OC_LOGICAL_TYPE,OC_SINGLE_COMPLEX_TYPE,OC_DOUBLE_COMPLEX_TYPE, &
    & OC_QUADRUPLE_COMPLEX_TYPE

  PUBLIC OC_NO_GLOBAL_DERIV,OC_GLOBAL_DERIV_S1,OC_GLOBAL_DERIV_S2,OC_GLOBAL_DERIV_S1_S2, &
    & OC_GLOBAL_DERIV_S3,OC_GLOBAL_DERIV_S1_S3,OC_GLOBAL_DERIV_S2_S3,OC_GLOBAL_DERIV_S1_S2_S3

  PUBLIC OC_NO_PARTIAL_DERIV,OC_PARTIAL_DERIV_S1,OC_PARTIAL_DERIV_S1_S1,OC_PARTIAL_DERIV_S2,OC_PARTIAL_DERIV_S2_S2, &
    & OC_PARTIAL_DERIV_S1_S2,OC_PARTIAL_DERIV_S3,OC_PARTIAL_DERIV_S3_S3,OC_PARTIAL_DERIV_S1_S3,OC_PARTIAL_DERIV_S2_S3, &
    & OC_PARTIAL_DERIV_S1_S2_S3,OC_PARTIAL_DERIV_S4,OC_PARTIAL_DERIV_S4_S4,OC_PARTIAL_DERIV_S1_S4, &
    & OC_PARTIAL_DERIV_S2_S4,OC_PARTIAL_DERIV_S3_S4,OC_PARTIAL_DERIV_S1_S2_S4,OC_PARTIAL_DERIV_S1_S3_S4, &
    & OC_PARTIAL_DERIV_S2_S3_S4,OC_PARTIAL_DERIV_S1_S1_S2,OC_PARTIAL_DERIV_S1_S1_S3,OC_PARTIAL_DERIV_S1_S1_S4, &
    & OC_PARTIAL_DERIV_S1_S1_S1

  PUBLIC OC_ELEMENT_NORMAL_MINUS_XI1,OC_ELEMENT_NORMAL_MINUS_XI2,OC_ELEMENT_NORMAL_MINUS_XI3,OC_ELEMENT_NORMAL_MINUS_XI4, &
    & OC_ELEMENT_NORMAL_PLUS_XI1,OC_ELEMENT_NORMAL_PLUS_XI2,OC_ELEMENT_NORMAL_PLUS_XI3,OC_ELEMENT_NORMAL_PLUS_XI4

  !==================================================================================================================================
  !
  ! CONTROL_LOOP_ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_ControlLoopConstants OpenCMISS::ControlLoop::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OpenCMISS_ControlLoopIdentifiers OpenCMISS::ControlLoop::Identifiers
  !> \brief The control loop identification parameters.
  !> \see OpenCMISS::ControlLoop,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_CONTROL_LOOP_NODE = CONTROL_LOOP_NODE !<The identifier for a each "leaf" node in a control loop. \see OpenCMISS_ControlLoopIdentifiers,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_ControlLoopTypes OpenCMISS::ControlLoop::ControlLoopTypes
  !> \brief Control loop type parameters
  !> \see OpenCMISS::ControlLoop,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_CONTROL_SIMPLE_TYPE = CONTROL_SIMPLE_TYPE !<Simple, one iteration control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CONTROL_FIXED_LOOP_TYPE = CONTROL_FIXED_LOOP_TYPE !<Fixed iteration control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CONTROL_TIME_LOOP_TYPE = CONTROL_TIME_LOOP_TYPE !<Time control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CONTROL_WHILE_LOOP_TYPE = CONTROL_WHILE_LOOP_TYPE !<While control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CONTROL_LOAD_INCREMENT_LOOP_TYPE = CONTROL_LOAD_INCREMENT_LOOP_TYPE !<Load increment control loop. \see OpenCMISS_ControlLoopTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_ControlLoopOutputTypes OpenCMISS::ControlLoop::OutputTypes
  !> \brief The control loop output types.
  !> \see OpenCMISS::ControlLoop,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_CONTROL_LOOP_NO_OUTPUT = CONTROL_LOOP_NO_OUTPUT !<No output from the control loop. \see OpenCMISS_ControlLoopOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CONTROL_LOOP_PROGRESS_OUTPUT = CONTROL_LOOP_PROGRESS_OUTPUT !<Progress output from the control loop. \see OpenCMISS_ControlLoopOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CONTROL_LOOP_TIMING_OUTPUT = CONTROL_LOOP_TIMING_OUTPUT !<Timing output from the control loop. \see OpenCMISS_ControlLoopOutputTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the absolute convergence tolerance for a while control loop. 
  INTERFACE OC_ControlLoop_AbsoluteToleranceGet
    MODULE PROCEDURE OC_ControlLoop_AbsoluteToleranceGetNumber0
    MODULE PROCEDURE OC_ControlLoop_AbsoluteToleranceGetNumber1
    MODULE PROCEDURE OC_ControlLoop_AbsoluteToleranceGetObj
  END INTERFACE OC_ControlLoop_AbsoluteToleranceGet

  !>Sets/changes the absolute tolerance for a while control loop.
  INTERFACE OC_ControlLoop_AbsoluteToleranceSet
    MODULE PROCEDURE OC_ControlLoop_AbsoluteToleranceSetNumber0
    MODULE PROCEDURE OC_ControlLoop_AbsoluteToleranceSetNumber1
    MODULE PROCEDURE OC_ControlLoop_AbsoluteToleranceSetObj
  END INTERFACE OC_ControlLoop_AbsoluteToleranceSet

  !>Returns the continue loop status for a while control loop.
  INTERFACE OC_ControlLoop_ContinueLoopGet
    MODULE PROCEDURE OC_ControlLoop_ContinueLoopGetNumber0
    MODULE PROCEDURE OC_ControlLoop_ContinueLoopGetNumber1
    MODULE PROCEDURE OC_ControlLoop_ContinueLoopGetObj
  END INTERFACE OC_ControlLoop_ContinueLoopGet

  !>Returns the current time parameters for a time control loop.
  INTERFACE OC_ControlLoop_CurrentTimesGet
    MODULE PROCEDURE OC_ControlLoop_CurrentTimesGetNumber0
    MODULE PROCEDURE OC_ControlLoop_CurrentTimesGetNumber1
    MODULE PROCEDURE OC_ControlLoop_CurrentTimesGetObj
  END INTERFACE OC_ControlLoop_CurrentTimesGet

  !>Destroy a control loop.
  INTERFACE OC_ControlLoop_Destroy
    MODULE PROCEDURE OC_ControlLoop_DestroyNumber0
    MODULE PROCEDURE OC_ControlLoop_DestroyNumber1
    MODULE PROCEDURE OC_ControlLoop_DestroyObj
  END INTERFACE OC_ControlLoop_Destroy

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  INTERFACE OC_ControlLoop_ControlLoopGet
    MODULE PROCEDURE OC_ControlLoop_ControlLoopGetNumber00
    MODULE PROCEDURE OC_ControlLoop_ControlLoopGetNumber10
    MODULE PROCEDURE OC_ControlLoop_ControlLoopGetNumber01
    MODULE PROCEDURE OC_ControlLoop_ControlLoopGetNumber11
    MODULE PROCEDURE OC_ControlLoop_ControlLoopGetObj0
    MODULE PROCEDURE OC_ControlLoop_ControlLoopGetObj1
  END INTERFACE OC_ControlLoop_ControlLoopGet

  !>Sets/changes the input frequency for a fixed control loop.
  INTERFACE OC_ControlLoop_FixedInputSet
    MODULE PROCEDURE OC_ControlLoop_FixedInputSetNumber0
    MODULE PROCEDURE OC_ControlLoop_FixedInputSetNumber1
    MODULE PROCEDURE OC_ControlLoop_FixedInputSetObj
  END INTERFACE OC_ControlLoop_FixedInputSet

  !>Sets/changes the output frequency for a fixed control loop.
  INTERFACE OC_ControlLoop_FixedOutputSet
    MODULE PROCEDURE OC_ControlLoop_FixedOutputSetNumber0
    MODULE PROCEDURE OC_ControlLoop_FixedOutputSetNumber1
    MODULE PROCEDURE OC_ControlLoop_FixedOutputSetObj
  END INTERFACE OC_ControlLoop_FixedOutputSet

  !>Sets/changes the iteration parameters for a fixed control loop. \todo need a get metod
  INTERFACE OC_ControlLoop_IterationsSet
    MODULE PROCEDURE OC_ControlLoop_IterationsSetNumber0
    MODULE PROCEDURE OC_ControlLoop_IterationsSetNumber1
    MODULE PROCEDURE OC_ControlLoop_IterationsSetObj
  END INTERFACE OC_ControlLoop_IterationsSet

  !>Returnss the iteration number for a control loop.
  INTERFACE OC_ControlLoop_IterationNumberGet
    MODULE PROCEDURE OC_ControlLoop_IterationNumberGetNumber0
    MODULE PROCEDURE OC_ControlLoop_IterationNumberGetNumber1
    MODULE PROCEDURE OC_ControlLoop_IterationNumberGetObj
  END INTERFACE OC_ControlLoop_IterationNumberGet

  !>Returns the label of a control loop.
  INTERFACE OC_ControlLoop_LabelGet
    MODULE PROCEDURE OC_ControlLoop_LabelGetCNumber0
    MODULE PROCEDURE OC_ControlLoop_LabelGetCNumber1
    MODULE PROCEDURE OC_ControlLoop_LabelGetCObj
    MODULE PROCEDURE OC_ControlLoop_LabelGetVSNumber0
    MODULE PROCEDURE OC_ControlLoop_LabelGetVSNumber1
    MODULE PROCEDURE OC_ControlLoop_LabelGetVSObj
  END INTERFACE OC_ControlLoop_LabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE OC_ControlLoop_LabelSet
    MODULE PROCEDURE OC_ControlLoop_LabelSetCNumber0
    MODULE PROCEDURE OC_ControlLoop_LabelSetCNumber1
    MODULE PROCEDURE OC_ControlLoop_LabelSetCObj
    MODULE PROCEDURE OC_ControlLoop_LabelSetVSNumber0
    MODULE PROCEDURE OC_ControlLoop_LabelSetVSNumber1
    MODULE PROCEDURE OC_ControlLoop_LabelSetVSObj
  END INTERFACE OC_ControlLoop_LabelSet

  !>Sets/changes the maximum iterations for a while control loop. \todo need a get method
  INTERFACE OC_ControlLoop_MaximumIterationsSet
    MODULE PROCEDURE OC_ControlLoop_MaximumIterationsSetNumber0
    MODULE PROCEDURE OC_ControlLoop_MaximumIterationsSetNumber1
    MODULE PROCEDURE OC_ControlLoop_MaximumIterationsSetObj
  END INTERFACE OC_ControlLoop_MaximumIterationsSet

  !>Returns the number of iterations for a time control loop. If the returned value is 0, that means that the number has not yet been computed. 
  INTERFACE OC_ControlLoop_NumberOfIterationsGet
    MODULE PROCEDURE OC_ControlLoop_NumberOfIterationsGetNumber0
    MODULE PROCEDURE OC_ControlLoop_NumberOfIterationsGetNumber1
    MODULE PROCEDURE OC_ControlLoop_NumberOfIterationsGetObj
  END INTERFACE OC_ControlLoop_NumberOfIterationsGet

  !>Sets/changes the number of iterations for a time control loop. If set to 0, it will be computed from time increment and start/stop time
  INTERFACE OC_ControlLoop_NumberOfIterationsSet
    MODULE PROCEDURE OC_ControlLoop_NumberOfIterationsSetNumber0
    MODULE PROCEDURE OC_ControlLoop_NumberOfIterationsSetNumber1
    MODULE PROCEDURE OC_ControlLoop_NumberOfIterationsSetObj
  END INTERFACE OC_ControlLoop_NumberOfIterationsSet

  !>Returns the number of sub loops for a control loop.
  INTERFACE OC_ControlLoop_NumberOfSubLoopsGet
    MODULE PROCEDURE OC_ControlLoop_NumberOfSubLoopsGetNumber0
    MODULE PROCEDURE OC_ControlLoop_NumberOfSubLoopsGetNumber1
    MODULE PROCEDURE OC_ControlLoop_NumberOfSubLoopsGetObj
  END INTERFACE OC_ControlLoop_NumberOfSubLoopsGet

  !>Sets/changes the number of sub loops for a control loop. \todo is this really a public method???
  INTERFACE OC_ControlLoop_NumberOfSubLoopsSet
    MODULE PROCEDURE OC_ControlLoop_NumberOfSubLoopsSetNumber0
    MODULE PROCEDURE OC_ControlLoop_NumberOfSubLoopsSetNumber1
    MODULE PROCEDURE OC_ControlLoop_NumberOfSubLoopsSetObj
  END INTERFACE OC_ControlLoop_NumberOfSubLoopsSet

  !>Returns the relative convergence tolerance for a while control loop. 
  INTERFACE OC_ControlLoop_RelativeToleranceGet
    MODULE PROCEDURE OC_ControlLoop_RelativeToleranceGetNumber0
    MODULE PROCEDURE OC_ControlLoop_RelativeToleranceGetNumber1
    MODULE PROCEDURE OC_ControlLoop_RelativeToleranceGetObj
  END INTERFACE OC_ControlLoop_RelativeToleranceGet

  !>Sets/changes the relative tolerance for a while control loop.
  INTERFACE OC_ControlLoop_RelativeToleranceSet
    MODULE PROCEDURE OC_ControlLoop_RelativeToleranceSetNumber0
    MODULE PROCEDURE OC_ControlLoop_RelativeToleranceSetNumber1
    MODULE PROCEDURE OC_ControlLoop_RelativeToleranceSetObj
  END INTERFACE OC_ControlLoop_RelativeToleranceSet

  !>Sets/changes the output parameters for a time control loop.
  INTERFACE OC_ControlLoop_TimeOutputSet
    MODULE PROCEDURE OC_ControlLoop_TimeOutputSetNumber0
    MODULE PROCEDURE OC_ControlLoop_TimeOutputSetNumber1
    MODULE PROCEDURE OC_ControlLoop_TimeOutputSetObj
  END INTERFACE OC_ControlLoop_TimeOutputSet

  !>Returns the output type for a control loop.
  INTERFACE OC_ControlLoop_OutputTypeGet
    MODULE PROCEDURE OC_ControlLoop_OutputTypeGetNumber0
    MODULE PROCEDURE OC_ControlLoop_OutputTypeGetNumber1
    MODULE PROCEDURE OC_ControlLoop_OutputTypeGetObj
  END INTERFACE OC_ControlLoop_OutputTypeGet

  !>Sets/changes the output type for a control loop.
  INTERFACE OC_ControlLoop_OutputTypeSet
    MODULE PROCEDURE OC_ControlLoop_OutputTypeSetNumber0
    MODULE PROCEDURE OC_ControlLoop_OutputTypeSetNumber1
    MODULE PROCEDURE OC_ControlLoop_OutputTypeSetObj
  END INTERFACE OC_ControlLoop_OutputTypeSet

  !>Sets/changes the input parameters for a time control loop.
  INTERFACE OC_ControlLoop_TimeInputSet
    MODULE PROCEDURE OC_ControlLoop_TimeInputSetNumber0
    MODULE PROCEDURE OC_ControlLoop_TimeInputSetNumber1
    MODULE PROCEDURE OC_ControlLoop_TimeInputSetObj
  END INTERFACE OC_ControlLoop_TimeInputSet

  !>Returns the time parameters for a time control loop.
  INTERFACE OC_ControlLoop_TimesGet
    MODULE PROCEDURE OC_ControlLoop_TimesGetNumber0
    MODULE PROCEDURE OC_ControlLoop_TimesGetNumber1
    MODULE PROCEDURE OC_ControlLoop_TimesGetObj
  END INTERFACE OC_ControlLoop_TimesGet

  !>Sets/Changes the time parameters for a time control loop.
  INTERFACE OC_ControlLoop_TimesSet
    MODULE PROCEDURE OC_ControlLoop_TimesSetNumber0
    MODULE PROCEDURE OC_ControlLoop_TimesSetNumber1
    MODULE PROCEDURE OC_ControlLoop_TimesSetObj
  END INTERFACE OC_ControlLoop_TimesSet

  !>Sets/Changes the loop type for a control loop. \todo Is this really a public method? \todo need a get method
  INTERFACE OC_ControlLoop_TypeSet
    MODULE PROCEDURE OC_ControlLoop_TypeSetNumber0
    MODULE PROCEDURE OC_ControlLoop_TypeSetNumber1
    MODULE PROCEDURE OC_ControlLoop_TypeSetObj
  END INTERFACE OC_ControlLoop_TypeSet

  PUBLIC OC_CONTROL_LOOP_NODE

  PUBLIC OC_CONTROL_SIMPLE_TYPE,OC_CONTROL_FIXED_LOOP_TYPE,OC_CONTROL_TIME_LOOP_TYPE, &
    & OC_CONTROL_WHILE_LOOP_TYPE,OC_CONTROL_LOAD_INCREMENT_LOOP_TYPE

  PUBLIC OC_CONTROL_LOOP_NO_OUTPUT,OC_CONTROL_LOOP_PROGRESS_OUTPUT,OC_CONTROL_LOOP_TIMING_OUTPUT

  PUBLIC OC_ControlLoop_CurrentTimesGet

  PUBLIC OC_ControlLoop_Destroy

  PUBLIC OC_ControlLoop_ContinueLoopGet

  PUBLIC OC_ControlLoop_ControlLoopGet

  PUBLIC OC_ControlLoop_FixedInputSet,OC_ControlLoop_FixedOutputSet

  PUBLIC OC_ControlLoop_IterationsSet

  PUBLIC OC_ControlLoop_IterationNumberGet

  PUBLIC OC_ControlLoop_LabelGet,OC_ControlLoop_LabelSet

  PUBLIC OC_ControlLoop_LoadOutputSet

  PUBLIC OC_ControlLoop_MaximumIterationsSet

  PUBLIC OC_ControlLoop_AbsoluteToleranceGet,OC_ControlLoop_AbsoluteToleranceSet

  PUBLIC OC_ControlLoop_NumberOfIterationsGet,OC_ControlLoop_NumberOfIterationsSet

  PUBLIC OC_ControlLoop_NumberOfSubLoopsGet,OC_ControlLoop_NumberOfSubLoopsSet

  PUBLIC OC_ControlLoop_OutputTypeGet,OC_ControlLoop_OutputTypeSet

  PUBLIC OC_ControlLoop_RelativeToleranceGet,OC_ControlLoop_RelativeToleranceSet

  PUBLIC OC_ControlLoop_TimeOutputSet,OC_ControlLoop_TimeInputSet

  PUBLIC OC_ControlLoop_TimesGet,OC_ControlLoop_TimesSet

  PUBLIC OC_ControlLoop_TypeSet


  !==================================================================================================================================
  !
  ! CoordinateRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_CoordinateConstants OpenCMISS::Coordinate::Constants
  !> \brief Coordinate constants.
  !>@{
  !> \addtogroup OpenCMISS_CoordinateSystemTypes OpenCMISS::Coordinate::SystemTypes
  !> \brief Coordinate system type parameters.
  !> \see OpenCMISS::Coordinate,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_RECTANGULAR_CARTESIAN_TYPE = COORDINATE_RECTANGULAR_CARTESIAN_TYPE !<Rectangular Cartesian coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_CYLINDRICAL_POLAR_TYPE = COORDINATE_CYLINDRICAL_POLAR_TYPE !<Cylindrical polar coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_SPHERICAL_POLAR_TYPE = COORDINATE_SPHERICAL_POLAR_TYPE !<Spherical polar coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_PROLATE_SPHEROIDAL_TYPE = COORDINATE_PROLATE_SPHEROIDAL_TYPE !<Prolate spheroidal coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_OBLATE_SPHEROIDAL_TYPE = COORDINATE_OBLATE_SPHEROIDAL_TYPE !<Oblate spheroidal coordinate system type \see OpenCMISS_CoordinateSystemTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_CoordinateRadialInterpolations OpenCMISS::Coordinate::RadialInterpolations
  !> \brief The type of radial interpolation for polar coordinate systems
  !> \see OpenCMISS::Coordinate,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE = COORDINATE_NO_RADIAL_INTERPOLATION_TYPE !<No radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_RADIAL_INTERPOLATION_TYPE = COORDINATE_RADIAL_INTERPOLATION_TYPE !<r radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE = COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE !<r^2 radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE = COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE !<r^3 radial interpolation \see OpenCMISS_CoordinateRadialInterpolations,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a coordinate system. \see OpenCMISS::OC_CoordinateSystem_CreateStart
  INTERFACE OC_CoordinateSystem_CreateFinish
    MODULE PROCEDURE OC_CoordinateSystem_CreateFinishNumber
    MODULE PROCEDURE OC_CoordinateSystem_CreateFinishObj
  END INTERFACE OC_CoordinateSystem_CreateFinish

  !>Starts the creation of a coordinate system. \see OpenCMISS::OC_CoordinateSystem_CreateFinish
  INTERFACE OC_CoordinateSystem_CreateStart
    MODULE PROCEDURE OC_CoordinateSystem_CreateStartNumber
    MODULE PROCEDURE OC_CoordinateSystem_CreateStartObj
  END INTERFACE OC_CoordinateSystem_CreateStart

  !>Destorys a coordinate system.
  INTERFACE OC_CoordinateSystem_Destroy
    MODULE PROCEDURE OC_CoordinateSystem_DestroyNumber
    MODULE PROCEDURE OC_CoordinateSystem_DestroyObj
  END INTERFACE OC_CoordinateSystem_Destroy

  !>Returns the coordinate system dimension. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_DimensionGet
    MODULE PROCEDURE OC_CoordinateSystem_DimensionGetNumber
    MODULE PROCEDURE OC_CoordinateSystem_DimensionGetObj
  END INTERFACE OC_CoordinateSystem_DimensionGet

  !>Sets/changes the coordinate system dimension. \todo fix pointers
  INTERFACE OC_CoordinateSystem_DimensionSet
    MODULE PROCEDURE OC_CoordinateSystem_DimensionSetNumber
    MODULE PROCEDURE OC_CoordinateSystem_DimensionSetObj
  END INTERFACE OC_CoordinateSystem_DimensionSet

  !>Returns the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_FocusGet
    MODULE PROCEDURE OC_CoordinateSystem_FocusGetNumber
    MODULE PROCEDURE OC_CoordinateSystem_FocusGetObj
  END INTERFACE OC_CoordinateSystem_FocusGet

  !>Sets/changes the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_FocusSet
    MODULE PROCEDURE OC_CoordinateSystem_FocusSetNumber
    MODULE PROCEDURE OC_CoordinateSystem_FocusSetObj
  END INTERFACE OC_CoordinateSystem_FocusSet

  !>Returns the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_RadialInterpolationGet
    MODULE PROCEDURE OC_CoordinateSystem_RadialInterpolationGetNumber
    MODULE PROCEDURE OC_CoordinateSystem_RadialInterpolationGetObj
  END INTERFACE OC_CoordinateSystem_RadialInterpolationGet

  !>Sets/changes the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_RadialInterpolationSet
    MODULE PROCEDURE OC_CoordinateSystem_RadialInterpolationSetNumber
    MODULE PROCEDURE OC_CoordinateSystem_RadialInterpolationSetObj
  END INTERFACE OC_CoordinateSystem_RadialInterpolationSet

  !>Returns the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_TypeGet
    MODULE PROCEDURE OC_CoordinateSystem_TypeGetNumber
    MODULE PROCEDURE OC_CoordinateSystem_TypeGetObj
  END INTERFACE OC_CoordinateSystem_TypeGet

  !>Sets/changes the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE OC_CoordinateSystem_TypeSet
    MODULE PROCEDURE OC_CoordinateSystem_TypeSetNumber
    MODULE PROCEDURE OC_CoordinateSystem_TypeSetObj
  END INTERFACE OC_CoordinateSystem_TypeSet

  !>Returns the coordinate system orign.
  INTERFACE OC_CoordinateSystem_OriginGet
    MODULE PROCEDURE OC_CoordinateSystem_OriginGetNumber
    MODULE PROCEDURE OC_CoordinateSystem_OriginGetObj
  END INTERFACE OC_CoordinateSystem_OriginGet

  !>Sets/changes the coordinate system orign.
  INTERFACE OC_CoordinateSystem_OriginSet
    MODULE PROCEDURE OC_CoordinateSystem_OriginSetNumber
    MODULE PROCEDURE OC_CoordinateSystem_OriginSetObj
  END INTERFACE OC_CoordinateSystem_OriginSet

  !>Returns the coordinate system orientation.
  INTERFACE OC_CoordinateSystem_OrientationGet
    MODULE PROCEDURE OC_CoordinateSystem_OrientationGetNumber
    MODULE PROCEDURE OC_CoordinateSystem_OrientationGetObj
  END INTERFACE OC_CoordinateSystem_OrientationGet

  !>Sets/changes the coordinate system orientation.
  INTERFACE OC_CoordinateSystem_OrientationSet
    MODULE PROCEDURE OC_CoordinateSystem_OrientationSetNumber
    MODULE PROCEDURE OC_CoordinateSystem_OrientationSetObj
  END INTERFACE OC_CoordinateSystem_OrientationSet

  PUBLIC OC_COORDINATE_RECTANGULAR_CARTESIAN_TYPE,OC_COORDINATE_CYLINDRICAL_POLAR_TYPE, &
    & OC_COORDINATE_SPHERICAL_POLAR_TYPE, &
    & OC_COORDINATE_PROLATE_SPHEROIDAL_TYPE,OC_COORDINATE_OBLATE_SPHEROIDAL_TYPE

  PUBLIC OC_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE,OC_COORDINATE_RADIAL_INTERPOLATION_TYPE, &
    & OC_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE,OC_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE

  PUBLIC OC_CoordinateSystem_CreateFinish,OC_CoordinateSystem_CreateStart

  PUBLIC OC_CoordinateSystem_Destroy

  PUBLIC OC_CoordinateSystem_DimensionGet,OC_CoordinateSystem_DimensionSet

  PUBLIC OC_CoordinateSystem_FocusGet,OC_CoordinateSystem_FocusSet

  PUBLIC OC_CoordinateSystem_RadialInterpolationGet,OC_CoordinateSystem_RadialInterpolationSet

  PUBLIC OC_CoordinateSystem_TypeGet,OC_CoordinateSystem_TypeSet

  PUBLIC OC_CoordinateSystem_OriginGet,OC_CoordinateSystem_OriginSet

  PUBLIC OC_CoordinateSystem_OrientationGet,OC_CoordinateSystem_OrientationSet

  !==================================================================================================================================
  !
  ! DataPointsRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating data points in a region. \see OpenCMISS::OC_DataPoints_CreateStart
  INTERFACE OC_DataPoints_CreateFinish
    MODULE PROCEDURE OC_DataPoints_CreateFinishNumber
    MODULE PROCEDURE OC_DataPoints_CreateFinishObj
  END INTERFACE OC_DataPoints_CreateFinish

  !>Starts the process of creating data points in a region. \see OpenCMISS::OC_DataPoints_CreateFinish
  INTERFACE OC_DataPoints_CreateStart
    MODULE PROCEDURE OC_DataPoints_CreateStartNumber
    MODULE PROCEDURE OC_DataPoints_CreateStartObj
    MODULE PROCEDURE OC_DataPoints_CreateStartInterfaceObj
  END INTERFACE OC_DataPoints_CreateStart

  !>Destroys data points.
  INTERFACE OC_DataPoints_Destroy
    MODULE PROCEDURE OC_DataPoints_DestroyNumber
    MODULE PROCEDURE OC_DataPoints_DestroyObj
  END INTERFACE OC_DataPoints_Destroy

  !>Returns the number of data points
  INTERFACE OC_DataPoints_NumberOfDataPointsGet
    MODULE PROCEDURE OC_DataPoints_NumberOfDataPointsGetNumber
    MODULE PROCEDURE OC_DataPoints_NumberOfDataPointsGetObj
  END INTERFACE OC_DataPoints_NumberOfDataPointsGet

  !>Returns the label for a data point identified by a given user number.
  INTERFACE OC_DataPoints_LabelGet
    MODULE PROCEDURE OC_DataPoints_LabelGetCNumber
    MODULE PROCEDURE OC_DataPoints_LabelGetCObj
    MODULE PROCEDURE OC_DataPoints_LabelGetVSNumber
    MODULE PROCEDURE OC_DataPoints_LabelGetVSObj
  END INTERFACE OC_DataPoints_LabelGet

  !>Sets/changes the label for a data point identified by a given user number.
  INTERFACE OC_DataPoints_LabelSet
    MODULE PROCEDURE OC_DataPoints_LabelSetCNumber
    MODULE PROCEDURE OC_DataPoints_LabelSetCObj
    MODULE PROCEDURE OC_DataPoints_LabelSetVSNumber
    MODULE PROCEDURE OC_DataPoints_LabelSetVSObj
  END INTERFACE OC_DataPoints_LabelSet

  !>Returns the user number for a data point identified by a given global number.
  INTERFACE OC_DataPoints_UserNumberGet
    MODULE PROCEDURE OC_DataPoints_UserNumberGetNumber
    MODULE PROCEDURE OC_DataPoints_UserNumberGetObj
  END INTERFACE OC_DataPoints_UserNumberGet

  !>Sets/changes the user number for a data point identified by a given global number.
  INTERFACE OC_DataPoints_UserNumberSet
    MODULE PROCEDURE OC_DataPoints_UserNumberSetNumber
    MODULE PROCEDURE OC_DataPoints_UserNumberSetObj
  END INTERFACE OC_DataPoints_UserNumberSet

  !>Returns the position for a data point identified by a given user number.
  INTERFACE OC_DataPoints_PositionGet
    MODULE PROCEDURE OC_DataPoints_PositionGetNumber
    MODULE PROCEDURE OC_DataPoints_PositionGetObj
  END INTERFACE OC_DataPoints_PositionGet

  !>Sets/changes the position for a data point identified by a given user number.
  INTERFACE OC_DataPoints_PositionSet
    MODULE PROCEDURE OC_DataPoints_PositionSetNumber
    MODULE PROCEDURE OC_DataPoints_PositionSetObj
  END INTERFACE OC_DataPoints_PositionSet

  !>Returns the weights for a data point identified by a given user number.
  INTERFACE OC_DataPoints_WeightsGet
    MODULE PROCEDURE OC_DataPoints_WeightsGetNumber
    MODULE PROCEDURE OC_DataPoints_WeightsGetObj
  END INTERFACE OC_DataPoints_WeightsGet

  !>Sets/changes the weights for a data point identified by a given user number.
  INTERFACE OC_DataPoints_WeightsSet
    MODULE PROCEDURE OC_DataPoints_WeightsSetNumber
    MODULE PROCEDURE OC_DataPoints_WeightsSetObj
  END INTERFACE OC_DataPoints_WeightsSet

  PUBLIC OC_DataPoints_CreateFinish,OC_DataPoints_CreateStart

  PUBLIC OC_DataPoints_Destroy

  PUBLIC OC_DataPoints_NumberOfDataPointsGet

  PUBLIC OC_DataPoints_LabelGet,OC_DataPoints_LabelSet

  PUBLIC OC_DataPoints_UserNumberGet,OC_DataPoints_UserNumberSet

  PUBLIC OC_DataPoints_PositionGet,OC_DataPoints_PositionSet

  PUBLIC OC_DataPoints_WeightsGet,OC_DataPoints_WeightsSet

  !==================================================================================================================================
  !
  ! DataProjectionRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_DataProjectionConstants OpenCMISS::DataProjection::Constants
  !> \brief DataProjection  constants.
  !>@{
  !> \addtogroup OpenCMISS_DataProjectionProjectionTypes OpenCMISS::DataProjection::ProjectionTypes
  !> \brief Data Projection types
  !> \see OpenCMISS::DataProjection,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE!<The boundary line projection type for data projection, only projects to boundary lines of the mesh. \see OpenCMISS_DataProjectionProjectionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE!<The boundary face projection type for data projection, only projects to boundary faces of the mesh. \see OpenCMISS_DataProjectionProjectionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE = DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE !<The element projection type for data projection, projects to all elements in mesh. \see OpenCMISS_DataProjectionProjectionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DataProjectionExitTags OpenCMISS::DataProjection::DataProjectionExitTags
  !> \brief Datapoint projection exit tags
  !> \see OpenCMISS::DataProjection,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_CANCELLED = DATA_PROJECTION_CANCELLED !<Data projection has been cancelled. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_USER_SPECIFIED = DATA_PROJECTION_USER_SPECIFIED !<Data projection was user specified. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_EXIT_TAG_CONVERGED = DATA_PROJECTION_EXIT_TAG_CONVERGED !<Data projection exited due to it being converged. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_EXIT_TAG_BOUNDS = DATA_PROJECTION_EXIT_TAG_BOUNDS !<Data projection exited due to it hitting the bound and continue to travel out of the element. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_EXIT_TAG_MAX_ITERATION = DATA_PROJECTION_EXIT_TAG_MAX_ITERATION !<Data projection exited due to it attaining maximum number of iteration specified by user. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_EXIT_TAG_NO_ELEMENT = DATA_PROJECTION_EXIT_TAG_NO_ELEMENT !<Data projection exited due to no local element found, this happens when none of the candidate elements are within this computational node, and before MPI communication with other nodes. \see OpenCMISS_DataProjectionExitTags,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DataProjectionDistanceRelations OpenCMISS::DataProjection::DataProjectionDistanceRelations
  !> \brief Datapoint projection distance relations to select data points based on distance.
  !> \see OpenCMISS::DataProjection,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_DISTANCE_GREATER = DATA_PROJECTION_DISTANCE_GREATER !<Data projection distance relation is greater than. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_DISTANCE_GREATER_EQUAL = DATA_PROJECTION_DISTANCE_GREATER_EQUAL !<Data projection distance relation is greater than or equal. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_DISTANCE_LESS = DATA_PROJECTION_DISTANCE_LESS !<Data projection distance relation is less than. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DATA_PROJECTION_DISTANCE_LESS_EQUAL = DATA_PROJECTION_DISTANCE_LESS_EQUAL !<Data projection distance relation is less than or equal. \see OpenCMISS_DataProjectionDistanceRelations,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the absolute tolerance for a data projection.
  INTERFACE OC_DataProjection_AbsoluteToleranceGet
    MODULE PROCEDURE OC_DataProjection_AbsoluteToleranceGetNumber
    MODULE PROCEDURE OC_DataProjection_AbsoluteToleranceGetObj
  END INTERFACE OC_DataProjection_AbsoluteToleranceGet

  !>Sets/changes the absolute tolerance for a data projection.
  INTERFACE OC_DataProjection_AbsoluteToleranceSet
    MODULE PROCEDURE OC_DataProjection_AbsoluteToleranceSetNumber
    MODULE PROCEDURE OC_DataProjection_AbsoluteToleranceSetObj
  END INTERFACE OC_DataProjection_AbsoluteToleranceSet

  !>Finishes the creation of a new data projection. \see OpenCMISS::OC_DataProjection_CreateStart
  INTERFACE OC_DataProjection_CreateFinish
    MODULE PROCEDURE OC_DataProjection_CreateFinishNumber
    MODULE PROCEDURE OC_DataProjection_CreateFinishObj
  END INTERFACE OC_DataProjection_CreateFinish

  !>Starts the creation of a new data projection. \see OpenCMISS::OC_DataProjection_CreateFinish
  INTERFACE OC_DataProjection_CreateStart
    MODULE PROCEDURE OC_DataProjection_CreateStartNumber
    MODULE PROCEDURE OC_DataProjection_CreateStartObj
  END INTERFACE OC_DataProjection_CreateStart

  !>Destroy a data projection.
  INTERFACE OC_DataProjection_Destroy
    MODULE PROCEDURE OC_DataProjection_DestroyNumber
    MODULE PROCEDURE OC_DataProjection_DestroyObj
  END INTERFACE OC_DataProjection_Destroy

  !>Evaluate A data point in a field based on data projection
  INTERFACE OC_DataProjection_DataPointFieldEvaluate
    MODULE PROCEDURE OC_DataProjection_DataPointFieldEvaluateRegionNumber
    MODULE PROCEDURE OC_DataProjection_DataPointFieldEvaluateInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_DataPointFieldEvaluateObj
  END INTERFACE OC_DataProjection_DataPointFieldEvaluate

  !>Evaluate the data points position in a field based on data projection
  INTERFACE OC_DataProjection_DataPointsPositionEvaluate
    MODULE PROCEDURE OC_DataProjection_DataPointsPositionEvaluateRegionNumber
    MODULE PROCEDURE OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_DataPointsPositionEvaluateObj
  END INTERFACE OC_DataProjection_DataPointsPositionEvaluate

  !>Starts the evaluation of data projection on the geometric field.
  INTERFACE OC_DataProjection_DataPointsProjectionEvaluate
    MODULE PROCEDURE OC_DataProjection_DataPointsProjectionEvaluateNumber
    MODULE PROCEDURE OC_DataProjection_DataPointsProjectionEvaluateObj
  END INTERFACE OC_DataProjection_DataPointsProjectionEvaluate

  !>Returns the maximum iteration update for a data projection.
  INTERFACE OC_DataProjection_MaximumIterationUpdateGet
    MODULE PROCEDURE OC_DataProjection_MaximumIterationUpdateGetNumber
    MODULE PROCEDURE OC_DataProjection_MaximumIterationUpdateGetObj
  END INTERFACE OC_DataProjection_MaximumIterationUpdateGet

  !>Sets/changes the maximum iteration update for a data projection.
  INTERFACE OC_DataProjection_MaximumIterationUpdateSet
    MODULE PROCEDURE OC_DataProjection_MaximumIterationUpdateSetNumber
    MODULE PROCEDURE OC_DataProjection_MaximumIterationUpdateSetObj
  END INTERFACE OC_DataProjection_MaximumIterationUpdateSet

  !>Returns the maximum number of iterations for a data projection.
  INTERFACE OC_DataProjection_MaximumNumberOfIterationsGet
    MODULE PROCEDURE OC_DataProjection_MaximumNumberOfIterationsGetNumber
    MODULE PROCEDURE OC_DataProjection_MaximumNumberOfIterationsGetObj
  END INTERFACE OC_DataProjection_MaximumNumberOfIterationsGet

  !>Sets/changes the maximum number of iterations for a data projection.
  INTERFACE OC_DataProjection_MaximumNumberOfIterationsSet
    MODULE PROCEDURE OC_DataProjection_MaximumNumberOfIterationsSetNumber
    MODULE PROCEDURE OC_DataProjection_MaximumNumberOfIterationsSetObj
  END INTERFACE OC_DataProjection_MaximumNumberOfIterationsSet

  !>Returns the number of closest elements for a data projection.
  INTERFACE OC_DataProjection_NumberOfClosestElementsGet
    MODULE PROCEDURE OC_DataProjection_NumberOfClosestElementsGetNumber
    MODULE PROCEDURE OC_DataProjection_NumberOfClosestElementsGetObj
  END INTERFACE OC_DataProjection_NumberOfClosestElementsGet

  !>Sets/changes the number of closest elements for a data projection.
  INTERFACE OC_DataProjection_NumberOfClosestElementsSet
    MODULE PROCEDURE OC_DataProjection_NumberOfClosestElementsSetNumber
    MODULE PROCEDURE OC_DataProjection_NumberOfClosestElementsSetObj
  END INTERFACE OC_DataProjection_NumberOfClosestElementsSet

  !>Cancel the data projection for data points based on the data point user numbers.
  INTERFACE OC_DataProjection_ProjectionCancelByDataPoints
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDataPointsInterNum0
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDataPointsInterNum1
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDataPointsObj0
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDataPointsObj1
  END INTERFACE OC_DataProjection_ProjectionCancelByDataPoints

  !>Cancel the data projection for data points based on the projection distance.
  INTERFACE OC_DataProjection_ProjectionCancelByDistance
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDistanceRegionNumber
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByDistanceObj
  END INTERFACE OC_DataProjection_ProjectionCancelByDistance

  !>Cancel the data projection for data points based on the projection exit tag.
  INTERFACE OC_DataProjection_ProjectionCancelByExitTags
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByExitTagsObj0
    MODULE PROCEDURE OC_DataProjection_ProjectionCancelByExitTagsObj1
  END INTERFACE OC_DataProjection_ProjectionCancelByExitTags

  !>Set the data projection candidate elements for an all elements projection type.
  INTERFACE OC_DataProjection_ProjectionCandidateElementsSet
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateElementsSetIntNum0
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateElementsSetIntNum1
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateElementsSetObj0
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateElementsSetObj1
  END INTERFACE OC_DataProjection_ProjectionCandidateElementsSet

  !>Set the data projection candidate elements for data points for an all elements projection type.
  INTERFACE OC_DataProjection_ProjectionDataCandidateElementsSet
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetObj00
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetObj01
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetObj10
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateElementsSetObj11
  END INTERFACE OC_DataProjection_ProjectionDataCandidateElementsSet

  !>Set the data projection candidate faces for a boundary faces projection type.
  INTERFACE OC_DataProjection_ProjectionCandidateFacesSet
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetObj00
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetObj10
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetObj01
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateFacesSetObj11
  END INTERFACE OC_DataProjection_ProjectionCandidateFacesSet

  !>Set the data projection candidate faces for data points for a boundary faces projection type.
  INTERFACE OC_DataProjection_ProjectionDataCandidateFacesSet
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetObj000
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetObj011
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetObj100
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateFacesSetObj111
  END INTERFACE OC_DataProjection_ProjectionDataCandidateFacesSet

  !>Set the data projection candidate lines for a boundary lines projection type.
  INTERFACE OC_DataProjection_ProjectionCandidateLinesSet
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetObj00
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetObj10
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetObj01
    MODULE PROCEDURE OC_DataProjection_ProjectionCandidateLinesSetObj11
  END INTERFACE OC_DataProjection_ProjectionCandidateLinesSet

  !>Set the data projection candidate lines for data points for a boundary lines projection type.
  INTERFACE OC_DataProjection_ProjectionDataCandidateLinesSet
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetObj000
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetObj011
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetObj100
    MODULE PROCEDURE OC_DataProjection_ProjectionDataCandidateLinesSetObj111
  END INTERFACE OC_DataProjection_ProjectionDataCandidateLinesSet

  !>Returns the projection type for a data projection.
  INTERFACE OC_DataProjection_ProjectionTypeGet
    MODULE PROCEDURE OC_DataProjection_ProjectionTypeGetNumber
    MODULE PROCEDURE OC_DataProjection_ProjectionTypeGetObj
  END INTERFACE OC_DataProjection_ProjectionTypeGet

  !>Sets/changes the projection type for a data projection.
  INTERFACE OC_DataProjection_ProjectionTypeSet
    MODULE PROCEDURE OC_DataProjection_ProjectionTypeSetNumber
    MODULE PROCEDURE OC_DataProjection_ProjectionTypeSetObj
  END INTERFACE OC_DataProjection_ProjectionTypeSet

  !>Returns the relative tolerance for a data projection.
  INTERFACE OC_DataProjection_RelativeToleranceGet
    MODULE PROCEDURE OC_DataProjection_RelativeToleranceGetNumber
    MODULE PROCEDURE OC_DataProjection_RelativeToleranceGetObj
  END INTERFACE OC_DataProjection_RelativeToleranceGet

  !>Sets/changes the relative tolerance for a data projection.
  INTERFACE OC_DataProjection_RelativeToleranceSet
    MODULE PROCEDURE OC_DataProjection_RelativeToleranceSetNumber
    MODULE PROCEDURE OC_DataProjection_RelativeToleranceSetObj
  END INTERFACE OC_DataProjection_RelativeToleranceSet

  !>Returns the starting xi for a data projection.
  INTERFACE OC_DataProjection_StartingXiGet
    MODULE PROCEDURE OC_DataProjection_StartingXiGetNumber
    MODULE PROCEDURE OC_DataProjection_StartingXiGetObj
  END INTERFACE OC_DataProjection_StartingXiGet

  !>Sets/changes the starting xi for a data projection.
  INTERFACE OC_DataProjection_StartingXiSet
    MODULE PROCEDURE OC_DataProjection_StartingXiSetNumber
    MODULE PROCEDURE OC_DataProjection_StartingXiSetObj
  END INTERFACE OC_DataProjection_StartingXiSet

  !>Sets/changes the element number for a data point projection.
  INTERFACE OC_DataProjection_ElementSet
    MODULE PROCEDURE OC_DataProjection_ElementSetRegionNumber
    MODULE PROCEDURE OC_DataProjection_ElementSetInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_ElementSetObj
  END INTERFACE OC_DataProjection_ElementSet

  !>Gets the label for a data point projection.
  INTERFACE OC_DataProjection_LabelGet
    MODULE PROCEDURE OC_DataProjection_LabelGetCRegionNumber
    MODULE PROCEDURE OC_DataProjection_LabelGetCInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_LabelGetCObj
    MODULE PROCEDURE OC_DataProjection_LabelGetVSRegionNumber
    MODULE PROCEDURE OC_DataProjection_LabelGetVSInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_LabelGetVSObj
  END INTERFACE OC_DataProjection_LabelGet

  !>Sets/changes the label for a data point projection.
  INTERFACE OC_DataProjection_LabelSet
    MODULE PROCEDURE OC_DataProjection_LabelSetCRegionNumber
    MODULE PROCEDURE OC_DataProjection_LabelSetCInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_LabelSetCObj
    MODULE PROCEDURE OC_DataProjection_LabelSetVSRegionNumber
    MODULE PROCEDURE OC_DataProjection_LabelSetVSInterfaceNumber
    MODULE PROCEDURE OC_DataProjection_LabelSetVSObj
  END INTERFACE OC_DataProjection_LabelSet

  !>Outputs an analysis of the data projection results
  INTERFACE OC_DataProjection_ResultAnalysisOutput
    MODULE PROCEDURE OC_DataProjection_ResultAnalysisOutputNumber
    MODULE PROCEDURE OC_DataProjection_ResultAnalysisOutputObj
  END INTERFACE OC_DataProjection_ResultAnalysisOutput

  !>Returns the projection distance for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultDistanceGet
    MODULE PROCEDURE OC_DataProjection_ResultDistanceGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultDistanceGetObj
  END INTERFACE OC_DataProjection_ResultDistanceGet

  !>Returns the projection element number for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementNumberGet
    MODULE PROCEDURE OC_DataProjection_ResultElementNumberGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementNumberGetObj
  END INTERFACE OC_DataProjection_ResultElementNumberGet

  !>Sets the projection element number for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementNumberSet
    MODULE PROCEDURE OC_DataProjection_ResultElementNumberSetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementNumberSetObj
  END INTERFACE OC_DataProjection_ResultElementNumberSet

  !>Returns the projection element face number for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementFaceNumberGet
    MODULE PROCEDURE OC_DataProjection_ResultElementFaceNumberGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementFaceNumberGetObj
  END INTERFACE OC_DataProjection_ResultElementFaceNumberGet

  !>Sets the projection element face number for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementFaceNumberSet
    MODULE PROCEDURE OC_DataProjection_ResultElementFaceNumberSetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementFaceNumberSetObj
  END INTERFACE OC_DataProjection_ResultElementFaceNumberSet

  !>Returns the projection element line number for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementLineNumberGet
    MODULE PROCEDURE OC_DataProjection_ResultElementLineNumberGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementLineNumberGetObj
  END INTERFACE OC_DataProjection_ResultElementLineNumberGet

  !>Sets the projection element line number for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementLineNumberSet
    MODULE PROCEDURE OC_DataProjection_ResultElementLineNumberSetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementLineNumberSetObj
  END INTERFACE OC_DataProjection_ResultElementLineNumberSet

  !>Returns the element xi for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultElementXiGet
    MODULE PROCEDURE OC_DataProjection_ResultElementXiGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultElementXiGetObj
  END INTERFACE OC_DataProjection_ResultElementXiGet

  !>Returns the projection exit tag for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultExitTagGet
    MODULE PROCEDURE OC_DataProjection_ResultExitTagGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultExitTagGetObj
  END INTERFACE OC_DataProjection_ResultExitTagGet

  !>Returns the maximum error for a data projection.
  INTERFACE OC_DataProjection_ResultMaximumErrorGet
    MODULE PROCEDURE OC_DataProjection_ResultMaximumErrorGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultMaximumErrorGetObj
  END INTERFACE OC_DataProjection_ResultMaximumErrorGet

  !>Returns the minimum error for a data projection.
  INTERFACE OC_DataProjection_ResultMinimumErrorGet
    MODULE PROCEDURE OC_DataProjection_ResultMinimumErrorGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultMinimumErrorGetObj
  END INTERFACE OC_DataProjection_ResultMinimumErrorGet

  !>Returns the RMS error for a data projection.
  INTERFACE OC_DataProjection_ResultRMSErrorGet
    MODULE PROCEDURE OC_DataProjection_ResultRMSErrorGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultRMSErrorGetObj
  END INTERFACE OC_DataProjection_ResultRMSErrorGet

  !>Returns the projection vector for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultProjectionVectorGet
    MODULE PROCEDURE OC_DataProjection_ResultProjectionVectorGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultProjectionVectorGetObj
  END INTERFACE OC_DataProjection_ResultProjectionVectorGet

  !>Returns the projection xi for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultProjectionXiGet
    MODULE PROCEDURE OC_DataProjection_ResultProjectionXiGetNumber
    MODULE PROCEDURE OC_DataProjection_ResultProjectionXiGetObj
  END INTERFACE OC_DataProjection_ResultProjectionXiGet

  !>Sets the projection xi for a data point identified by a given user number.
  INTERFACE OC_DataProjection_ResultProjectionXiSet
    MODULE PROCEDURE OC_DataProjection_ResultProjectionXiSetNumber
    MODULE PROCEDURE OC_DataProjection_ResultProjectionXiSetObj
  END INTERFACE OC_DataProjection_ResultProjectionXiSet

  PUBLIC OC_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE,OC_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE, &
    & OC_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE

  PUBLIC OC_DATA_PROJECTION_CANCELLED,OC_DATA_PROJECTION_USER_SPECIFIED,OC_DATA_PROJECTION_EXIT_TAG_CONVERGED, &
    & OC_DATA_PROJECTION_EXIT_TAG_BOUNDS,OC_DATA_PROJECTION_EXIT_TAG_MAX_ITERATION,OC_DATA_PROJECTION_EXIT_TAG_NO_ELEMENT

  PUBLIC OC_DATA_PROJECTION_DISTANCE_GREATER,OC_DATA_PROJECTION_DISTANCE_GREATER_EQUAL,OC_DATA_PROJECTION_DISTANCE_LESS, &
    & OC_DATA_PROJECTION_DISTANCE_LESS_EQUAL

  PUBLIC OC_DataProjection_AbsoluteToleranceGet,OC_DataProjection_AbsoluteToleranceSet

  PUBLIC OC_DataProjection_CreateFinish,OC_DataProjection_CreateStart

  PUBLIC OC_DataProjection_DataPointFieldEvaluate

  PUBLIC OC_DataProjection_DataPointsPositionEvaluate

  PUBLIC OC_DataProjection_DataPointsProjectionEvaluate

  PUBLIC OC_DataProjection_Destroy

  PUBLIC OC_DataProjection_ElementSet

  PUBLIC OC_DataProjection_LabelGet,OC_DataProjection_LabelSet

  PUBLIC OC_DataProjection_MaximumIterationUpdateGet,OC_DataProjection_MaximumIterationUpdateSet

  PUBLIC OC_DataProjection_MaximumNumberOfIterationsGet,OC_DataProjection_MaximumNumberOfIterationsSet

  PUBLIC OC_DataProjection_NumberOfClosestElementsGet,OC_DataProjection_NumberOfClosestElementsSet

  PUBLIC OC_DataProjection_ProjectionCancelByDataPoints

  PUBLIC OC_DataProjection_ProjectionCancelByDistance

  PUBLIC OC_DataProjection_ProjectionCancelByExitTags

  PUBLIC OC_DataProjection_ProjectionCandidateElementsSet

  PUBLIC OC_DataProjection_ProjectionCandidateFacesSet

  PUBLIC OC_DataProjection_ProjectionCandidateLinesSet

  PUBLIC OC_DataProjection_ProjectionDataCandidateElementsSet

  PUBLIC OC_DataProjection_ProjectionDataCandidateFacesSet

  PUBLIC OC_DataProjection_ProjectionDataCandidateLinesSet

  PUBLIC OC_DataProjection_ProjectionTypeGet,OC_DataProjection_ProjectionTypeSet

  PUBLIC OC_DataProjection_RelativeToleranceGet,OC_DataProjection_RelativeToleranceSet

  PUBLIC OC_DataProjection_ResultAnalysisOutput

  PUBLIC OC_DataProjection_ResultDistanceGet

  PUBLIC OC_DataProjection_ResultElementNumberGet,OC_DataProjection_ResultElementNumberSet

  PUBLIC OC_DataProjection_ResultElementFaceNumberGet,OC_DataProjection_ResultElementFaceNumberSet

  PUBLIC OC_DataProjection_ResultElementLineNumberGet,OC_DataProjection_ResultElementLineNumberSet

  PUBLIC OC_DataProjection_ResultElementXiGet

  PUBLIC OC_DataProjection_ResultExitTagGet

  PUBLIC OC_DataProjection_ResultMaximumErrorGet,OC_DataProjection_ResultMinimumErrorGet

  PUBLIC OC_DataProjection_ResultRMSErrorGet

  PUBLIC OC_DataProjection_ResultProjectionVectorGet

  PUBLIC OC_DataProjection_ResultProjectionXiGet,OC_DataProjection_ResultProjectionXiSet

  PUBLIC OC_DataProjection_StartingXiGet,OC_DataProjection_StartingXiSet

  !==================================================================================================================================
  !
  ! EquationsRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_EquationsConstants OpenCMISS::Equations::Constants
  !> \brief Equations constants.
  !>@{
  !> \addtogroup OpenCMISS_EquationsDynamicMatrixTypes OpenCMISS::Equations::Constants::DynamicMatrixTypes
  !> \brief Type of dynamic matrix in a dynamic equations
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_MATRIX_STIFFNESS=EQUATIONS_MATRIX_STIFFNESS !<A stiffness matrix (multiplies displacement values) \see OpenCMISS_EquationsDynamicMatrixTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_MATRIX_DAMPING=EQUATIONS_MATRIX_DAMPING !<A damping matrix (multiplies velocity values) \see OpenCMISS_EquationsDynamicMatrixTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_MATRIX_MASS=EQUATIONS_MATRIX_MASS !<A mass matrix (multiplies acceleration values) \see OpenCMISS_EquationsDynamicMatrixTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsOutputTypes OpenCMISS::Equations::Constants::OutputTypes
  !> \brief Equations output types
  !> \see OpenCMISS::Equations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_NO_OUTPUT = EQUATIONS_NO_OUTPUT!<No output from the equations \see OpenCMISS_EquationsOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_TIMING_OUTPUT = EQUATIONS_TIMING_OUTPUT !<Timing information output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_MATRIX_OUTPUT = EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_ELEMENT_MATRIX_OUTPUT = EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_NODAL_MATRIX_OUTPUT = EQUATIONS_NODAL_MATRIX_OUTPUT !<All below and nodal matrices output. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSparsityTypes OpenCMISS::Equations::Constants::SparsityTypes
  !> \brief Equations sparsity types
  !> \see OpenCMISS::Equations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SPARSE_MATRICES = EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the equations. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_FULL_MATRICES = EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the equations. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsLumpingTypes OpenCMISS::Equations::Constants::LumpingTypes
  !> \brief Equations lumping types
  !> \see OpenCMISS::Equations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_UNLUMPED_MATRICES = EQUATIONS_UNLUMPED_MATRICES !<The equations matrices are not lumped. \see OpenCMISS_EquationsLumpingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_LUMPED_MATRICES = EQUATIONS_LUMPED_MATRICES !<The equations matrices are "mass" lumped. \see OpenCMISS_EquationsLumpingTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsLinearityTypes OpenCMISS::Equations::Constants::LinearityTypes
  !> \brief The equations linearity types
  !> \see OpenCMISS::Equations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_LINEAR = EQUATIONS_LINEAR !<The equations are linear. \see OpenCMISS_EquationsLinearityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_NONLINEAR = EQUATIONS_NONLINEAR !<The equations are non-linear. \see \see OpenCMISS_EquationsLinearityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_NONLINEAR_BCS = EQUATIONS_NONLINEAR_BCS !<The equations have non-linear boundary conditions. \see \see OpenCMISS_EquationsLinearityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsTimeDependenceTypes OpenCMISS::Equations::Constants::TimeDependenceTypes
  !> \brief The equations time dependence types
  !> \see OpenCMISS::Equations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_STATIC = EQUATIONS_STATIC !<The equations are static and have no time dependence. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_QUASISTATIC = EQUATIONS_QUASISTATIC !<The equations are quasi-static. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_FIRST_ORDER_DYNAMIC = EQUATIONS_FIRST_ORDER_DYNAMIC !<The equations are first order dynamic. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SECOND_ORDER_DYNAMIC = EQUATIONS_SECOND_ORDER_DYNAMIC !<The equations are a second order dynamic. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_TIME_STEPPING = EQUATIONS_TIME_STEPPING !<The equations are for time stepping. \see OpenCMISS_EquationsTimeDependenceTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsJacobianCalculated OpenCMISS::Equations::Constants::JacobianCalculated
  !> \brief Equations Jacobian matrices calculation types
  !> \see OpenCMISS::Equations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED =  &
    & EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED !<Evaluate Jacobian matrix using finite differences. \see OpenCMISS_EquationsJacobianCalculated
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_JACOBIAN_ANALYTIC_CALCULATED = EQUATIONS_JACOBIAN_ANALYTIC_CALCULATED !<Evaluate Jacobian matrix using analytic expressions. \see OpenCMISS_EquationsJacobianCalculated,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys equations for an equations.
  INTERFACE OC_Equations_Destroy
    MODULE PROCEDURE OC_Equations_DestroyNumber
    MODULE PROCEDURE OC_Equations_DestroyObj
  END INTERFACE OC_Equations_Destroy

  !>Gets the distributed matrix for a dynamic matrix in an equations specified by matrix number.
  INTERFACE OC_Equations_DynamicMatrixGet
    MODULE PROCEDURE OC_Equations_DynamicMatrixGetObj
  END INTERFACE OC_Equations_DynamicMatrixGet

  !>Gets the distributed matrix for a dynamic matrix in an equation specified by matrix type.
  INTERFACE OC_Equations_DynamicMatrixGetByType
    MODULE PROCEDURE OC_Equations_DynamicMatrixGetByTypeObj
  END INTERFACE OC_Equations_DynamicMatrixGetByType

  !>Gets the type (stiffness, damping, mass) of a dynamic matrix in an equations specified by matrix number.
  INTERFACE OC_Equations_DynamicMatrixTypeGet
    MODULE PROCEDURE OC_Equations_DynamicMatrixTypeGetObj
  END INTERFACE OC_Equations_DynamicMatrixTypeGet

  !>Sets/changes the Jacobian matrix calculation types for equations
  INTERFACE OC_Equations_JacobianCalculationTypeSet
    MODULE PROCEDURE OC_Equations_JacobianCalculationTypeSetNumber
    MODULE PROCEDURE OC_Equations_JacobianCalculationTypeSetObj
  END INTERFACE OC_Equations_JacobianCalculationTypeSet

  !>Sets/changes the Jacobian matrix finite difference step size for equations
  INTERFACE OC_Equations_JacobianFiniteDifferenceStepSizeSet
    MODULE PROCEDURE OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber
    MODULE PROCEDURE OC_Equations_JacobianFiniteDifferenceStepSizeSetObj
  END INTERFACE OC_Equations_JacobianFiniteDifferenceStepSizeSet

  !>Gets the distributed matrix for a Jacobian matrix in an equation specified by variable number.
  INTERFACE OC_Equations_JacobianMatrixGetByNumber
    MODULE PROCEDURE OC_Equations_JacobianMatrixGetByNumberObj
  END INTERFACE OC_Equations_JacobianMatrixGetByNumber

  !>Gets the distributed matrix for a Jacobian matrix in an equation specified by variable type.
  INTERFACE OC_Equations_JacobianMatrixGetByType
    MODULE PROCEDURE OC_Equations_JacobianMatrixGetByTypeObj
  END INTERFACE OC_Equations_JacobianMatrixGetByType

  !>Gets the linearity type for equations.
  INTERFACE OC_Equations_LinearityTypeGet
    MODULE PROCEDURE OC_Equations_LinearityTypeGetNumber
    MODULE PROCEDURE OC_Equations_LinearityTypeGetObj
  END INTERFACE OC_Equations_LinearityTypeGet

  !>Gets the distributed matrix for a linear matrix in equations.
  INTERFACE OC_Equations_LinearMatrixGet
    MODULE PROCEDURE OC_Equations_LinearMatrixGetObj
  END INTERFACE OC_Equations_LinearMatrixGet

  !>Gets the lumping type for equations.
  INTERFACE OC_Equations_LumpingTypeGet
    MODULE PROCEDURE OC_Equations_LumpingTypeGetNumber
    MODULE PROCEDURE OC_Equations_LumpingTypeGetObj
  END INTERFACE OC_Equations_LumpingTypeGet

  !>Sets/changes the lumping type for equations.
  INTERFACE OC_Equations_LumpingTypeSet
    MODULE PROCEDURE OC_Equations_LumpingTypeSetNumber
    MODULE PROCEDURE OC_Equations_LumpingTypeSetObj
  END INTERFACE OC_Equations_LumpingTypeSet

  !>Gets the number of dynamic matrices in the equations.
  INTERFACE OC_Equations_NumberOfDynamicMatricesGet
    MODULE PROCEDURE OC_Equations_NumberOfDynamicMatricesGetObj
  END INTERFACE OC_Equations_NumberOfDynamicMatricesGet

  !>Gets the number of Jacobian matrices in a residual vector in the equations.
  INTERFACE OC_Equations_NumberOfJacobianMatricesGet
    MODULE PROCEDURE OC_Equations_NumberOfJacobianMatricesGetObj
  END INTERFACE OC_Equations_NumberOfJacobianMatricesGet

  !>Gets the number of linear matrices in the equations.
  INTERFACE OC_Equations_NumberOfLinearMatricesGet
    MODULE PROCEDURE OC_Equations_NumberOfLinearMatricesGetObj
  END INTERFACE OC_Equations_NumberOfLinearMatricesGet

  !>Gets the number of residual vectors in the equations.
  INTERFACE OC_Equations_NumberOfResidualVectorsGet
    MODULE PROCEDURE OC_Equations_NumberOfResidualVectorsGetObj
  END INTERFACE OC_Equations_NumberOfResidualVectorsGet

  !>Gets the number of source vectors in the equations.
  INTERFACE OC_Equations_NumberOfSourceVectorsGet
    MODULE PROCEDURE OC_Equations_NumberOfSourceVectorsGetObj
  END INTERFACE OC_Equations_NumberOfSourceVectorsGet

  !>Gets the output type for equations.
  INTERFACE OC_Equations_OutputTypeGet
    MODULE PROCEDURE OC_Equations_OutputTypeGetNumber
    MODULE PROCEDURE OC_Equations_OutputTypeGetObj
  END INTERFACE OC_Equations_OutputTypeGet

  !>Sets/changes the output type for equations.
  INTERFACE OC_Equations_OutputTypeSet
    MODULE PROCEDURE OC_Equations_OutputTypeSetNumber
    MODULE PROCEDURE OC_Equations_OutputTypeSetObj
  END INTERFACE OC_Equations_OutputTypeSet

  !>Gets the number of variables in a residual vector in equations.
  INTERFACE OC_Equations_ResidualNumberOfVariablesGet
    MODULE PROCEDURE OC_Equations_ResidualNumberOfVariablesGetObj
  END INTERFACE OC_Equations_ResidualNumberOfVariablesGet

  !>Gets the variable type for a variable in a residual vector in equations.
  INTERFACE OC_Equations_ResidualVariableTypeGet
    MODULE PROCEDURE OC_Equations_ResidualVariableTypeGetObj
  END INTERFACE OC_Equations_ResidualVariableTypeGet

  !>Gets the variable types in a residual vector in equations.
  INTERFACE OC_Equations_ResidualVariableTypesGet
    MODULE PROCEDURE OC_Equations_ResidualVariableTypesGetObj
  END INTERFACE OC_Equations_ResidualVariableTypesGet

  !>Gets the distributed vector for a residual vector in equations.
  INTERFACE OC_Equations_ResidualVectorGet
    MODULE PROCEDURE OC_Equations_ResidualVectorGetObj
  END INTERFACE OC_Equations_ResidualVectorGet

  !>Gets the distributed vector for a right hand side vector in equations.
  INTERFACE OC_Equations_RHSVectorGet
    MODULE PROCEDURE OC_Equations_RHSVectorGetObj
  END INTERFACE OC_Equations_RHSVectorGet

  !>Gets the sparsity type for equations.
  INTERFACE OC_Equations_SparsityTypeGet
    MODULE PROCEDURE OC_Equations_SparsityTypeGetNumber
    MODULE PROCEDURE OC_Equations_SparsityTypeGetObj
  END INTERFACE OC_Equations_SparsityTypeGet

  !>Sets/changes the sparsity type for equations.
  INTERFACE OC_Equations_SparsityTypeSet
    MODULE PROCEDURE OC_Equations_SparsityTypeSetNumber
    MODULE PROCEDURE OC_Equations_SparsityTypeSetObj
  END INTERFACE OC_Equations_SparsityTypeSet

  !>Gets the distributed vector for a source vector in equations.
  INTERFACE OC_Equations_SourceVectorGet
    MODULE PROCEDURE OC_Equations_SourceVectorGetObj
  END INTERFACE OC_Equations_SourceVectorGet

  !>Gets the time dependence type for equations.
  INTERFACE OC_Equations_TimeDependenceTypeGet
    MODULE PROCEDURE OC_Equations_TimeDependenceTypeGetNumber
    MODULE PROCEDURE OC_Equations_TimeDependenceTypeGetObj
  END INTERFACE OC_Equations_TimeDependenceTypeGet

  PUBLIC OC_EQUATIONS_MATRIX_STIFFNESS,OC_EQUATIONS_MATRIX_DAMPING,OC_EQUATIONS_MATRIX_MASS

  PUBLIC OC_EQUATIONS_NO_OUTPUT,OC_EQUATIONS_TIMING_OUTPUT,OC_EQUATIONS_MATRIX_OUTPUT, &
    & OC_EQUATIONS_ELEMENT_MATRIX_OUTPUT,OC_EQUATIONS_NODAL_MATRIX_OUTPUT

  PUBLIC OC_EQUATIONS_SPARSE_MATRICES,OC_EQUATIONS_FULL_MATRICES

  PUBLIC OC_EQUATIONS_JACOBIAN_FINITE_DIFFERENCE_CALCULATED, OC_EQUATIONS_JACOBIAN_ANALYTIC_CALCULATED

  PUBLIC OC_EQUATIONS_UNLUMPED_MATRICES,OC_EQUATIONS_LUMPED_MATRICES

  PUBLIC OC_EQUATIONS_LINEAR,OC_EQUATIONS_NONLINEAR,OC_EQUATIONS_NONLINEAR_BCS

  PUBLIC OC_EQUATIONS_STATIC,OC_EQUATIONS_QUASISTATIC,OC_EQUATIONS_FIRST_ORDER_DYNAMIC, &
    & OC_EQUATIONS_SECOND_ORDER_DYNAMIC,OC_EQUATIONS_TIME_STEPPING

  PUBLIC OC_Equations_Destroy

  PUBLIC OC_Equations_DynamicMatrixGet

  PUBLIC OC_Equations_DynamicMatrixGetByType

  PUBLIC OC_Equations_DynamicMatrixTypeGet

  PUBLIC OC_Equations_JacobianCalculationTypeSet

  PUBLIC OC_Equations_JacobianFiniteDifferenceStepSizeSet

  PUBLIC OC_Equations_JacobianMatrixGetByNumber

  PUBLIC OC_Equations_JacobianMatrixGetByType

  PUBLIC OC_Equations_LinearityTypeGet

  PUBLIC OC_Equations_LinearMatrixGet

  PUBLIC OC_Equations_LumpingTypeGet,OC_Equations_LumpingTypeSet

  PUBLIC OC_Equations_NumberOfDynamicMatricesGet

  PUBLIC OC_Equations_NumberOfJacobianMatricesGet

  PUBLIC OC_Equations_NumberOfLinearMatricesGet

  PUBLIC OC_Equations_NumberOfResidualVectorsGet

  PUBLIC OC_Equations_NumberOfSourceVectorsGet

  PUBLIC OC_Equations_OutputTypeGet,OC_Equations_OutputTypeSet

  PUBLIC OC_Equations_ResidualNumberOfVariablesGet

  PUBLIC OC_Equations_ResidualVariableTypeGet

  PUBLIC OC_Equations_ResidualVariableTypesGet

  PUBLIC OC_Equations_ResidualVectorGet

  PUBLIC OC_Equations_RHSVectorGet

  PUBLIC OC_Equations_SourceVectorGet

  PUBLIC OC_Equations_SparsityTypeGet,OC_Equations_SparsityTypeSet

  PUBLIC OC_Equations_TimeDependenceTypeGet


  !==================================================================================================================================
  !
  ! EquationsSetRoutines
  !
  !==================================================================================================================================


  !Module parameters

  !> \addtogroup OpenCMISS_EquationsSetRoutines OpenCMISS::EquationsSet::Constants
  !> \brief Equations set constants.
  !>@{
  !> \addtogroup OpenCMISS_EquationsSetClasses OpenCMISS::EquationsSet::Constants::Classes
  !> \brief Equations set classes.
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NO_CLASS = EQUATIONS_SET_NO_CLASS !<No equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELASTICITY_CLASS = EQUATIONS_SET_ELASTICITY_CLASS !<Elasticity equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FLUID_MECHANICS_CLASS = EQUATIONS_SET_FLUID_MECHANICS_CLASS !<Fluid Mechanics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELECTROMAGNETICS_CLASS = EQUATIONS_SET_ELECTROMAGNETICS_CLASS !<Electromagnetics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CLASSICAL_FIELD_CLASS = EQUATIONS_SET_CLASSICAL_FIELD_CLASS !<Classical Field equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BIOELECTRICS_CLASS = EQUATIONS_SET_BIOELECTRICS_CLASS !<Bioelectrics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MODAL_CLASS = EQUATIONS_SET_MODAL_CLASS !<Modal equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FITTING_CLASS = EQUATIONS_SET_FITTING_CLASS !<Fitting equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_OPTIMISATION_CLASS = EQUATIONS_SET_OPTIMISATION_CLASS !<Optimisation equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_PHYSICS_CLASS = EQUATIONS_SET_MULTI_PHYSICS_CLASS !<Multi Physics equations set class \see OpenCMISS_EquationsSetClasses,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSetTypes OpenCMISS::EquationsSet::Constants::Types
  !> \brief Equations set Types.
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NO_TYPE = EQUATIONS_SET_NO_TYPE !<No equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE = EQUATIONS_SET_LINEAR_ELASTICITY_TYPE !<Linear elasticity equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_TYPE !<Finite elasticity equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_TYPE = EQUATIONS_SET_STOKES_EQUATION_TYPE !<Stokes equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_TYPE = EQUATIONS_SET_DARCY_EQUATION_TYPE !<Darcy equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE = EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE !<Darcy pressure equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE = EQUATIONS_SET_POISEUILLE_EQUATION_TYPE !<Poiseuille equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BURGERS_EQUATION_TYPE = EQUATIONS_SET_BURGERS_EQUATION_TYPE !<Burgers equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE = EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE !<Characteristic equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STREE_EQUATION_TYPE = EQUATIONS_SET_STREE_EQUATION_TYPE !<Characteristic equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELECTROSTATIC_TYPE = EQUATIONS_SET_ELECTROSTATIC_TYPE !<Electrostatic equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MAGNETOSTATIC_TYPE = EQUATIONS_SET_MAGNETOSTATIC_TYPE !<Magnetostatic equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE = EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE !<Maxwells equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LAPLACE_EQUATION_TYPE = EQUATIONS_SET_LAPLACE_EQUATION_TYPE !<Laplace equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_POISSON_EQUATION_TYPE = EQUATIONS_SET_POISSON_EQUATION_TYPE !<Poisson equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE = EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE !<Helmholtz equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_WAVE_EQUATION_TYPE = EQUATIONS_SET_WAVE_EQUATION_TYPE !<Wave equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_DIFFUSION_EQUATION_TYPE !<Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ADVECTION_EQUATION_TYPE = EQUATIONS_SET_ADVECTION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE = EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE !<Biharmonic equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE = EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE !<Monodomain equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE = EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE !<Bidomain equation equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE = EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE !<Linear elasticity modal equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE = EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE !<Data point fitting equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GAUSS_FITTING_EQUATION_TYPE = EQUATIONS_SET_GAUSS_FITTING_EQUATION_TYPE !<Gauss point fitting equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity Navier Stokes equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE = EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE = &
    & EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion equations set type \see OpenCMISS_EquationsSetTypes,OpenCMISS

  !>@}
  !> \addtogroup OpenCMISS_EquationsSetSubtypes OpenCMISS::EquationsSet::Constants::Subtypes
  !> \brief Equations set subtypes.
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NO_SUBTYPE = EQUATIONS_SET_NO_SUBTYPE !<No equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_THREE_DIMENSIONAL_ISOTROPIC_SUBTYPE = &
    & EQUATIONS_SET_THREE_DIMENSIONAL_ISOTROPIC_SUBTYPE !<Three dimensional isotropic linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_THREE_DIMENSIONAL_ORTHOTROPIC_SUBTYPE = &
    & EQUATIONS_SET_THREE_DIMENSIONAL_ORTHOTROPIC_SUBTYPE !<Three dimensional orthotropic linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE !<Plane stress linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE !<Plane strain linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE !<One dimensional linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_PLATE_SUBTYPE = EQUATIONS_SET_PLATE_SUBTYPE !<Plate linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_SHELL_SUBTYPE = EQUATIONS_SET_SHELL_SUBTYPE !<Shell linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ONE_DIM_STOKES_DAMPING_SUBTYPE = EQUATIONS_SET_ONE_DIM_STOKES_DAMPING_SUBTYPE !<One dimensionsional Stokes damping linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TWO_DIM_PLANE_STRESS_STOKES_DAMPING_SUBTYPE =  &
    & EQUATIONS_SET_TWO_DIM_PLANE_STRESS_STOKES_DAMPING_SUBTYPE !<Two dimensionsional plane stress Stokes damping linear elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE = EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_NEARLY_INCOMP_MOONEY_RIVLIN_SUBTYPE !< Nearly Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVE_CONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVE_CONTRACTION_SUBTYPE !< Mooney-Rivlin constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ST_VENANT_KIRCHOFF_ACTIVE_CONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_ST_VENANT_KIRCHOFF_ACTIVE_CONTRACTION_SUBTYPE !< St Venant Kirchoff constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ACTIVE_CONTRACTION_SUBTYPE =&
    & EQUATIONS_SET_ACTIVE_CONTRACTION_SUBTYPE !< Active contraction/costa-based law with quasistatic time loop for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE = EQUATIONS_SET_ISOTROPIC_EXP_SUBTYPE !< Isotropic exponential constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_EXP_SUBTYPE !< Transverse isotropic exponential constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_CONTRACTION_SUBTYPE !< Transverse isotropic, active-contraction constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE !< Transverse isotropic, active-contraction material-transition constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_COSTA_SUBTYPE !< Orthotropic Costa constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COMPRESSIBLE_ACTIVE_CONTRACTION_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_ACTIVE_CONTRACTION_SUBTYPE !<Compressible version for finite elasticity equations set with active contraction subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE !< Isotropic active strain constitutive law based on multiplicative decomposition of the deformation gradient subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE !< Isotropic active strain constitutive law based on multiplicative decomposition of the deformation gradient and the cellular model of Razumova et al. (2000) subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE !< Determine the reference configuration using Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_REFERENCE_STATE_TRANS_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equstions set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_SUBTYPE !< Transverse isotropic Guccione constitutive law with active contraction subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_NOLENDEP_SUBTYPE = &
    & EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_NOLENDEP_SUBTYPE !< Transverse isotropic Guccione constitutive law with active contraction subtype without length dependence \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_2NDPIOLA_SUBTYPE = &
    & EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_2NDPIOLA_SUBTYPE !< Transverse isotropic Guccione constitutive law with active contraction subtype for benchmark problem \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE !<Incompressible version for finite elasticity coupled with Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE !<INRIA Model for finite elasticity coupled with Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_MULTI_COMPARTMENT_DARCY_INRIA_SUBTYPE !<Multi Compartment Darcy INRIA Model coupled with finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure, formulated in terms of modified invariants. \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MEMBRANE_SUBTYPE = EQUATIONS_SET_MEMBRANE_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE !< Orthotropic Holzapfel-Ogden constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVE_CONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVE_CONTRACTION_SUBTYPE &
    & !< Orthotropic Holzapfel-Ogden constitutive law with active contraction for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
    INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE = &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE !< Static finite elasticity coupled with fluid pressure set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ELASTI_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype with active contraction \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_POLYNOMIAL_SUBTYPE !<Transverse isotropic constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE !<Anisotropic polynomial constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_CONTRACTION_SUBTYPE !<Anisotropic polynomial active constitutive law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE= &
    & EQUATIONS_SET_TRANS_ISOTROPIC_HUMPHREY_YIN_SUBTYPE !<Humphrey and Yin transversely isotropic constitutive relation subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE !<Dynamic St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE !<Dynamic Mooney-Rivlin constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_COMPRESSIBLE_ST_VENANT_KIRCHOFF_SUBTYPE !<Dynamic compressible St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_DYNAMIC_COMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !<Dynamic compressible Mooney-Rivlin constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_COMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !<Compressible Mooney-Rivlin constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE !<St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE = &
    & EQUATIONS_SET_COMPRESSIBLE_ST_VENANT_KIRCHOFF_SUBTYPE !<Compressible St Venant-Kirchoff constitutative \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STATIC_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_STOKES_SUBTYPE !<Static Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ALE_STOKES_SUBTYPE = EQUATIONS_SET_ALE_STOKES_SUBTYPE !<ALE Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE !<Transient residual-based stabilisation Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE =  &
    & EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE !<Transient residual-based stabilisation Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE !<Transient stabilised 3D Navier-Stokes equations set with coupled multiscale boundaries subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE !<Transient stabilised 3D Navier-Stokes equations set with coupled constitutive model for non-Newtonian viscosity \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes equations set subtype with coupled Advection \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CHARACTERISTIC_SUBTYPE = &
    & EQUATIONS_SET_CHARACTERISTIC_SUBTYPE !<Static Characteristics equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STREE1D0D_SUBTYPE = &
    & EQUATIONS_SET_STREE1D0D_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE = &
    & EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ALE_RBS_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_RBS_NAVIER_STOKES_SUBTYPE !<ALE with RBS Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE = EQUATIONS_SET_STANDARD_DARCY_SUBTYPE !<Standard Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE = EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ALE_DARCY_SUBTYPE = EQUATIONS_SET_ALE_DARCY_SUBTYPE !<ALE Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE !<Transient ALE Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE = EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE !<Multi Compartment Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BURGERS_SUBTYPE = EQUATIONS_SET_BURGERS_SUBTYPE !<Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE = EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE !<Generalised Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE = EQUATIONS_SET_STATIC_BURGERS_SUBTYPE !<Static Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE = EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE !<Inviscid Burgers equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE = EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE = EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE = EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE !<Moving mesh Laplace equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE !<Dynamic Poiseuille equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_POISSON_SUBTYPE = EQUATIONS_SET_GENERALISED_POISSON_SUBTYPE !<Constant source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE !<Quadratic source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE !<Exponential source Poisson equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Poisson equations set subtype, that is the extracellular bidomain equation \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_DIFFUSION_SUBTYPE = EQUATIONS_SET_GENERALISED_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_ALE_DIFFUSION_SUBTYPE = EQUATIONS_SET_GENERALISED_ALE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE !<Multi-compartment transport diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ADVECTION_SUBTYPE = &
    & EQUATIONS_SET_ADVECTION_SUBTYPE !<advection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUBTYPE !<Generalised advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE !<Linear source advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE !<In CellML evaluated incompressible material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE = EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE !<Rubin rate based smooth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE =  &
    & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE !<Rubin compressible rate based smooth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE = &
    & EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE !<Rubin rate based growth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE = &
    & EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE !<Rubin compressible rate based growth model for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTIT_AND_GROWTH_LAW_IN_CELLML_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE !<CellML evaluated growth and constituative material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CELLML_GROWTH_LAW_SUBTYPE = EQUATIONS_SET_CELLML_GROWTH_LAW_SUBTYPE !<CellML evaluated growth or finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CELLML_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE = &
    & EQUATIONS_SET_CELLML_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE !<CellML evaluated growth and Neo-Hookean constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CELLML_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_CELLML_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE !<CellML evaluated growth and Mooney-Rivlin constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FIBRE_GROWTH_LAW_ST_VENANT_SUBTYPE = &
    & EQUATIONS_SET_FIBRE_GROWTH_LAW_ST_VENANT_SUBTYPE !<Fibre growth tensor law and St. Venant-Kirchoff constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_ST_VENANT_SUBTYPE = &
    & EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_ST_VENANT_SUBTYPE !<Isotropic growth tensor law and St. Venant-Kirchoff constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_ST_VENANT_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_ST_VENANT_SUBTYPE !<Transversely isotropic growth tensor law and St. Venant-Kirchoff constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_ST_VENANT_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_ST_VENANT_SUBTYPE !<Orthotropic growth tensor law and St. Venant-Kirchoff constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_ST_VENANT_SUBTYPE = &
    & EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_ST_VENANT_SUBTYPE !<Full specificied growth tensor law and St. Venant-Kirchoff constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FIBRE_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE = &
    & EQUATIONS_SET_FIBRE_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE !<Fibre growth tensor law and Neo-Hookean constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE = &
    & EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE !<Isotropic growth tensor law and Neo-Hookean constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE !<Transversely isotropic growth tensor law and Neo-Hookean constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE !<Orthotropic growth tensor law and Neo-Hookean constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE = &
    & EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE !<Full specificied growth tensor law and Neo-Hookean constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FIBRE_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_FIBRE_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE !<Fibre growth tensor law and Mooney-Rivlin constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE !<Isotropic growth tensor law and Mooney-Rivlin constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE !<Transversely isotropic growth tensor law and Mooney-Rivlin constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE !<Orthotropic growth tensor law and Mooney-Rivlin constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE = &
    & EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE !<Full specificied growth tensor law and Mooney-Rivlin constitutive material law for finite elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE !<Generalsed ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Linear source ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Quadratic source ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Exponential source ALE advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE !<Generalised static advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source static advection diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUPG_SUBTYPE !<Generalised source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Generalised ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Quadratic source ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE !<Exponential source ALE advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Generalised static advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source static advection diffusion equations set subtype with SUPG \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE !<Coupled diffusion & advection-diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE !<Multi-component transport advection-diffusion equations set \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE !<Multi-component transport advection-diffusion equations set using SUPG scheme \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CELLML_SPLIT_GEN_REACT_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_SPLIT_GEN_REACT_DIFF_SUBTYPE !<Generalised reaction-diffusion with a CellML reaction term and operator splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CELLML_NOSPLIT_LINEAR_GEN_REACT_DIFF_SUBTYPE= &
    & EQUATIONS_SET_CELLML_NOSPLIT_LINEAR_GEN_REACT_DIFF_SUBTYPE !<Generalised reaction-diffusion with a linear CellML reaction term and no operator splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CELLML_NOSPLIT_NONLIN_GEN_REACT_DIFF_SUBTYPE= &
    & EQUATIONS_SET_CELLML_NOSPLIT_NONLINEAR_GEN_REACT_DIFF_SUBTYPE !<Generalised reaction-diffusion with a nonlinear CellML reaction term and no operator splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GEN_FISHERS_SPLIT_REACT_DIFF_SUBTYPE= &
    & EQUATIONS_SET_GEN_FISHERS_SPLIT_REACT_DIFF_SUBTYPE !<Generalised Fisher's reaction-diffusion with operator splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GEN_FISHERS_NOSPLIT_REACT_DIFF_SUBTYPE= &
    & EQUATIONS_SET_GEN_FISHERS_NOSPLIT_REACT_DIFF_SUBTYPE !<Generalised Fisher's reaction-diffusion without operator splitting \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MONODOMAIN_CELLML_SUBTYPE= EQUATIONS_SET_MONODOMAIN_CELLML_SUBTYPE !<CellML monodomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE= EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Bueno-Orovio monodomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE= EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Ten Tusscher 2006 monodomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE = EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE !<First bidomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE = EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE !<Second bidomain equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised data point fitting equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_TENSOR_FIBRE_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE !<Diffusion tensor fibre data point fitting equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_GAUSS_FITTING_SUBTYPE !<Generalised Gauss point fitting equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MAT_PROPERTIES_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_GAUSS_FITTING_SUBTYPE !<Material Properties Galerkin Projection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MAT_PROP_INRIA_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_INRIA_GAUSS_FITTING_SUBTYPE !<Material Properties INRIA Model Galerkin Projection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIV_FREE_GAUSS_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIV_FREE_GAUSS_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS


  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE = &
    & EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled diffusion-diffusion equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE !<Standard Monodomain Elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with titin \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with force-velocity relation \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE =  &
    & EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype \see OpenCMISS_EquationsSetSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Finite Elasticity Navier Stokes ALE equations set subtype \see OpenCMISS_EquationsSetSubtype,OpenCMISS

  !>@}
  !> \addtogroup OpenCMISS_EquationsSetFittingSmoothingTypes OpenCMISS::EquationsSet::Fitting::Constants::SmoothingTypes
  !> \brief The smoothing types for fitting equations sets.
  !> \see OpenCMISS::EquationsSet::Fitting::Constants,OpenCMISS::EquationsSet::Fitting
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FITTING_NO_SMOOTHING = &
    & EQUATIONS_SET_FITTING_NO_SMOOTHING !<No smoothing \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FITTING_SOBOLEV_VALUE_SMOOTHING = &
    & EQUATIONS_SET_FITTING_SOBOLEV_VALUE_SMOOTHING !<Sobolev smoothing on the value of the dependent field \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FITTING_SOBOLEV_DIFFERENCE_SMOOTHING = &
    & EQUATIONS_SET_FITTING_SOBOLEV_DIFFERENCE_SMOOTHING !<Sobolev smoothing on the difference between the current and initial value of the dependent field \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FITTING_STRAIN_ENERGY_SMOOTHING = &
    & EQUATIONS_SET_FITTING_STRAIN_ENERGY_SMOOTHING !<Sobolev smoothing on the strain energy of the dependent field \see OpenCMISS_EquationsSetFittingSmoothingTypes,OpenCMISS
  !>@}

  !>@}
  !> \addtogroup OpenCMISS_EquationsSetSolutionMethods OpenCMISS::EquationsSet::Constants::SolutionMethods
  !> \brief The solution method parameters
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FEM_SOLUTION_METHOD = EQUATIONS_SET_FEM_SOLUTION_METHOD !<Finite Element Method solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BEM_SOLUTION_METHOD = EQUATIONS_SET_BEM_SOLUTION_METHOD !<Boundary Element Method solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FD_SOLUTION_METHOD = EQUATIONS_SET_FD_SOLUTION_METHOD !<Finite Difference solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FV_SOLUTION_METHOD = EQUATIONS_SET_FV_SOLUTION_METHOD !<Finite Volume solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GFEM_SOLUTION_METHOD = EQUATIONS_SET_GFEM_SOLUTION_METHOD !<Grid-based Finite Element Method solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GFD_SOLUTION_METHOD = EQUATIONS_SET_GFD_SOLUTION_METHOD !<Grid-based Finite Difference solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GFV_SOLUTION_METHOD = EQUATIONS_SET_GFV_SOLUTION_METHOD !<Grid-based Finite Volume solution method. \see OpenCMISS_EquationsSetSolutionMethods,OpenCMISS
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetDerivedTensorTypes OpenCMISS::EquationsSet::Constants::DerivedTensorTypes
  !> \brief EquationsSet derived tensor type parameters
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT = EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR !<Deformation gradient tensor, F, output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT_SPATIAL = &
    & EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR_SPATIAL !<Deformation gradient tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT_FIBRE = &
    & EQUATIONS_SET_DEFORMATION_GRADIENT_TENSOR_FIBRE !<Deformation gradient tensor field wrt fibre coordinates, FNu, output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_DEFORMATION_ELASTIC = EQUATIONS_SET_DEFORMATION_ELASTIC_TENSOR !<Elastic deformation tensor field, Fe, output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_DEFORMATION_GROWTH = EQUATIONS_SET_DEFORMATION_GROWTH_TENSOR !<Growth deformation tensor field, Fg, output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_RIGHT_STRETCH = EQUATIONS_SET_RIGHT_STRETCH_TENSOR !<Deformation right stretch tensor field output i.e., U from F = R.U \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_LEFT_STRETCH = EQUATIONS_SET_LEFT_STRETCH_TENSOR !<Deformation left stretch tensor field output i.e., v from F = v.R \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_ROTATION = EQUATIONS_SET_ROTATION_TENSOR !<Deformation rotation tensor field output i.e., R from F = R.U = v.R \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_RIGHT_STRETCH_FIBRE = EQUATIONS_SET_RIGHT_STRETCH_TENSOR_FIBRE !<Deformation right stretch tensor field wrt fibre coordinates output i.e., U from FNu = R.U \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_LEFT_STRETCH_FIBRE = EQUATIONS_SET_LEFT_STRETCH_TENSOR_FIBRE !<Deformation left stretch tensor field wrt fibre coordinates output i.e., v from FNu = v.R \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_ROTATION_FIBRE = EQUATIONS_SET_ROTATION_TENSOR_FIBRE !<Deformation rotation tensor field wrt fibre coordinates output i.e., R from FNu = R.U = v.R \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_R_CAUCHY_GREEN_DEFORMATION = &
    & EQUATIONS_SET_R_CAUCHY_GREEN_DEFORMATION_TENSOR !<Right Cauchy-Green deformation field \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_L_CAUCHY_GREEN_DEFORMATION = &
    & EQUATIONS_SET_L_CAUCHY_GREEN_DEFORMATION_TENSOR !<Left Cauchy-Green deformation field \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_GREEN_LAGRANGE_STRAIN = EQUATIONS_SET_GREEN_LAGRANGE_STRAIN_TENSOR !<Green strain tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_SMALL_STRAIN = EQUATIONS_SET_SMALL_STRAIN_TENSOR !<Small strain tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_CAUCHY_STRESS = EQUATIONS_SET_CAUCHY_STRESS_TENSOR !<Cauchy stress tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_CAUCHY_STRESS_FIBRE = EQUATIONS_SET_CAUCHY_STRESS_TENSOR_FIBRE !<Cauchy stress tensor (wrt deformed fibres) field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_FIRST_PK_STRESS = EQUATIONS_SET_FIRST_PK_STRESS_TENSOR !<1st Piola-Kirchoff stress tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_SECOND_PK_STRESS = EQUATIONS_SET_SECOND_PK_STRESS_TENSOR !<2nd Piola-Kirchoff stress tensor field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DERIVED_ELASTIC_WORK = EQUATIONS_SET_ELASTIC_WORK !<Elastic work field output. \see OpenCMISS_EquationsSetDerivedTensorTypes,OpenCMISS
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetOutputTypes OpenCMISS::EquationsSet::Constants::OutputTypes
  !> \brief Equations set output types
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NO_OUTPUT = EQUATIONS_SET_NO_OUTPUT!<No output from the equations set \see OpenCMISS_EquationsSetOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_PROGRESS_OUTPUT = EQUATIONS_SET_PROGRESS_OUTPUT !<Progress information output for the equations set. \see OpenCMISS_EquationsSetOutputTypes,OpenCMISS
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes
  !> \brief The analytic function types.
  !> \see OpenCMISS::EquationsSet::Constants,OpenCMISS::EquationsSet
  !>@{
  !> \addtogroup OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Laplace
  !> \brief The analytic function types for a Laplace equation
  !> \see OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes,OpenCMISS::EquationsSet::Constants
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_TWO_DIM_1 !<u=x**2+2*x*y-y**2 \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_TWO_DIM_2 = &
    & EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_TWO_DIM_2 !<u=cos(x)cosh(y) \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_THREE_DIM_1 = &
    & EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_THREE_DIM_1 !<u=x**2-2*y**2+z**2 \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_THREE_DIM_2 = &
    & EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_THREE_DIM_2 !<u=cos(x)*cosh(y)*z \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_LAPLACE_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_GENERALISED_LAPLACE_EQUATION_TWO_DIM_1 !<u=2.e^x.e^{-\lambda_{1}.y}cos(\lambda_{2}y) \see OpenCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSetHelmholtzAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Helmholtz
  !> \brief The analytic function types for a Helmholtz equation
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 = EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 !<u=cos(sqrt(2)*k*x)*sin(sqrt(2)*k*y) \see OpenCMISS_EquationsSetHelmholtzAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_PoiseuilleAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Poiseuille
  !> \brief The analytic function types for a Poiseuille equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OpenCMISS_EquationsSetPoiseuilleAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_PoissonAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Poisson
  !> \brief The analytic function types for a Poisson equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_2 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_1 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_1 !<u=ln(6/(x+y+z+1^2)) \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_2 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_3 = EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_QUADRATIC_POISSON_EQUATION_TWO_DIM_1 !<u=??? \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXPONENTIAL_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_EXPONENTIAL_POISSON_EQUATION_TWO_DIM_1 !<\see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetPoissonAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DiffusionAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Diffusion
  !> \brief The analytic function types for a diffusion equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OpenCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 !<
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1 = &
    & EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_EQUATION_THREE_DIM_1
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1

  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM !<Prescribed solution, using a source term to correct for error - 2D with 2 compartments
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 2 compartments
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  !>@}
  !> \addtogroup OpenCMISS_AdvectionDiffusionAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::AdvectionDiffusion
  !> \brief The analytic function types for an advection-diffusion equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OpenCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_ReactionDiffusionAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::ReactionDiffusion
  !> \brief The analytic function types for a reaction-diffusion equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_ONE_DIM_1 !<Fisher's equation, u(x,t)=1/[1 + A.exp(-5.c.t/6 +/- \sqrt(6.c)x/6)]^2 \see OpenCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_StokesAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Stokes
  !> \brief The analytic function types for a Stokes equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetStokesAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_NavierStokesAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::NavierStokes
  !> \brief The analytic function types for a Navier-Stokes equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE !< fully developed 2D channel flow (parabolic) \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN !< 2D dynamic nonlinear Taylor-Green vortex decay \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID !< A sinusoidal flow waveform
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE !< Spline integration of dependent values specified in a file
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OpenCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DarcyAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Darcy
  !> \brief The analytic function types for a Darcy equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 !<u=tbd \see OpenCMISS_EquationsSetDarcyAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY = &
    & EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY !<this is a solution where the finite elasticity solve is skipped to allow easy analytic testing of the mass increase & velocity solve step of incompressible poromechanical model
  !>@}
  !> \addtogroup OpenCMISS_BurgersAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::Burgers
  !> \brief The analytic function types for a Burgers equation.
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1 = EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1
  !>@}

  !> \addtogroup OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::LinearElasticity
  !> \brief The analytic function types for a LinearElasticity equation
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 !<u=tbd \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_LINEAR_ELASTICITY_CANTILEVER_END_LOAD = EQUATIONS_SET_LINEAR_ELASTICITY_CANTILEVER_END_LOAD !<Cantilever with a point load at the free end \see OpenCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes OpenCMISS::EquationsSet::Constants::AnalyticFunctionTypes::FiniteElasticity
  !> \brief The analytic function types for a FiniteElasticity equation
  !> \see OpenCMISS::EquationsSet::AnalyticFunctionTypes,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER = EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER !<u=tbd \see OpenCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER_GROWTH = EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER_GROWTH !<u=tbd \see OpenCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes,OpenCMISS
  !>@}
  !>@}
  !>@}

  !> \addtogroup OpenCMISS_AnalyticParamIndices OpenCMISS::FiniteElasticity::AnalyticParamIndices
  !> \brief Indices for EquationsSetAnalyticType%analyticUserParams
  !> \see OpenCMISS::FiniteElasticity::AnalyticParamIndices,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX !<Inner pressure parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX !<Outer pressure parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX !<Lambda parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX !<Tsi parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX !<Inner radius parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX !<Outer radius parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX !<c1 parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX !<c2 parameter index \see OpenCMISS_AnalyticParamIndices,OpenCMISS
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC OC_EQUATIONS_SET_NO_CLASS,OC_EQUATIONS_SET_ELASTICITY_CLASS,OC_EQUATIONS_SET_FLUID_MECHANICS_CLASS, &
    & OC_EQUATIONS_SET_ELECTROMAGNETICS_CLASS,OC_EQUATIONS_SET_CLASSICAL_FIELD_CLASS,OC_EQUATIONS_SET_BIOELECTRICS_CLASS, &
    & OC_EQUATIONS_SET_MODAL_CLASS,OC_EQUATIONS_SET_FITTING_CLASS,OC_EQUATIONS_SET_OPTIMISATION_CLASS, &
    & OC_EQUATIONS_SET_MULTI_PHYSICS_CLASS

  PUBLIC OC_EQUATIONS_SET_NO_TYPE,OC_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE,OC_EQUATIONS_SET_FINITE_ELASTICITY_TYPE, &
    & OC_EQUATIONS_SET_STOKES_EQUATION_TYPE,OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_DARCY_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE,OC_EQUATIONS_SET_BURGERS_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE, &
    & OC_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE, &
    & OC_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_STREE_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_ELECTROSTATIC_TYPE,OC_EQUATIONS_SET_MAGNETOSTATIC_TYPE,OC_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE, &
    & OC_EQUATIONS_SET_LAPLACE_EQUATION_TYPE,OC_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_POISSON_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE,OC_EQUATIONS_SET_WAVE_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE,OC_EQUATIONS_SET_ADVECTION_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE,OC_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE,OC_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE, &
    & OC_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE, &
    & OC_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE,OC_EQUATIONS_SET_GAUSS_FITTING_EQUATION_TYPE

  PUBLIC OC_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE, &
    & OC_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE, OC_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & OC_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE, OC_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE

  PUBLIC OC_EQUATIONS_SET_NO_SUBTYPE,OC_EQUATIONS_SET_THREE_DIMENSIONAL_ISOTROPIC_SUBTYPE, &
    & OC_EQUATIONS_SET_THREE_DIMENSIONAL_ORTHOTROPIC_SUBTYPE,OC_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
    & OC_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE,OC_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE, &
    & OC_EQUATIONS_SET_PLATE_SUBTYPE,OC_EQUATIONS_SET_SHELL_SUBTYPE, &
    & OC_EQUATIONS_SET_ONE_DIM_STOKES_DAMPING_SUBTYPE,OC_EQUATIONS_SET_TWO_DIM_PLANE_STRESS_STOKES_DAMPING_SUBTYPE, &
    & OC_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,OC_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_REFERENCE_STATE_MOONEY_RIVLIN_SUBTYPE, OC_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
    & OC_EQUATIONS_SET_ACTIVE_CONTRACTION_SUBTYPE,OC_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVE_CONTRACTION_SUBTYPE, &
    & OC_EQUATIONS_SET_COMPRESSIBLE_ACTIVE_CONTRACTION_SUBTYPE,OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE,OC_EQUATIONS_SET_ST_VENANT_KIRCHOFF_ACTIVE_CONTRACTION_SUBTYPE, &
    & OC_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,OC_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,OC_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
    & OC_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,OC_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE, &
    & OC_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE,OC_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE, &
    & OC_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
    & OC_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE, &
    & OC_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE,OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
    & OC_EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_SUBTYPE, &
    & OC_EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_NOLENDEP_SUBTYPE, &
    & OC_EQUATIONS_SET_GUCCIONE_ACTIVE_CONTRACTION_2NDPIOLA_SUBTYPE, &
    & OC_EQUATIONS_SET_ACTIVE_STRAIN_SUBTYPE, &
    & OC_EQUATIONS_SET_MULTISCALE_ACTIVE_STRAIN_SUBTYPE, &
    & OC_EQUATIONS_SET_REFERENCE_STATE_TRANSVERSE_GUCCIONE_SUBTYPE, &
    & OC_EQUATIONS_SET_MEMBRANE_SUBTYPE, OC_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE, &
    & OC_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVE_CONTRACTION_SUBTYPE,  &
    & OC_EQUATIONS_SET_DYNAMIC_ST_VENANT_KIRCHOFF_SUBTYPE,OC_EQUATIONS_SET_DYNAMIC_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_DYNAMIC_COMP_ST_VENANT_KIRCHOFF_SUBTYPE,OC_EQUATIONS_SET_DYNAMIC_COMP_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_COMP_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_ST_VENANT_KIRCHOFF_SUBTYPE, OC_EQUATIONS_SET_COMP_ST_VENANT_KIRCHOFF_SUBTYPE, &
    & OC_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE, &
    & OC_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE, &
    & OC_EQUATIONS_SET_ELASTI_FLUID_PRES_HOLMES_MOW_ACTIVE_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE, &
    & OC_EQUATIONS_SET_STATIC_STOKES_SUBTYPE, OC_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE,OC_EQUATIONS_SET_ALE_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE, OC_EQUATIONS_SET_ALE_RBS_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE,OC_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE,OC_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE, OC_EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_CHARACTERISTIC_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE, OC_EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_STREE1D0D_SUBTYPE, OC_EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE, &
    & OC_EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE, &
    & OC_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE,OC_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE, &
    & OC_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE,OC_EQUATIONS_SET_ALE_DARCY_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE,OC_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE, &
    & OC_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE,OC_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE,OC_EQUATIONS_SET_GENERALISED_POISSON_SUBTYPE, &
    & OC_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE, OC_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & OC_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE, OC_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE,&
    & OC_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE,OC_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE, &
    & OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE,OC_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE,OC_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE,OC_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_ALE_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE,OC_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_ADVECTION_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_EXP_SOURCE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_EXP_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE,OC_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE, &
    & OC_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE,OC_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE, &
    & OC_EQUATIONS_SET_MONODOMAIN_CELLML_SUBTYPE, &
    & OC_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE, &
    & OC_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE, &
    & OC_EQUATIONS_SET_DIFFUSION_TENSOR_FIBRE_DATA_FITTING_SUBTYPE, &
    & OC_EQUATIONS_SET_GENERALISED_GAUSS_FITTING_SUBTYPE, &
    & OC_EQUATIONS_SET_MAT_PROPERTIES_GAUSS_FITTING_SUBTYPE,OC_EQUATIONS_SET_MAT_PROP_INRIA_GAUSS_FITTING_SUBTYPE, &
    & OC_EQUATIONS_SET_DIV_FREE_GAUSS_FITTING_SUBTYPE, &
    & OC_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
    & OC_EQUATIONS_SET_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE, &
    & OC_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_BURGERS_SUBTYPE,OC_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE, &
    & OC_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE, &
    & OC_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE,OC_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
    & OC_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,OC_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
    & OC_EQUATIONS_SET_1D3D_MONODOMAIN_ACTIVE_STRAIN_SUBTYPE, &
    & OC_EQUATIONS_SET_CONSTIT_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
    & OC_EQUATIONS_SET_CELLML_GROWTH_LAW_SUBTYPE, &
    & OC_EQUATIONS_SET_CELLML_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE, &
    & OC_EQUATIONS_SET_CELLML_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_FIBRE_GROWTH_LAW_ST_VENANT_SUBTYPE, &
    & OC_EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_ST_VENANT_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_ST_VENANT_SUBTYPE, &
    & OC_EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_ST_VENANT_SUBTYPE, &
    & OC_EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_ST_VENANT_SUBTYPE, &
    & OC_EQUATIONS_SET_FIBRE_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE, &
    & OC_EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE, &
    & OC_EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE, &
    & OC_EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_NEO_HOOKEAN_SUBTYPE, &
    & OC_EQUATIONS_SET_FIBRE_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_ISOTROPIC_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_TRANS_ISO_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_ORTHOTROPIC_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_FULL_TENSOR_GROWTH_LAW_MOONEY_RIVLIN_SUBTYPE, &
    & OC_EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
    & OC_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE, &
    & OC_EQUATIONS_SET_RATE_BASED_SMOOTH_MODEL_SUBTYPE,OC_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_SMOOTH_MODEL_SUBTYPE, &
    & OC_EQUATIONS_SET_RATE_BASED_GROWTH_MODEL_SUBTYPE,OC_EQUATIONS_SET_COMPRESSIBLE_RATE_BASED_GROWTH_MODEL_SUBTYPE

  PUBLIC OC_EQUATIONS_SET_FITTING_NO_SMOOTHING,OC_EQUATIONS_SET_FITTING_SOBOLEV_VALUE_SMOOTHING, &
    & OC_EQUATIONS_SET_FITTING_SOBOLEV_DIFFERENCE_SMOOTHING,OC_EQUATIONS_SET_FITTING_STRAIN_ENERGY_SMOOTHING

  PUBLIC OC_EQUATIONS_SET_CELLML_SPLIT_GEN_REACT_DIFF_SUBTYPE,OC_EQUATIONS_SET_CELLML_NOSPLIT_LINEAR_GEN_REACT_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_CELLML_NOSPLIT_NONLIN_GEN_REACT_DIFF_SUBTYPE,OC_EQUATIONS_SET_GEN_FISHERS_SPLIT_REACT_DIFF_SUBTYPE, &
    & OC_EQUATIONS_SET_GEN_FISHERS_NOSPLIT_REACT_DIFF_SUBTYPE

  PUBLIC OC_EQUATIONS_SET_FEM_SOLUTION_METHOD,OC_EQUATIONS_SET_BEM_SOLUTION_METHOD,OC_EQUATIONS_SET_FD_SOLUTION_METHOD, &
    & OC_EQUATIONS_SET_FV_SOLUTION_METHOD,OC_EQUATIONS_SET_GFEM_SOLUTION_METHOD,OC_EQUATIONS_SET_GFD_SOLUTION_METHOD, &
    & OC_EQUATIONS_SET_GFV_SOLUTION_METHOD

  PUBLIC OC_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT,OC_EQUATIONS_SET_DERIVED_DEFORMATION_ELASTIC, &
    & OC_EQUATIONS_SET_DERIVED_DEFORMATION_GROWTH,OC_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT_SPATIAL, &
    & OC_EQUATIONS_SET_DERIVED_DEFORMATION_GRADIENT_FIBRE, &
    & OC_EQUATIONS_SET_DERIVED_RIGHT_STRETCH,OC_EQUATIONS_SET_DERIVED_LEFT_STRETCH,OC_EQUATIONS_SET_DERIVED_ROTATION, &
    & OC_EQUATIONS_SET_DERIVED_RIGHT_STRETCH_FIBRE,OC_EQUATIONS_SET_DERIVED_LEFT_STRETCH_FIBRE, &
    & OC_EQUATIONS_SET_DERIVED_ROTATION_FIBRE, &
    & OC_EQUATIONS_SET_DERIVED_R_CAUCHY_GREEN_DEFORMATION,OC_EQUATIONS_SET_DERIVED_L_CAUCHY_GREEN_DEFORMATION, &
    & OC_EQUATIONS_SET_DERIVED_GREEN_LAGRANGE_STRAIN,OC_EQUATIONS_SET_DERIVED_SMALL_STRAIN, &
    & OC_EQUATIONS_SET_DERIVED_CAUCHY_STRESS,OC_EQUATIONS_SET_DERIVED_CAUCHY_STRESS_FIBRE, &
    & OC_EQUATIONS_SET_DERIVED_FIRST_PK_STRESS,OC_EQUATIONS_SET_DERIVED_SECOND_PK_STRESS, &
    & OC_EQUATIONS_SET_DERIVED_ELASTIC_WORK

  PUBLIC OC_EQUATIONS_SET_NO_OUTPUT,OC_EQUATIONS_SET_PROGRESS_OUTPUT

  PUBLIC OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_TWO_DIM_1,OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_TWO_DIM_2, &
    & OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_THREE_DIM_1,OC_EQUATIONS_SET_STANDARD_LAPLACE_EQUATION_THREE_DIM_2
  PUBLIC OC_EQUATIONS_SET_GENERALISED_LAPLACE_EQUATION_TWO_DIM_1

  PUBLIC OC_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1

  PUBLIC OC_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1,OC_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1, &
    & OC_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2,OC_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1, &
    & OC_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2,OC_EQUATIONS_SET_LINEAR_ELASTICITY_CANTILEVER_END_LOAD

  PUBLIC OC_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1,OC_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1, &
    & OC_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1, &
    & OC_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1,OC_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1, &
    & OC_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1,OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM, &
    & OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM,OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM, &
    & OC_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM

  PUBLIC OC_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1

  PUBLIC OC_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_ONE_DIM_1

  PUBLIC OC_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1

  PUBLIC OC_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1,OC_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1, &
    & OC_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2, &
    & OC_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1

  PUBLIC OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_1,OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_TWO_DIM_2
  PUBLIC OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_1,OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_2, &
    & OC_EQUATIONS_SET_CONSTANT_POISSON_EQUATION_THREE_DIM_3
  PUBLIC OC_EQUATIONS_SET_QUADRATIC_POISSON_EQUATION_TWO_DIM_1
  PUBLIC OC_EQUATIONS_SET_EXPONENTIAL_POISSON_EQUATION_TWO_DIM_1
  PUBLIC OC_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1,OC_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2

  PUBLIC OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1,OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2, &
    & OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3
  PUBLIC OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4,OC_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5
  PUBLIC OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1,OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2, &
    & OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3
  PUBLIC OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4,OC_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5

  PUBLIC OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE, &
    & OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN
  PUBLIC OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA, &
    &    OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID, &
    &    OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE
  PUBLIC OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1,OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2, &
    & OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3
  PUBLIC OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4,OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5
  PUBLIC OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1,OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2, &
    & OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3
  PUBLIC OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4,OC_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5

  PUBLIC OC_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1,OC_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2, &
    & OC_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3
  PUBLIC OC_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1,OC_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2, &
    & OC_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3
  PUBLIC OC_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY

  PUBLIC OC_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER,OC_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER_GROWTH
  PUBLIC OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX,OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX
  PUBLIC OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX,OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX
  PUBLIC OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX,OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX
  PUBLIC OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX,OC_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX

  !==================================================================================================================================
  !
  ! EquationsSetRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of a analytic solution for an equations set. \see OpenCMISS::OC_EquationsSet_AnalyticCreateStart
  INTERFACE OC_EquationsSet_AnalyticCreateFinish
    MODULE PROCEDURE OC_EquationsSet_AnalyticCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticCreateFinishObj
  END INTERFACE OC_EquationsSet_AnalyticCreateFinish

  !>Start the creation of a analytic solution for an equations set. \see OpenCMISS::OC_EquationsSet_AnalyticCreateFinish
  INTERFACE OC_EquationsSet_AnalyticCreateStart
    MODULE PROCEDURE OC_EquationsSet_AnalyticCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticCreateStartObj
  END INTERFACE OC_EquationsSet_AnalyticCreateStart

  !>Destroy the analytic solution for an equations set.
  INTERFACE OC_EquationsSet_AnalyticDestroy
    MODULE PROCEDURE OC_EquationsSet_AnalyticDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticDestroyObj
  END INTERFACE OC_EquationsSet_AnalyticDestroy

  !>Evaluates the current analytic solution for an equations set.
  INTERFACE OC_EquationsSet_AnalyticEvaluate
    MODULE PROCEDURE OC_EquationsSet_AnalyticEvaluateNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticEvaluateObj
  END INTERFACE OC_EquationsSet_AnalyticEvaluate

  !>Returns the analytic time for an equations set.
  INTERFACE OC_EquationsSet_AnalyticTimeGet
    MODULE PROCEDURE OC_EquationsSet_AnalyticTimeGetNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticTimeGetObj
  END INTERFACE OC_EquationsSet_AnalyticTimeGet

  !>Sets/changes the analytic time for an equations set.
  INTERFACE OC_EquationsSet_AnalyticTimeSet
    MODULE PROCEDURE OC_EquationsSet_AnalyticTimeSetNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticTimeSetObj
  END INTERFACE OC_EquationsSet_AnalyticTimeSet

  !>Finish the creation of an equations set. \see OpenCMISS::OC_EquationsSet_CreateStart
  INTERFACE OC_EquationsSet_CreateFinish
    MODULE PROCEDURE OC_EquationsSet_CreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_CreateFinishObj
  END INTERFACE OC_EquationsSet_CreateFinish

  !>Start the creation of an equations set on a region. \see OpenCMISS::OC_EquationsSet_CreateFinish
  INTERFACE OC_EquationsSet_CreateStart
    MODULE PROCEDURE OC_EquationsSet_CreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_CreateStartObj
  END INTERFACE OC_EquationsSet_CreateStart

  !>Destroy an equations set.
  INTERFACE OC_EquationsSet_Destroy
    MODULE PROCEDURE OC_EquationsSet_DestroyNumber
    MODULE PROCEDURE OC_EquationsSet_DestroyObj
  END INTERFACE OC_EquationsSet_Destroy

  !>Finish the creation of dependent variables for an equations set. \see OpenCMISS::OC_EquationsSet_DependentCreateStart
  INTERFACE OC_EquationsSet_DependentCreateFinish
    MODULE PROCEDURE OC_EquationsSet_DependentCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_DependentCreateFinishObj
  END INTERFACE OC_EquationsSet_DependentCreateFinish

  !>Start the creation of dependent variables for an equations set. \see OpenCMISS::OC_EquationsSet_DependentCreateFinish
  INTERFACE OC_EquationsSet_DependentCreateStart
    MODULE PROCEDURE OC_EquationsSet_DependentCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_DependentCreateStartObj
  END INTERFACE OC_EquationsSet_DependentCreateStart

  !>Destroy the dependent variables for an equations set.
  INTERFACE OC_EquationsSet_DependentDestroy
    MODULE PROCEDURE OC_EquationsSet_DependentDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_DependentDestroyObj
  END INTERFACE OC_EquationsSet_DependentDestroy

  !>Finish the creation of derived variables for an equations set. \see OpenCMISS::OC_EquationsSet_DerivedCreateStart
  INTERFACE OC_EquationsSet_DerivedCreateFinish
    MODULE PROCEDURE OC_EquationsSet_DerivedCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_DerivedCreateFinishObj
  END INTERFACE OC_EquationsSet_DerivedCreateFinish

  !>Start the creation of derived variables for an equations set. These are used to store any intermediate
  !>calculated values, for example stress and strain fields in an elasticity problem. \see OpenCMISS::OC_EquationsSet_DerivedCreateFinish
  INTERFACE OC_EquationsSet_DerivedCreateStart
    MODULE PROCEDURE OC_EquationsSet_DerivedCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_DerivedCreateStartObj
  END INTERFACE OC_EquationsSet_DerivedCreateStart

  !>Destroy the derived variables for an equations set.
  INTERFACE OC_EquationsSet_DerivedDestroy
    MODULE PROCEDURE OC_EquationsSet_DerivedDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_DerivedDestroyObj
  END INTERFACE OC_EquationsSet_DerivedDestroy

  !>Finish the creation of equations for an equations set. \see OpenCMISS::OC_EquationsSet_EquationsCreateStart
  INTERFACE OC_EquationsSet_EquationsCreateFinish
    MODULE PROCEDURE OC_EquationsSet_EquationsCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_EquationsCreateFinishObj
  END INTERFACE OC_EquationsSet_EquationsCreateFinish

  !>Start the creation of equations for an equations set. \see OpenCMISS::OC_EquationsSet_EquationsCreateFinish
  INTERFACE OC_EquationsSet_EquationsCreateStart
    MODULE PROCEDURE OC_EquationsSet_EquationsCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_EquationsCreateStartObj
  END INTERFACE OC_EquationsSet_EquationsCreateStart

  !>Destroy the equations for an equations set.
  INTERFACE OC_EquationsSet_EquationsDestroy
    MODULE PROCEDURE OC_EquationsSet_EquationsDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_EquationsDestroyObj
  END INTERFACE OC_EquationsSet_EquationsDestroy

  !>Finish the creation of independent fields for an equations set. \see OpenCMISS::OC_EquationsSet_IndependentCreateStart
  INTERFACE OC_EquationsSet_IndependentCreateFinish
    MODULE PROCEDURE OC_EquationsSet_IndependentCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_IndependentCreateFinishObj
  END INTERFACE OC_EquationsSet_IndependentCreateFinish

  !>Start the creation of independent fields for an equations set. \see OpenCMISS::OC_EquationsSet_MaterialsCreateFinish
  INTERFACE OC_EquationsSet_IndependentCreateStart
    MODULE PROCEDURE OC_EquationsSet_IndependentCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_IndependentCreateStartObj
  END INTERFACE OC_EquationsSet_IndependentCreateStart

  !>Destroy the independent fields for an equations set.
  INTERFACE OC_EquationsSet_IndependentDestroy
    MODULE PROCEDURE OC_EquationsSet_IndependentDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_IndependentDestroyObj
  END INTERFACE OC_EquationsSet_IndependentDestroy

  !>Returns the label for an equations set.
  INTERFACE OC_EquationsSet_LabelGet
    MODULE PROCEDURE OC_EquationsSet_LabelGetCNumber
    MODULE PROCEDURE OC_EquationsSet_LabelGetCObj
    MODULE PROCEDURE OC_EquationsSet_LabelGetVSNumber
    MODULE PROCEDURE OC_EquationsSet_LabelGetVSObj
  END INTERFACE OC_EquationsSet_LabelGet

  !>Sets/changes the label for an equations set.
  INTERFACE OC_EquationsSet_LabelSet
    MODULE PROCEDURE OC_EquationsSet_LabelSetCNumber
    MODULE PROCEDURE OC_EquationsSet_LabelSetCObj
    MODULE PROCEDURE OC_EquationsSet_LabelSetVSNumber
    MODULE PROCEDURE OC_EquationsSet_LabelSetVSObj
  END INTERFACE OC_EquationsSet_LabelSet

  !>Finish the creation of materials for an equations set. \see OpenCMISS::OC_EquationsSet_MaterialsCreateStart
  INTERFACE OC_EquationsSet_MaterialsCreateFinish
    MODULE PROCEDURE OC_EquationsSet_MaterialsCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_MaterialsCreateFinishObj
  END INTERFACE OC_EquationsSet_MaterialsCreateFinish

  !>Start the creation of materials for an equations set. \see OpenCMISS::OC_EquationsSet_MaterialsCreateFinish
  INTERFACE OC_EquationsSet_MaterialsCreateStart
    MODULE PROCEDURE OC_EquationsSet_MaterialsCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_MaterialsCreateStartObj
  END INTERFACE OC_EquationsSet_MaterialsCreateStart

  !>Destroy the materials for an equations set.
  INTERFACE OC_EquationsSet_MaterialsDestroy
    MODULE PROCEDURE OC_EquationsSet_MaterialsDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_MaterialsDestroyObj
  END INTERFACE OC_EquationsSet_MaterialsDestroy

  !>Gets the output type for an equations set.
  INTERFACE OC_EquationsSet_OutputTypeGet
    MODULE PROCEDURE OC_EquationsSet_OutputTypeGetNumber
    MODULE PROCEDURE OC_EquationsSet_OutputTypeGetObj
  END INTERFACE OC_EquationsSet_OutputTypeGet

  !>Sets/changes the output type an equations set.
  INTERFACE OC_EquationsSet_OutputTypeSet
    MODULE PROCEDURE OC_EquationsSet_OutputTypeSetNumber
    MODULE PROCEDURE OC_EquationsSet_OutputTypeSetObj
  END INTERFACE OC_EquationsSet_OutputTypeSet

  !>Returns the solution method for an equations set.
  INTERFACE OC_EquationsSet_SolutionMethodGet
    MODULE PROCEDURE OC_EquationsSet_SolutionMethodGetNumber
    MODULE PROCEDURE OC_EquationsSet_SolutionMethodGetObj
  END INTERFACE OC_EquationsSet_SolutionMethodGet

  !>Sets/changes the solution method for an equations set.
  INTERFACE OC_EquationsSet_SolutionMethodSet
    MODULE PROCEDURE OC_EquationsSet_SolutionMethodSetNumber
    MODULE PROCEDURE OC_EquationsSet_SolutionMethodSetObj
  END INTERFACE OC_EquationsSet_SolutionMethodSet

  !>Finish the creation of a source for an equations set. \see OpenCMISS::OC_EquationsSet_SourceCreateStart
  INTERFACE OC_EquationsSet_SourceCreateFinish
    MODULE PROCEDURE OC_EquationsSet_SourceCreateFinishNumber
    MODULE PROCEDURE OC_EquationsSet_SourceCreateFinishObj
  END INTERFACE OC_EquationsSet_SourceCreateFinish

  !>Start the creation of a source for an equations set. \see OpenCMISS::OC_EquationsSet_SourceCreateFinish
  INTERFACE OC_EquationsSet_SourceCreateStart
    MODULE PROCEDURE OC_EquationsSet_SourceCreateStartNumber
    MODULE PROCEDURE OC_EquationsSet_SourceCreateStartObj
  END INTERFACE OC_EquationsSet_SourceCreateStart

  !>Destroy the source for an equations set.
  INTERFACE OC_EquationsSet_SourceDestroy
    MODULE PROCEDURE OC_EquationsSet_SourceDestroyNumber
    MODULE PROCEDURE OC_EquationsSet_SourceDestroyObj
  END INTERFACE OC_EquationsSet_SourceDestroy

  !>Returns the equations set specification array
  INTERFACE OC_EquationsSet_SpecificationGet
    MODULE PROCEDURE OC_EquationsSet_SpecificationGetNumber
    MODULE PROCEDURE OC_EquationsSet_SpecificationGetObj
  END INTERFACE OC_EquationsSet_SpecificationGet

  !>Returns the size of the equations set specification array.
  INTERFACE OC_EquationsSet_SpecificationSizeGet
    MODULE PROCEDURE OC_EquationsSet_SpecificationSizeGetNumber
    MODULE PROCEDURE OC_EquationsSet_SpecificationSizeGetObj
  END INTERFACE OC_EquationsSet_SpecificationSizeGet

  !>Calculates an output field for the equations set.
  INTERFACE OC_EquationsSet_DerivedVariableCalculate
    MODULE PROCEDURE OC_EquationsSet_DerivedVariableCalculateNumber
    MODULE PROCEDURE OC_EquationsSet_DerivedVariableCalculateObj
  END INTERFACE OC_EquationsSet_DerivedVariableCalculate

  !>Set the derived field variable type to be used by a derived variable
  INTERFACE OC_EquationsSet_DerivedVariableSet
    MODULE PROCEDURE OC_EquationsSet_DerivedVariableSetNumber
    MODULE PROCEDURE OC_EquationsSet_DerivedVariableSetObj
  END INTERFACE OC_EquationsSet_DerivedVariableSet

  !>Evaluate a tensor at a given element Gauss location.
  INTERFACE OC_EquationsSet_TensorInterpolateGaussPoint
    MODULE PROCEDURE OC_EquationsSet_TensorInterpolateGaussPointNumber
    MODULE PROCEDURE OC_EquationsSet_TensorInterpolateGaussPointObj
  END INTERFACE OC_EquationsSet_TensorInterpolateGaussPoint

  !>Evaluate a tensor at a given element xi location.
  INTERFACE OC_EquationsSet_TensorInterpolateXi
    MODULE PROCEDURE OC_EquationsSet_TensorInterpolateXiNumber
    MODULE PROCEDURE OC_EquationsSet_TensorInterpolateXiObj
  END INTERFACE OC_EquationsSet_TensorInterpolateXi

  !>Returns the equations set current times
  INTERFACE OC_EquationsSet_TimesGet
    MODULE PROCEDURE OC_EquationsSet_TimesGetNumber
    MODULE PROCEDURE OC_EquationsSet_TimesGetObj
  END INTERFACE OC_EquationsSet_TimesGet

  !>Sets/changes the equations set current times
  INTERFACE OC_EquationsSet_TimesSet
    MODULE PROCEDURE OC_EquationsSet_TimesSetNumber
    MODULE PROCEDURE OC_EquationsSet_TimesSetObj
  END INTERFACE OC_EquationsSet_TimesSet

  !>Gets the equations set analytic user parameter
  INTERFACE OC_EquationsSet_AnalyticUserParamGet
    MODULE PROCEDURE OC_EquationsSet_AnalyticUserParamGetNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticUserParamGetObj
  END INTERFACE OC_EquationsSet_AnalyticUserParamGet

  !>Sets/changes the equations set analytic user parameter
  INTERFACE OC_EquationsSet_AnalyticUserParamSet
    MODULE PROCEDURE OC_EquationsSet_AnalyticUserParamSetNumber
    MODULE PROCEDURE OC_EquationsSet_AnalyticUserParamSetObj
  END INTERFACE OC_EquationsSet_AnalyticUserParamSet

  PUBLIC OC_EquationsSet_AnalyticCreateFinish,OC_EquationsSet_AnalyticCreateStart

  PUBLIC OC_EquationsSet_AnalyticDestroy

  PUBLIC OC_EquationsSet_AnalyticEvaluate

  PUBLIC OC_EquationsSet_AnalyticTimeGet,OC_EquationsSet_AnalyticTimeSet

  PUBLIC OC_EquationsSet_CreateFinish,OC_EquationsSet_CreateStart

  PUBLIC OC_EquationsSet_Destroy

  PUBLIC OC_EquationsSet_DependentCreateFinish,OC_EquationsSet_DependentCreateStart

  PUBLIC OC_EquationsSet_DependentDestroy

  PUBLIC OC_EquationsSet_DerivedCreateFinish,OC_EquationsSet_DerivedCreateStart

  PUBLIC OC_EquationsSet_DerivedDestroy

  PUBLIC OC_EquationsSet_DerivedVariableCalculate,OC_EquationsSet_DerivedVariableSet

  PUBLIC OC_EquationsSet_EquationsCreateFinish,OC_EquationsSet_EquationsCreateStart

  PUBLIC OC_EquationsSet_EquationsDestroy

  PUBLIC OC_EquationsSet_IndependentCreateFinish,OC_EquationsSet_IndependentCreateStart

  PUBLIC OC_EquationsSet_IndependentDestroy

  PUBLIC OC_EquationsSet_LabelGet,OC_EquationsSet_LabelSet

  PUBLIC OC_EquationsSet_MaterialsCreateFinish,OC_EquationsSet_MaterialsCreateStart

  PUBLIC OC_EquationsSet_MaterialsDestroy

  PUBLIC OC_Equationsset_OutputTypeGet,OC_EquationsSet_OutputTypeSet

  PUBLIC OC_EquationsSet_SolutionMethodGet,OC_EquationsSet_SolutionMethodSet

  PUBLIC OC_EquationsSet_SourceCreateFinish,OC_EquationsSet_SourceCreateStart

  PUBLIC OC_EquationsSet_SourceDestroy

  PUBLIC OC_EquationsSet_SpecificationGet,OC_EquationsSet_SpecificationSizeGet

  PUBLIC OC_EquationsSet_TensorInterpolateGaussPoint

  PUBLIC OC_EquationsSet_TensorInterpolateXi

  PUBLIC OC_EquationsSet_TimesGet,OC_EquationsSet_TimesSet

  PUBLIC OC_EquationsSet_AnalyticUserParamSet,OC_EquationsSet_AnalyticUserParamGet

  !==================================================================================================================================
  !
  ! ExportRoutines
  !
  !==================================================================================================================================

  !Module parameters
  
  !> \addtogroup OpenCMISS_ExportConstants OpenCMISS::Export::Constants
  !> \brief Export constants.
  !>@{
  !> \addtogroup OpenCMISS_ExportFormatTypes OpenCMISS::Export::Constants::FormatTypes
  !> \brief Export file format types.
  !> \see OpenCMISS::Export,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_EXPORT_EXFILE_FORMAT = EXPORT_EXFILE_FORMAT !<Exfile (cmgui) format type \see OpenCMISS_ExportFormatTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_EXPORT_VTK_FORMAT = EXPORT_VTK_FORMAT !<VTK format type \see OpenCMISS_ExportFormatTypes,OpenCMISS
  !>@}
  !>@}

  !Interfaces

  !>Gets the base filename for an export
  INTERFACE OC_Export_BaseFilenameGet
    MODULE PROCEDURE OC_Export_BaseFilenameGetNumberVS
    MODULE PROCEDURE OC_Export_BaseFilenameGetNumberC
    MODULE PROCEDURE OC_Export_BaseFilenameGetObjVS
    MODULE PROCEDURE OC_Export_BaseFilenameGetObjC
  END INTERFACE OC_Export_BaseFilenameGet

  !>Sets the base filename for an export
  INTERFACE OC_Export_BaseFilenameSet
    MODULE PROCEDURE OC_Export_BaseFilenameSetNumberVS
    MODULE PROCEDURE OC_Export_BaseFilenameSetNumberC
    MODULE PROCEDURE OC_Export_BaseFilenameSetObjVS
    MODULE PROCEDURE OC_Export_BaseFilenameSetObjC
  END INTERFACE OC_Export_BaseFilenameSet

  !>Finishes the creation of an export \see OpenCMISS::OC_Export_CreateStart
  INTERFACE OC_Export_CreateFinish
    MODULE PROCEDURE OC_Export_CreateFinishNumber
    MODULE PROCEDURE OC_Export_CreateFinishObj
  END INTERFACE OC_Export_CreateFinish

  !>Starts the creation of an export. \see OpenCMISS::OC_Export_CreateFinish
  INTERFACE OC_Export_CreateStart
    MODULE PROCEDURE OC_Export_CreateStartNumber
    MODULE PROCEDURE OC_Export_CreateStartObj
  END INTERFACE OC_Export_CreateStart

  !>Destroys an export.
  INTERFACE OC_Export_Destroy
    MODULE PROCEDURE OC_Export_DestroyNumber
    MODULE PROCEDURE OC_Export_DestroyObj
  END INTERFACE OC_Export_Destroy

  !>Export files an export.
  INTERFACE OC_Export_Export
    MODULE PROCEDURE OC_Export_ExportNumber
    MODULE PROCEDURE OC_Export_ExportObj
  END INTERFACE OC_Export_Export

  !>Sets the file format for an export.
  INTERFACE OC_Export_ExportFormatSet
    MODULE PROCEDURE OC_Export_ExportFormatSetNumber
    MODULE PROCEDURE OC_Export_ExportFormatSetObj
  END INTERFACE OC_Export_ExportFormatSet

  !>Adds an export variable to an export.
  INTERFACE OC_Export_ExportVariableAdd
    MODULE PROCEDURE OC_Export_ExportVariableAddNumberVS
    MODULE PROCEDURE OC_Export_ExportVariableAddNumberC
    MODULE PROCEDURE OC_Export_ExportVariableAddObjVS
    MODULE PROCEDURE OC_Export_ExportVariableAddObjC
  END INTERFACE OC_Export_ExportVariableAdd

  PUBLIC OC_EXPORT_EXFILE_FORMAT,OC_EXPORT_VTK_FORMAT

  PUBLIC OC_Export_BaseFilenameGet,OC_Export_BaseFilenameSet

  PUBLIC OC_Export_CreateFinish
  
  PUBLIC OC_Export_CreateStart

  PUBLIC OC_Export_Destroy

  PUBLIC OC_Export_Export
  
  PUBLIC OC_Export_ExportFormatSet

  PUBLIC OC_Export_ExportVariableAdd 

  !==================================================================================================================================
  !
  ! FieldRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_FieldConstants OpenCMISS::Field::Constants
  !> \brief Field constants.
  !>@{
  !> \addtogroup OpenCMISS_FieldDependentTypes OpenCMISS::Field::DependentTypes
  !> \brief Depedent field parameter types.
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_INDEPENDENT_TYPE = FIELD_INDEPENDENT_TYPE !<Independent field type \see OpenCMISS_FieldDependentTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEPENDENT_TYPE = FIELD_DEPENDENT_TYPE !<Dependent field type \see OpenCMISS_FieldDependentTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldDimensionTypes OpenCMISS::Field::DimensionTypes
  !> \brief Field dimension parameter types.
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_SCALAR_DIMENSION_TYPE = FIELD_SCALAR_DIMENSION_TYPE !<Scalar field \see OpenCMISS_FieldDimensionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_VECTOR_DIMENSION_TYPE = FIELD_VECTOR_DIMENSION_TYPE !<Vector field \see OpenCMISS_FieldDimensionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_TENSOR_DIMENSION_TYPE = FIELD_TENSOR_DIMENSION_TYPE !<Tensor field \see OpenCMISS_FieldDimensionTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldTypes OpenCMISS::Field::Types
  !> \brief Field type parameters.
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_GEOMETRIC_TYPE = FIELD_GEOMETRIC_TYPE !<Geometric field \see OpenCMISS_FieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_FIBRE_TYPE = FIELD_FIBRE_TYPE !<Fibre field \see OpenCMISS_FieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_GENERAL_TYPE = FIELD_GENERAL_TYPE !<General field \see OpenCMISS_FieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_MATERIAL_TYPE = FIELD_MATERIAL_TYPE !<Material field \see OpenCMISS_FieldTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_GEOMETRIC_GENERAL_TYPE = FIELD_GEOMETRIC_GENERAL_TYPE !<Geometric general field \see OpenCMISS_FieldTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldInterpolationTypes OpenCMISS::Field::InterpolationTypes
  !> \brief Field interpolation parameters.
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_CONSTANT_INTERPOLATION = FIELD_CONSTANT_INTERPOLATION !<Constant interpolation. One parameter for the field \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ELEMENT_BASED_INTERPOLATION = FIELD_ELEMENT_BASED_INTERPOLATION !<Element based interpolation. Parameters are different in each element \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_NODE_BASED_INTERPOLATION = FIELD_NODE_BASED_INTERPOLATION !<Node based interpolation. Parameters are nodal based and a basis function is used \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_GRID_POINT_BASED_INTERPOLATION = FIELD_GRID_POINT_BASED_INTERPOLATION !<Grid point based interpolation. Parameters are different at each grid point \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_GAUSS_POINT_BASED_INTERPOLATION = FIELD_GAUSS_POINT_BASED_INTERPOLATION !<Gauss point based interpolation. Parameters are different at each Gauss point \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DATA_POINT_BASED_INTERPOLATION = FIELD_DATA_POINT_BASED_INTERPOLATION !<Data point based interpolation. Parameters are different at each data point \see OpenCMISS_FieldInterpolationTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldVariableTypes OpenCMISS::Field::VariableTypes
  !> \brief Field variable type parameters.
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_NUMBER_OF_VARIABLE_SUBTYPES = FIELD_NUMBER_OF_VARIABLE_SUBTYPES !<The number of subtypes of a variable - i.e., u, du/dn, du/dt, d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U_VARIABLE_TYPE = FIELD_U_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELUDELN_VARIABLE_TYPE = FIELD_DELUDELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_T_VARIABLE_TYPE = FIELD_T_VARIABLE_TYPE !<Traction variable type i.e., t \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELUDELT_VARIABLE_TYPE = FIELD_DELUDELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2UDELT2_VARIABLE_TYPE = FIELD_DEL2UDELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_V_VARIABLE_TYPE = FIELD_V_VARIABLE_TYPE !<Second standard variable type i.e., v \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELVDELN_VARIABLE_TYPE = FIELD_DELVDELN_VARIABLE_TYPE !<Second normal derivative variable type i.e., dv/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELVDELT_VARIABLE_TYPE = FIELD_DELVDELT_VARIABLE_TYPE !<Second first time derivative variable type i.e., dv/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2VDELT2_VARIABLE_TYPE = FIELD_DEL2VDELT2_VARIABLE_TYPE !<Second second time derivative variable type i.e., d^2v/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_W_VARIABLE_TYPE = FIELD_W_VARIABLE_TYPE !<Third standard variable type i.e., w \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U1_VARIABLE_TYPE = FIELD_U1_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU1DELN_VARIABLE_TYPE = FIELD_DELU1DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU1DELT_VARIABLE_TYPE = FIELD_DELU1DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U1DELT2_VARIABLE_TYPE = FIELD_DEL2U1DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U2_VARIABLE_TYPE = FIELD_U2_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU2DELN_VARIABLE_TYPE = FIELD_DELU2DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU2DELT_VARIABLE_TYPE = FIELD_DELU2DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U2DELT2_VARIABLE_TYPE = FIELD_DEL2U2DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U3_VARIABLE_TYPE = FIELD_U3_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU3DELN_VARIABLE_TYPE = FIELD_DELU3DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU3DELT_VARIABLE_TYPE = FIELD_DELU3DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U3DELT2_VARIABLE_TYPE = FIELD_DEL2U3DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U4_VARIABLE_TYPE = FIELD_U4_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU4DELN_VARIABLE_TYPE = FIELD_DELU4DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU4DELT_VARIABLE_TYPE = FIELD_DELU4DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U4DELT2_VARIABLE_TYPE = FIELD_DEL2U4DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U5_VARIABLE_TYPE = FIELD_U5_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU5DELN_VARIABLE_TYPE = FIELD_DELU5DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU5DELT_VARIABLE_TYPE = FIELD_DELU5DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U5DELT2_VARIABLE_TYPE = FIELD_DEL2U5DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U6_VARIABLE_TYPE = FIELD_U6_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU6DELN_VARIABLE_TYPE = FIELD_DELU6DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU6DELT_VARIABLE_TYPE = FIELD_DELU6DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U6DELT2_VARIABLE_TYPE = FIELD_DEL2U6DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U7_VARIABLE_TYPE = FIELD_U7_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU7DELN_VARIABLE_TYPE = FIELD_DELU7DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU7DELT_VARIABLE_TYPE = FIELD_DELU7DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U7DELT2_VARIABLE_TYPE = FIELD_DEL2U7DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U8_VARIABLE_TYPE = FIELD_U8_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU8DELN_VARIABLE_TYPE = FIELD_DELU8DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU8DELT_VARIABLE_TYPE = FIELD_DELU8DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U8DELT2_VARIABLE_TYPE = FIELD_DEL2U8DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U9_VARIABLE_TYPE = FIELD_U9_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU9DELN_VARIABLE_TYPE = FIELD_DELU9DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU9DELT_VARIABLE_TYPE = FIELD_DELU9DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U9DELT2_VARIABLE_TYPE = FIELD_DEL2U9DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_U10_VARIABLE_TYPE = FIELD_U10_VARIABLE_TYPE !<Standard variable type i.e., u \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU10DELN_VARIABLE_TYPE = FIELD_DELU10DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DELU10DELT_VARIABLE_TYPE = FIELD_DELU10DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OpenCMISS_FieldVariableTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DEL2U10DELT2_VARIABLE_TYPE = FIELD_DEL2U10DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OpenCMISS_FieldVariableTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldDataTypes OpenCMISS::Field::DataTypes
  !> \brief Field data types
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_INTG_TYPE = FIELD_INTG_TYPE !<Integer field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_SP_TYPE = FIELD_SP_TYPE !<Single precision real field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_DP_TYPE = FIELD_DP_TYPE !<Double precision real field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_L_TYPE = FIELD_L_TYPE !<Logical field data type \see OpenCMISS_FieldDataTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldDOFOrderTypes OpenCMISS::Field::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_SEPARATED_COMPONENT_DOF_ORDER = FIELD_SEPARATED_COMPONENT_DOF_ORDER !<Field variable component dofs are not contiguous \see OpenCMISS_FieldDOFOrderTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER = FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER !<Field variable component dofs are contiguous \see OpenCMISS_FieldDOFOrderTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldParameterSetTypes OpenCMISS::Field::ParameterSetTypes
  !> \brief Field parameter set type parameters
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_VALUES_SET_TYPE = FIELD_VALUES_SET_TYPE !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_BOUNDARY_CONDITIONS_SET_TYPE = FIELD_BOUNDARY_CONDITIONS_SET_TYPE !<The parameter set corresponding to the field boundary condition values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_INITIAL_VALUES_SET_TYPE = FIELD_INITIAL_VALUES_SET_TYPE !<The parameter set corresponding to the field initial values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_INCREMENTAL_VALUES_SET_TYPE = FIELD_INCREMENTAL_VALUES_SET_TYPE !<The parameter set corresponding to the field incremental values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ANALYTIC_VALUES_SET_TYPE = FIELD_ANALYTIC_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_PREVIOUS_VALUES_SET_TYPE = FIELD_PREVIOUS_VALUES_SET_TYPE !<The parameter set corresponding to the previous field values (at time T) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE = FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mean predicited avalues (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_VELOCITY_VALUES_SET_TYPE = FIELD_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the velocity values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_INITIAL_VELOCITY_SET_TYPE = FIELD_INITIAL_VELOCITY_SET_TYPE !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_PREVIOUS_VELOCITY_SET_TYPE = FIELD_PREVIOUS_VELOCITY_SET_TYPE !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE = FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ANALYTIC_VELOCITY_VALUES_SET_TYPE = FIELD_ANALYTIC_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field velocity values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ACCELERATION_VALUES_SET_TYPE = FIELD_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the acceleration values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_INITIAL_ACCELERATION_SET_TYPE = FIELD_INITIAL_ACCELERATION_SET_TYPE !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_PREVIOUS_ACCELERATION_SET_TYPE = FIELD_PREVIOUS_ACCELERATION_SET_TYPE !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE = FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE !<The parameter set corresponding to the mean predicited acceleration values (at time T+DT) \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ANALYTIC_ACCELERATION_VALUES_SET_TYPE = FIELD_ANALYTIC_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field velocity values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_PRESSURE_VALUES_SET_TYPE = FIELD_PRESSURE_VALUES_SET_TYPE !<The parameter set corresponding to the surface pressure values. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_PREVIOUS_PRESSURE_SET_TYPE = FIELD_PREVIOUS_PRESSURE_SET_TYPE !<The parameter set corresponding to the previous surface pressure values (at time T). \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE = FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE !<The parameter set corresponding to the impermeable flag values. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_INTEGRATED_NEUMANN_SET_TYPE = FIELD_INTEGRATED_NEUMANN_SET_TYPE !<Stores integrated Neumann values calculated from Neumann point values. \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_MESH_DISPLACEMENT_SET_TYPE=FIELD_MESH_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mesh displacement values for ALE \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_MESH_VELOCITY_SET_TYPE=FIELD_MESH_VELOCITY_SET_TYPE !<The parameter set corresponding to the mesh velocity values for ALE \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_CELLML_VALUES_SET_TYPE=FIELD_CELLML_VALUES_SET_TYPE !<The parameter set corresponding to CellML values \see OpenCMISS_FieldParameterSetTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_FieldScalingTypes OpenCMISS::Field::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see OpenCMISS::Field,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_FIELD_NO_SCALING = FIELD_NO_SCALING !<The field is not scaled \see OpenCMISS_FieldScalingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_UNIT_SCALING = FIELD_UNIT_SCALING !<The field has unit scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ARC_LENGTH_SCALING = FIELD_ARC_LENGTH_SCALING !<The field has arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_ARITHMETIC_MEAN_SCALING = FIELD_ARITHMETIC_MEAN_SCALING !<The field has arithmetic mean of the arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_GEOMETRIC_MEAN_SCALING = FIELD_GEOMETRIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_FIELD_HARMONIC_MEAN_SCALING = FIELD_HARMONIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OpenCMISS_FieldScalingTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the interpolation type for a field variable component.
  INTERFACE OC_Field_ComponentInterpolationGet
    MODULE PROCEDURE OC_Field_ComponentInterpolationGetNumber
    MODULE PROCEDURE OC_Field_ComponentInterpolationGetObj
  END INTERFACE OC_Field_ComponentInterpolationGet

  !>Sets/changes the interpolation type for a field variable component.
  INTERFACE OC_Field_ComponentInterpolationSet
    MODULE PROCEDURE OC_Field_ComponentInterpolationSetNumber
    MODULE PROCEDURE OC_Field_ComponentInterpolationSetObj
  END INTERFACE OC_Field_ComponentInterpolationSet

  !>Returns the label for a field variable component.
  INTERFACE OC_Field_ComponentLabelGet
    MODULE PROCEDURE OC_Field_ComponentLabelGetCNumber
    MODULE PROCEDURE OC_Field_ComponentLabelGetCObj
    MODULE PROCEDURE OC_Field_ComponentLabelGetVSNumber
    MODULE PROCEDURE OC_Field_ComponentLabelGetVSObj
  END INTERFACE OC_Field_ComponentLabelGet

  !>Sets/changes the label for a field variable component.
  INTERFACE OC_Field_ComponentLabelSet
    MODULE PROCEDURE OC_Field_ComponentLabelSetCNumber
    MODULE PROCEDURE OC_Field_ComponentLabelSetCObj
    MODULE PROCEDURE OC_Field_ComponentLabelSetVSNumber
    MODULE PROCEDURE OC_Field_ComponentLabelSetVSObj
  END INTERFACE OC_Field_ComponentLabelSet

  !>Returns the mesh component number for a field variable component.
  INTERFACE OC_Field_ComponentMeshComponentGet
    MODULE PROCEDURE OC_Field_ComponentMeshComponentGetNumber
    MODULE PROCEDURE OC_Field_ComponentMeshComponentGetObj
  END INTERFACE OC_Field_ComponentMeshComponentGet

  !>Sets/changes the mesh component number for a field variable component.
  INTERFACE OC_Field_ComponentMeshComponentSet
    MODULE PROCEDURE OC_Field_ComponentMeshComponentSetNumber
    MODULE PROCEDURE OC_Field_ComponentMeshComponentSetObj
  END INTERFACE OC_Field_ComponentMeshComponentSet

  !>Initialises the values of a parameter set of a field variable component to a constant value.
  INTERFACE OC_Field_ComponentValuesInitialise
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseIntgNumber
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseIntgObj
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseSPNumber
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseSPObj
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseDPNumber
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseDPObj
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseLNumber
    MODULE PROCEDURE OC_Field_ComponentValuesInitialiseLObj
  END INTERFACE OC_Field_ComponentValuesInitialise

  !>Returns the data type for a field variable.
  INTERFACE OC_Field_DataTypeGet
    MODULE PROCEDURE OC_Field_DataTypeGetNumber
    MODULE PROCEDURE OC_Field_DataTypeGetObj
  END INTERFACE OC_Field_DataTypeGet

  !>Sets/changes the data type for a field variable.
  INTERFACE OC_Field_DataTypeSet
    MODULE PROCEDURE OC_Field_DataTypeSetNumber
    MODULE PROCEDURE OC_Field_DataTypeSetObj
  END INTERFACE OC_Field_DataTypeSet

  !>Returns the DOF order type for a field variable.
  INTERFACE OC_Field_DOFOrderTypeGet
    MODULE PROCEDURE OC_Field_DOFOrderTypeGetNumber
    MODULE PROCEDURE OC_Field_DOFOrderTypeGetObj
  END INTERFACE OC_Field_DOFOrderTypeGet

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous coponent DOF ordering all the components of the field variable must have the same interpolation type.
  INTERFACE OC_Field_DOFOrderTypeSet
    MODULE PROCEDURE OC_Field_DOFOrderTypeSetNumber
    MODULE PROCEDURE OC_Field_DOFOrderTypeSetObj
  END INTERFACE OC_Field_DOFOrderTypeSet

  !>Finishes the creation of a field. \see OpenCMISS::OC_Field_CreateStart
  INTERFACE OC_Field_CreateFinish
    MODULE PROCEDURE OC_Field_CreateFinishNumber
    MODULE PROCEDURE OC_Field_CreateFinishObj
  END INTERFACE OC_Field_CreateFinish

  !>Starts the creation of a field. \see OpenCMISS::OC_Field_CreateFinish
  INTERFACE OC_Field_CreateStart
    MODULE PROCEDURE OC_Field_CreateStartNumber
    MODULE PROCEDURE OC_Field_CreateStartInterfaceObj
    MODULE PROCEDURE OC_Field_CreateStartRegionObj
  END INTERFACE OC_Field_CreateStart

  !>Returns the dependent type for a field.
  INTERFACE OC_Field_DependentTypeGet
    MODULE PROCEDURE OC_Field_DependentTypeGetNumber
    MODULE PROCEDURE OC_Field_DependentTypeGetObj
  END INTERFACE OC_Field_DependentTypeGet

  !>Sets/changes the dependent type for a field.
  INTERFACE OC_Field_DependentTypeSet
    MODULE PROCEDURE OC_Field_DependentTypeSetNumber
    MODULE PROCEDURE OC_Field_DependentTypeSetObj
  END INTERFACE OC_Field_DependentTypeSet

  !>Destroys a field.
  INTERFACE OC_Field_Destroy
    MODULE PROCEDURE OC_Field_DestroyNumber
    MODULE PROCEDURE OC_Field_DestroyObj
  END INTERFACE OC_Field_Destroy

  !>Returns the field dimension for a field variable.
  INTERFACE OC_Field_DimensionGet
    MODULE PROCEDURE OC_Field_DimensionGetNumber
    MODULE PROCEDURE OC_Field_DimensionGetObj
  END INTERFACE OC_Field_DimensionGet

  !>Sets/changes the field dimension for a field variable.
  INTERFACE OC_Field_DimensionSet
    MODULE PROCEDURE OC_Field_DimensionSetNumber
    MODULE PROCEDURE OC_Field_DimensionSetObj
  END INTERFACE OC_Field_DimensionSet

  !>Returns the geometric field for a field.
  INTERFACE OC_Field_GeometricFieldGet
    MODULE PROCEDURE OC_Field_GeometricFieldGetNumber
    MODULE PROCEDURE OC_Field_GeometricFieldGetObj
  END INTERFACE OC_Field_GeometricFieldGet

  !>Sets/changes the geometric field for a field.
  INTERFACE OC_Field_GeometricFieldSet
    MODULE PROCEDURE OC_Field_GeometricFieldSetNumber
    MODULE PROCEDURE OC_Field_GeometricFieldSetObj
  END INTERFACE OC_Field_GeometricFieldSet

  !>Gets line lengths from a geometric field given an user element number and line xi normal directions.
  INTERFACE OC_Field_GeometricParametersElementLineLengthGet
    MODULE PROCEDURE OC_Field_GeometricParametersElementLineLengthGetNumber0
    MODULE PROCEDURE OC_Field_GeometricParametersElementLineLengthGetNumber1
    MODULE PROCEDURE OC_Field_GeometricParametersElementLineLengthGetObj0
    MODULE PROCEDURE OC_Field_GeometricParametersElementLineLengthGetObj1
  END INTERFACE OC_Field_GeometricParametersElementLineLengthGet

  !>Gets volumes from a geometric field given an user element number.
  INTERFACE OC_Field_GeometricParametersElementVolumeGet
    MODULE PROCEDURE OC_Field_GeometricParametersElementVolumeGetNumber
    MODULE PROCEDURE OC_Field_GeometricParametersElementVolumeGetObj
  END INTERFACE OC_Field_GeometricParametersElementVolumeGet

  !>Returns the label for a field.
  INTERFACE OC_Field_LabelGet
    MODULE PROCEDURE OC_Field_LabelGetCNumber
    MODULE PROCEDURE OC_Field_LabelGetCObj
    MODULE PROCEDURE OC_Field_LabelGetVSNumber
    MODULE PROCEDURE OC_Field_LabelGetVSObj
  END INTERFACE OC_Field_LabelGet

  !>Sets/changes the label for a field.
  INTERFACE OC_Field_LabelSet
    MODULE PROCEDURE OC_Field_LabelSetCNumber
    MODULE PROCEDURE OC_Field_LabelSetCObj
    MODULE PROCEDURE OC_Field_LabelSetVSNumber
    MODULE PROCEDURE OC_Field_LabelSetVSObj
  END INTERFACE OC_Field_LabelSet

  INTERFACE OC_Field_PositionNormalTangentCalculateNode
    MODULE PROCEDURE OC_Field_PositionNormalTangentCalculateNodeNumber
    MODULE PROCEDURE OC_Field_PositionNormalTangentCalculateNodeObj
  END INTERFACE OC_Field_PositionNormalTangentCalculateNode

  !>Returns the mesh decomposition for a field.
  INTERFACE OC_Field_DecompositionGet
    MODULE PROCEDURE OC_Field_DecompositionGetNumber
    MODULE PROCEDURE OC_Field_DecompositionGetObj
  END INTERFACE OC_Field_DecompositionGet

  !>Sets/changes the mesh decomposition for a field. \todo remove when fields take decomposition argument on creation???
  INTERFACE OC_Field_DecompositionSet
    MODULE PROCEDURE OC_Field_DecompositionSetNumber
    MODULE PROCEDURE OC_Field_DecompositionSetObj
  END INTERFACE OC_Field_DecompositionSet

  !>Sets/changes the data projection for a field.
  INTERFACE OC_Field_DataProjectionSet
    MODULE PROCEDURE OC_Field_DataProjectionSetNumber
    MODULE PROCEDURE OC_Field_DataProjectionSetObj
  END INTERFACE OC_Field_DataProjectionSet

  !>Returns the number of field components for a field variable.
  INTERFACE OC_Field_NumberOfComponentsGet
    MODULE PROCEDURE OC_Field_NumberOfComponentsGetNumber
    MODULE PROCEDURE OC_Field_NumberOfComponentsGetObj
  END INTERFACE OC_Field_NumberOfComponentsGet

  !>Sets/changes the number of field components for a field variable.
  INTERFACE OC_Field_NumberOfComponentsSet
    MODULE PROCEDURE OC_Field_NumberOfComponentsSetNumber
    MODULE PROCEDURE OC_Field_NumberOfComponentsSetObj
  END INTERFACE OC_Field_NumberOfComponentsSet

  !>Returns the number of field DOFs for a field variable.
  INTERFACE OC_Field_NumberOfDOFsGet
    MODULE PROCEDURE OC_Field_NumberOfDOFsGetNumber
    MODULE PROCEDURE OC_Field_NumberOfDOFsGetObj
  END INTERFACE OC_Field_NumberOfDOFsGet

  !>Returns the number of global field DOFs for a field variable.
  INTERFACE OC_Field_NumberOfGlobalDOFsGet
    MODULE PROCEDURE OC_Field_NumberOfGlobalDOFsGetNumber
    MODULE PROCEDURE OC_Field_NumberOfGlobalDOFsGetObj
  END INTERFACE OC_Field_NumberOfGlobalDOFsGet

  !>Returns the number of field variables for a field.
  INTERFACE OC_Field_NumberOfVariablesGet
    MODULE PROCEDURE OC_Field_NumberOfVariablesGetNumber
    MODULE PROCEDURE OC_Field_NumberOfVariablesGetObj
  END INTERFACE OC_Field_NumberOfVariablesGet

  !>Sets/changes the number of field variables for a field.
  INTERFACE OC_Field_NumberOfVariablesSet
    MODULE PROCEDURE OC_Field_NumberOfVariablesSetNumber
    MODULE PROCEDURE OC_Field_NumberOfVariablesSetObj
  END INTERFACE OC_Field_NumberOfVariablesSet

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE OC_Field_ParameterSetAddConstant
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantSPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantDPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantLNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddConstantLObj
  END INTERFACE OC_Field_ParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE OC_Field_ParameterSetAddElement
    MODULE PROCEDURE OC_Field_ParameterSetAddElementIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddElementIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetAddElementSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddElementSPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddElementDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddElementDPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddElementLNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddElementLObj
  END INTERFACE OC_Field_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  INTERFACE OC_Field_ParameterSetAddGaussPoint
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointSPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointDPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointLNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddGaussPointLObj
  END INTERFACE OC_Field_ParameterSetAddGaussPoint

  !>Adds the given value to the given parameter set for a particular user node of the field variable component.
  INTERFACE OC_Field_ParameterSetAddNode
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeSPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeDPObj
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeLNumber
    MODULE PROCEDURE OC_Field_ParameterSetAddNodeLObj
  END INTERFACE OC_Field_ParameterSetAddNode

  !>Creates a new parameter set of type set type for a field variable.
  INTERFACE OC_Field_ParameterSetCreate
    MODULE PROCEDURE OC_Field_ParameterSetCreateNumber
    MODULE PROCEDURE OC_Field_ParameterSetCreateObj
  END INTERFACE OC_Field_ParameterSetCreate

  !>Destroy a parameter set of type set type for a field variable.
  INTERFACE OC_Field_ParameterSetDestroy
    MODULE PROCEDURE OC_Field_ParameterSetDestroyNumber
    MODULE PROCEDURE OC_Field_ParameterSetDestroyObj
  END INTERFACE OC_Field_ParameterSetDestroy

  !>Returns a pointer to the specified field parameter set local data array. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  INTERFACE OC_Field_ParameterSetDataGet
    MODULE PROCEDURE OC_Field_ParameterSetDataGetIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataGetIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetDataGetSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataGetSPObj
    MODULE PROCEDURE OC_Field_ParameterSetDataGetDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataGetDPObj
    MODULE PROCEDURE OC_Field_ParameterSetDataGetLNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataGetLObj
  END INTERFACE OC_Field_ParameterSetDataGet

  !>Restores the specified field variable parameter set local array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call.
  INTERFACE OC_Field_ParameterSetDataRestore
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreSPObj
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreDPObj
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreLNumber
    MODULE PROCEDURE OC_Field_ParameterSetDataRestoreLObj
  END INTERFACE OC_Field_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE OC_Field_ParameterSetGetConstant
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantSPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantDPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantLNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetConstantLObj
  END INTERFACE OC_Field_ParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified data pont of a field variable component.
  INTERFACE OC_Field_ParameterSetGetDataPoint
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointIntgNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointIntgNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointSPNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointSPNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointSPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointDPNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointDPNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointDPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointLNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointLNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetGetDataPointLObj
  END INTERFACE OC_Field_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE OC_Field_ParameterSetGetElement
    MODULE PROCEDURE OC_Field_ParameterSetGetElementIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetElementIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetGetElementSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetElementSPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetElementDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetElementDPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetElementLNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetElementLObj
  END INTERFACE OC_Field_ParameterSetGetElement

  !>Returns from the given parameter set a value for the specified node and derivative of a field variable component.
  INTERFACE OC_Field_ParameterSetGetNode
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeSPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeDPObj
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeLNumber
    MODULE PROCEDURE OC_Field_ParameterSetGetNodeLObj
  END INTERFACE OC_Field_ParameterSetGetNode

  !>Returns from the given parameter set a value for the specified element and Gauss point of a field variable component.
  INTERFACE OC_Field_ParameterSetGetGaussPoint ! TODO: other versions
    MODULE PROCEDURE OC_Field_ParameterSetGetGaussPointDPObj
  END INTERFACE OC_Field_ParameterSetGetGaussPoint

  !>Updates the given parameter set with the given value for the constant of a field variable component.
  INTERFACE OC_Field_ParameterSetUpdateConstant
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantSPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantDPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantLNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateConstantLObj
  END INTERFACE OC_Field_ParameterSetUpdateConstant

  !>Update the given parameter set a value for the specified data pont of a field variable component.
  INTERFACE OC_Field_ParameterSetUpdateDataPoint
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointIntgNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointIntgNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointSPNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointSPNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointSPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointDPNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointDPNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointDPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointLNumberI !Interface
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointLNumberR !Region
    MODULE PROCEDURE OC_Field_ParameterSetUpdateDataPointLObj
  END INTERFACE OC_Field_ParameterSetUpdateDataPoint

  !>Updates the given parameter set with the given value for a particular user element of a field variable component.
  INTERFACE OC_Field_ParameterSetUpdateElement
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementSPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementDPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementLNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementLObj
  END INTERFACE OC_Field_ParameterSetUpdateElement

  !>Finishes the parameter set update for a field variable. \see OpenCMISS::OC_Field_ParameterSetUpdateStart
  INTERFACE OC_Field_ParameterSetUpdateFinish
    MODULE PROCEDURE OC_Field_ParameterSetUpdateFinishNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateFinishObj
  END INTERFACE OC_Field_ParameterSetUpdateFinish

  !>Updates the given parameter set with the given value for a particular user node of a field variable component.
  INTERFACE OC_Field_ParameterSetUpdateNode
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeSPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeDPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeLNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateNodeLObj
  END INTERFACE OC_Field_ParameterSetUpdateNode

  !\todo: merge the two types of routines for getting scalefactors under the same interface declaration?
  !>Gets a scale factor for a particular node.
  INTERFACE OC_Field_ParameterSetNodeScaleFactorGet
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorGetNumber
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorGetObj
  END INTERFACE OC_Field_ParameterSetNodeScaleFactorGet

  !>Gets the scale factors for all nodes
  INTERFACE OC_Field_ParameterSetNodeScaleFactorsGet
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorsGetNumber
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorsGetObj
  END INTERFACE OC_Field_ParameterSetNodeScaleFactorsGet

  !>Sets a scale factor for a particular node.
  INTERFACE OC_Field_ParameterSetNodeScaleFactorSet
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorSetNumber
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorSetObj
  END INTERFACE OC_Field_ParameterSetNodeScaleFactorSet

  !>Sets the scale factors for all nodes
  INTERFACE OC_Field_ParameterSetNodeScaleFactorsSet
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorsSetNumber
    MODULE PROCEDURE OC_Field_ParameterSetNodeScaleFactorsSetObj
  END INTERFACE OC_Field_ParameterSetNodeScaleFactorsSet

  !>Gets the number of scalefactor dofs
  INTERFACE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGet
    MODULE PROCEDURE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber
    MODULE PROCEDURE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj
  END INTERFACE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  !>Updates the given parameter set with the given value for a particular Gauss point of a field variable component.
  INTERFACE OC_Field_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointIntgNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointIntgObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointSPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointSPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointDPNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointDPObj
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointLNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateGaussPointLObj
  END INTERFACE OC_Field_ParameterSetUpdateGaussPoint

  !>Interpolates the given parameter set at a specified xi/set of xi locations for specified element and derviative.
  INTERFACE OC_Field_ParameterSetInterpolateXi
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateXiDPNumber0
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateXiDPObj0
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateXiDPNumber1
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateXiDPObj1
  END INTERFACE OC_Field_ParameterSetInterpolateXi

  !>Interpolates the given parameter set at a specified set of Gauss points for specified element and derviative. When interpolating at multiple Gauss points, if no Gauss points are specified then all Gauss points are interpolated.
  INTERFACE OC_Field_ParameterSetInterpolateGauss
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateGaussDPNumber0
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateGaussDPObj0
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateGaussDPNumber1
    MODULE PROCEDURE OC_Field_ParameterSetInterpolateGaussDPObj1
  END INTERFACE OC_Field_ParameterSetInterpolateGauss

  !>Updates the given parameter set with the given value for a particular data point of a field variable component.
  INTERFACE OC_Field_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE OC_Field_ParameterSetUpdateElementDataPointDPObj
  END INTERFACE OC_Field_ParameterSetUpdateElementDataPoint

  !>Starts the parameter set update for a field variable. \see OpenCMISS::OC_Field_ParameterSetUpdateFinish
  INTERFACE OC_Field_ParameterSetUpdateStart
    MODULE PROCEDURE OC_Field_ParameterSetUpdateStartNumber
    MODULE PROCEDURE OC_Field_ParameterSetUpdateStartObj
  END INTERFACE OC_Field_ParameterSetUpdateStart

  !>Add the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  INTERFACE OC_Field_ParametersToFieldParametersComponentAdd
    MODULE PROCEDURE OC_Field_ParametersToFieldParametersComponentAddNumber
    MODULE PROCEDURE OC_Field_ParametersToFieldParametersComponentAddObj
  END INTERFACE OC_Field_ParametersToFieldParametersComponentAdd

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  INTERFACE OC_Field_ParametersToFieldParametersComponentCopy
    MODULE PROCEDURE OC_Field_ParametersToFieldParametersComponentCopyNumber
    MODULE PROCEDURE OC_Field_ParametersToFieldParametersComponentCopyObj
  END INTERFACE OC_Field_ParametersToFieldParametersComponentCopy

  !>Returns the scaling type for a field.
  INTERFACE OC_Field_ScalingTypeGet
    MODULE PROCEDURE OC_Field_ScalingTypeGetNumber
    MODULE PROCEDURE OC_Field_ScalingTypeGetObj
  END INTERFACE OC_Field_ScalingTypeGet

  !>Sets/changes the scaling type for a field.
  INTERFACE OC_Field_ScalingTypeSet
    MODULE PROCEDURE OC_Field_ScalingTypeSetNumber
    MODULE PROCEDURE OC_Field_ScalingTypeSetObj
  END INTERFACE OC_Field_ScalingTypeSet

  !>Returns the total number of field DOFs for a field variable.
  INTERFACE OC_Field_TotalNumberOfDOFsGet
    MODULE PROCEDURE OC_Field_TotalNumberOfDOFsGetNumber
    MODULE PROCEDURE OC_Field_TotalNumberOfDOFsGetObj
  END INTERFACE OC_Field_TotalNumberOfDOFsGet

  !>Returns the type for a field.
  INTERFACE OC_Field_TypeGet
    MODULE PROCEDURE OC_Field_TypeGetNumber
    MODULE PROCEDURE OC_Field_TypeGetObj
  END INTERFACE OC_Field_TypeGet

  !>Sets/changes the type for a field.
  INTERFACE OC_Field_TypeSet
    MODULE PROCEDURE OC_Field_TypeSetNumber
    MODULE PROCEDURE OC_Field_TypeSetObj
  END INTERFACE OC_Field_TypeSet

  !>Returns the label for a field variable.
  INTERFACE OC_Field_VariableLabelGet
    MODULE PROCEDURE OC_Field_VariableLabelGetCNumber
    MODULE PROCEDURE OC_Field_VariableLabelGetCObj
    MODULE PROCEDURE OC_Field_VariableLabelGetVSNumber
    MODULE PROCEDURE OC_Field_VariableLabelGetVSObj
  END INTERFACE OC_Field_VariableLabelGet

  !>Sets/changes the label for a field variable.
  INTERFACE OC_Field_VariableLabelSet
    MODULE PROCEDURE OC_Field_VariableLabelSetCNumber
    MODULE PROCEDURE OC_Field_VariableLabelSetCObj
    MODULE PROCEDURE OC_Field_VariableLabelSetVSNumber
    MODULE PROCEDURE OC_Field_VariableLabelSetVSObj
  END INTERFACE OC_Field_VariableLabelSet

  !>Returns the field variable types for a field.
  INTERFACE OC_Field_VariableTypesGet
    MODULE PROCEDURE OC_Field_VariableTypesGetNumber
    MODULE PROCEDURE OC_Field_VariableTypesGetObj
  END INTERFACE OC_Field_VariableTypesGet

  !>Sets/changes the field variable types for a field.
  INTERFACE OC_Field_VariableTypesSet
    MODULE PROCEDURE OC_Field_VariableTypesSetNumber
    MODULE PROCEDURE OC_Field_VariableTypesSetObj
  END INTERFACE OC_Field_VariableTypesSet

  !>Adds a field to a list of fields
  INTERFACE OC_Fields_AddField
    MODULE PROCEDURE OC_Fields_AddFieldObj
  END INTERFACE OC_Fields_AddField

  PUBLIC OC_FIELD_DEPENDENT_TYPE,OC_FIELD_INDEPENDENT_TYPE

  PUBLIC OC_FIELD_SCALAR_DIMENSION_TYPE,OC_FIELD_VECTOR_DIMENSION_TYPE,OC_FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC OC_FIELD_GEOMETRIC_TYPE,OC_FIELD_FIBRE_TYPE,OC_FIELD_GENERAL_TYPE,OC_FIELD_MATERIAL_TYPE, &
    & OC_FIELD_GEOMETRIC_GENERAL_TYPE

  PUBLIC OC_FIELD_CONSTANT_INTERPOLATION,OC_FIELD_ELEMENT_BASED_INTERPOLATION,OC_FIELD_NODE_BASED_INTERPOLATION, &
    & OC_FIELD_GRID_POINT_BASED_INTERPOLATION,OC_FIELD_GAUSS_POINT_BASED_INTERPOLATION, &
    & OC_FIELD_DATA_POINT_BASED_INTERPOLATION

  PUBLIC OC_FIELD_NUMBER_OF_VARIABLE_SUBTYPES

  PUBLIC OC_FIELD_U_VARIABLE_TYPE,OC_FIELD_DELUDELN_VARIABLE_TYPE,OC_FIELD_T_VARIABLE_TYPE, &
    & OC_FIELD_DELUDELT_VARIABLE_TYPE,OC_FIELD_DEL2UDELT2_VARIABLE_TYPE, &
    & OC_FIELD_V_VARIABLE_TYPE,OC_FIELD_DELVDELN_VARIABLE_TYPE,OC_FIELD_DELVDELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2VDELT2_VARIABLE_TYPE, &
    & OC_FIELD_W_VARIABLE_TYPE, &
    & OC_FIELD_U1_VARIABLE_TYPE,OC_FIELD_DELU1DELN_VARIABLE_TYPE,OC_FIELD_DELU1DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U1DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U2_VARIABLE_TYPE,OC_FIELD_DELU2DELN_VARIABLE_TYPE,OC_FIELD_DELU2DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U2DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U3_VARIABLE_TYPE,OC_FIELD_DELU3DELN_VARIABLE_TYPE,OC_FIELD_DELU3DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U3DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U4_VARIABLE_TYPE,OC_FIELD_DELU4DELN_VARIABLE_TYPE,OC_FIELD_DELU4DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U4DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U5_VARIABLE_TYPE,OC_FIELD_DELU5DELN_VARIABLE_TYPE,OC_FIELD_DELU5DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U5DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U6_VARIABLE_TYPE,OC_FIELD_DELU6DELN_VARIABLE_TYPE,OC_FIELD_DELU6DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U6DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U7_VARIABLE_TYPE,OC_FIELD_DELU7DELN_VARIABLE_TYPE,OC_FIELD_DELU7DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U7DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U8_VARIABLE_TYPE,OC_FIELD_DELU8DELN_VARIABLE_TYPE,OC_FIELD_DELU8DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U8DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U9_VARIABLE_TYPE,OC_FIELD_DELU9DELN_VARIABLE_TYPE,OC_FIELD_DELU9DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U9DELT2_VARIABLE_TYPE, &
    & OC_FIELD_U10_VARIABLE_TYPE,OC_FIELD_DELU10DELN_VARIABLE_TYPE,OC_FIELD_DELU10DELT_VARIABLE_TYPE, &
    & OC_FIELD_DEL2U10DELT2_VARIABLE_TYPE

  PUBLIC OC_FIELD_INTG_TYPE,OC_FIELD_SP_TYPE,OC_FIELD_DP_TYPE,OC_FIELD_L_TYPE

  PUBLIC OC_FIELD_SEPARATED_COMPONENT_DOF_ORDER,OC_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC OC_FIELD_VALUES_SET_TYPE,OC_FIELD_INITIAL_VALUES_SET_TYPE,OC_FIELD_INCREMENTAL_VALUES_SET_TYPE, &
    & OC_FIELD_BOUNDARY_CONDITIONS_SET_TYPE, OC_FIELD_ANALYTIC_VALUES_SET_TYPE, &
    & OC_FIELD_ANALYTIC_VELOCITY_VALUES_SET_TYPE,OC_FIELD_ANALYTIC_ACCELERATION_VALUES_SET_TYPE, &
    & OC_FIELD_PREVIOUS_VALUES_SET_TYPE,OC_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,OC_FIELD_VELOCITY_VALUES_SET_TYPE, &
    & OC_FIELD_INITIAL_VELOCITY_SET_TYPE,OC_FIELD_PREVIOUS_VELOCITY_SET_TYPE,OC_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE, &
    & OC_FIELD_ACCELERATION_VALUES_SET_TYPE,OC_FIELD_INITIAL_ACCELERATION_SET_TYPE, &
    & OC_FIELD_PREVIOUS_ACCELERATION_SET_TYPE, &
    & OC_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE, OC_FIELD_PRESSURE_VALUES_SET_TYPE, &
    & OC_FIELD_PREVIOUS_PRESSURE_SET_TYPE, &
    & OC_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,OC_FIELD_INTEGRATED_NEUMANN_SET_TYPE, &
    & OC_FIELD_MESH_DISPLACEMENT_SET_TYPE,OC_FIELD_MESH_VELOCITY_SET_TYPE,OC_FIELD_CELLML_VALUES_SET_TYPE

  PUBLIC OC_FIELD_NO_SCALING,OC_FIELD_UNIT_SCALING,OC_FIELD_ARC_LENGTH_SCALING,OC_FIELD_ARITHMETIC_MEAN_SCALING, &
    & OC_FIELD_GEOMETRIC_MEAN_SCALING,OC_FIELD_HARMONIC_MEAN_SCALING

  PUBLIC OC_Field_ComponentInterpolationGet,OC_Field_ComponentInterpolationSet

  PUBLIC OC_Field_ComponentLabelGet,OC_Field_ComponentLabelSet

  PUBLIC OC_Field_ComponentMeshComponentGet,OC_Field_ComponentMeshComponentSet

  PUBLIC OC_Field_ComponentValuesInitialise

  PUBLIC OC_Field_DataTypeGet,OC_Field_DataTypeSet

  PUBLIC OC_Field_DOFOrderTypeGet,OC_Field_DOFOrderTypeSet

  PUBLIC OC_Field_CreateFinish,OC_Field_CreateStart

  PUBLIC OC_Field_DependentTypeGet,OC_Field_DependentTypeSet

  PUBLIC OC_Field_Destroy

  PUBLIC OC_Field_DimensionGet,OC_Field_DimensionSet

  PUBLIC OC_Field_GeometricFieldGet,OC_Field_GeometricFieldSet

  PUBLIC OC_Field_GeometricParametersElementLineLengthGet, OC_Field_GeometricParametersElementVolumeGet

  PUBLIC OC_Field_LabelGet,OC_Field_LabelSet

  PUBLIC OC_Field_DecompositionGet,OC_Field_DecompositionSet

  PUBLIC OC_Field_DataProjectionSet

  PUBLIC OC_Field_PositionNormalTangentCalculateNode

  PUBLIC OC_Field_NumberOfComponentsGet,OC_Field_NumberOfComponentsSet

  PUBLIC OC_Field_NumberOfDOFsGet

  PUBLIC OC_Field_NumberOfGlobalDOFsGet

  PUBLIC OC_Field_NumberOfVariablesGet,OC_Field_NumberOfVariablesSet

  PUBLIC OC_Field_ParameterSetAddConstant,OC_Field_ParameterSetAddElement,OC_Field_ParameterSetAddGaussPoint, &
    & OC_Field_ParameterSetAddNode

  PUBLIC OC_Field_ParameterSetCreate

  PUBLIC OC_Field_ParameterSetDestroy

  PUBLIC OC_Field_ParameterSetDataGet,OC_Field_ParameterSetDataRestore

  PUBLIC OC_Field_ParameterSetGetConstant,OC_Field_ParameterSetGetElement,OC_Field_ParameterSetGetNode

  PUBLIC OC_Field_ParameterSetGetDataPoint,OC_Field_ParameterSetUpdateDataPoint

  PUBLIC OC_Field_ParameterSetUpdateConstant,OC_Field_ParameterSetUpdateElement,OC_Field_ParameterSetUpdateNode

  PUBLIC OC_Field_ParameterSetNodeScaleFactorGet,OC_Field_ParameterSetNodeScaleFactorSet

  PUBLIC OC_Field_ParameterSetNodeScaleFactorsGet,OC_Field_ParameterSetNodeScaleFactorsSet

  PUBLIC OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC OC_Field_ParameterSetUpdateGaussPoint,OC_Field_ParameterSetGetGaussPoint

  PUBLIC OC_Field_ParameterSetInterpolateXi

  PUBLIC OC_Field_ParameterSetInterpolateGauss

  PUBLIC OC_Field_ParameterSetUpdateElementDataPoint

  PUBLIC OC_Field_ParameterSetUpdateFinish,OC_Field_ParameterSetUpdateStart

  PUBLIC OC_Field_ParametersToFieldParametersComponentAdd

  PUBLIC OC_Field_ParametersToFieldParametersComponentCopy

  PUBLIC OC_Field_ScalingTypeGet,OC_Field_ScalingTypeSet

  PUBLIC OC_Field_TotalNumberOfDOFsGet

  PUBLIC OC_Field_TypeGet,OC_Field_TypeSet

  PUBLIC OC_Field_VariableLabelGet,OC_Field_VariableLabelSet

  PUBLIC OC_Field_VariableTypesGet,OC_Field_VariableTypesSet

  !==================================================================================================================================
  !
  ! FIELD_IO_ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  INTERFACE OC_Fields_ElementsExport
    MODULE PROCEDURE OC_Fields_ElementsExportCCNumber
    MODULE PROCEDURE OC_Fields_ElementsExportVSCNumber
    MODULE PROCEDURE OC_Fields_ElementsExportCVSNumber
    MODULE PROCEDURE OC_Fields_ElementsExportVSVSNumber
    MODULE PROCEDURE OC_Fields_ElementsExportCCObj
    MODULE PROCEDURE OC_Fields_ElementsExportVSCObj
    MODULE PROCEDURE OC_Fields_ElementsExportCVSObj
    MODULE PROCEDURE OC_Fields_ElementsExportVSVSObj
  END INTERFACE OC_Fields_ElementsExport

  INTERFACE OC_Fields_NodesExport
    MODULE PROCEDURE OC_Fields_NodesExportCCNumber
    MODULE PROCEDURE OC_Fields_NodesExportVSCNumber
    MODULE PROCEDURE OC_Fields_NodesExportCVSNumber
    MODULE PROCEDURE OC_Fields_NodesExportVSVSNumber
    MODULE PROCEDURE OC_Fields_NodesExportCCObj
    MODULE PROCEDURE OC_Fields_NodesExportVSCObj
    MODULE PROCEDURE OC_Fields_NodesExportCVSObj
    MODULE PROCEDURE OC_Fields_NodesExportVSVSObj
  END INTERFACE OC_Fields_NodesExport

  PUBLIC OC_Fields_ElementsExport,OC_Fields_NodesExport

  !==================================================================================================================================
  !
  ! GeneratedMeshRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_GeneratedMeshConstants OpenCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OpenCMISS_GeneratedMeshTypes OpenCMISS::GeneratedMesh::Types
  !> \brief Generated mesh types.
  !> \see OpenCMISS::GeneratedMesh,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_MESH_TYPE = GENERATED_MESH_REGULAR_MESH_TYPE !<A regular generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_POLAR_MESH_TYPE = GENERATED_MESH_POLAR_MESH_TYPE !<A polar generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE = GENERATED_MESH_FRACTAL_TREE_MESH_TYPE !<A fractal tree generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_CYLINDER_MESH_TYPE = GENERATED_MESH_CYLINDER_MESH_TYPE !<A cylinder generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_ELLIPSOID_MESH_TYPE = GENERATED_MESH_ELLIPSOID_MESH_TYPE !<An ellipsoid generated mesh. \see OpenCMISS_GeneratedMeshTypes,OpenCMISS
  !>@}
  !>@}

  !> \addtogroup OpenCMISS_GeneratedMeshConstants OpenCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OpenCMISS_GeneratedMeshSurfaceTypes OpenCMISS::GeneratedMesh::SurfaceTypes
  !> \brief Generated mesh surface types.
  !> \see OpenCMISS::GeneratedMesh,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_CYLINDER_INNER_SURFACE = GENERATED_MESH_CYLINDER_INNER_SURFACE !<Cylinder inner surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_CYLINDER_OUTER_SURFACE = GENERATED_MESH_CYLINDER_OUTER_SURFACE !<Cylinder outer surface. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_CYLINDER_TOP_SURFACE = GENERATED_MESH_CYLINDER_TOP_SURFACE !<Cylinder top surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE = GENERATED_MESH_CYLINDER_BOTTOM_SURFACE !<Cylinder bottom surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_ELLIPSOID_INNER_SURFACE = GENERATED_MESH_ELLIPSOID_INNER_SURFACE !<Ellipsoid inner surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE = GENERATED_MESH_ELLIPSOID_OUTER_SURFACE !<Ellipsoid outer surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_ELLIPSOID_TOP_SURFACE = GENERATED_MESH_ELLIPSOID_TOP_SURFACE !<Ellipsoid top surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_LEFT_SURFACE = GENERATED_MESH_REGULAR_LEFT_SURFACE !<Regular left surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_RIGHT_SURFACE = GENERATED_MESH_REGULAR_RIGHT_SURFACE !<Regular right surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_TOP_SURFACE = GENERATED_MESH_REGULAR_TOP_SURFACE !<Regular top surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_BOTTOM_SURFACE = GENERATED_MESH_REGULAR_BOTTOM_SURFACE !<Regular bottom surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_FRONT_SURFACE = GENERATED_MESH_REGULAR_FRONT_SURFACE !<Regular front surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_GENERATED_MESH_REGULAR_BACK_SURFACE = GENERATED_MESH_REGULAR_BACK_SURFACE !<Regular back surface constant. \see OpenCMISS_GeneratedMeshSurfaceTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the basis for a generated mesh.
  INTERFACE OC_GeneratedMesh_BasisGet
    MODULE PROCEDURE OC_GeneratedMesh_BasisGetNumber
    MODULE PROCEDURE OC_GeneratedMesh_BasisGetObj
  END INTERFACE OC_GeneratedMesh_BasisGet

  !>Sets/changes the basis for a generated mesh.
  INTERFACE OC_GeneratedMesh_BasisSet
    MODULE PROCEDURE OC_GeneratedMesh_BasisSetNumber0
    MODULE PROCEDURE OC_GeneratedMesh_BasisSetNumber1
    MODULE PROCEDURE OC_GeneratedMesh_BasisSetObj0
    MODULE PROCEDURE OC_GeneratedMesh_BasisSetObj1
  END INTERFACE OC_GeneratedMesh_BasisSet

  !>Sets/changes the base vectors for a generated mesh.
  INTERFACE OC_GeneratedMesh_BaseVectorsSet
    MODULE PROCEDURE OC_GeneratedMesh_BaseVectorsSetNumber
    MODULE PROCEDURE OC_GeneratedMesh_BaseVectorsSetObj
  END INTERFACE OC_GeneratedMesh_BaseVectorsSet

  !>Finishes the creation of a generated mesh. \see OpenCMISS::OC_GeneratedMesh_CreateStart
  INTERFACE OC_GeneratedMesh_CreateFinish
    MODULE PROCEDURE OC_GeneratedMesh_CreateFinishNumber
    MODULE PROCEDURE OC_GeneratedMesh_CreateFinishObj
  END INTERFACE OC_GeneratedMesh_CreateFinish

  !>Starts the creation of a generated mesh. \see OpenCMISS::OC_GeneratedMesh_CreateFinish
  INTERFACE OC_GeneratedMesh_CreateStart
    MODULE PROCEDURE OC_GeneratedMesh_CreateStartNumber
    MODULE PROCEDURE OC_GeneratedMesh_CreateStartInterfaceObj
    MODULE PROCEDURE OC_GeneratedMesh_CreateStartRegionObj
  END INTERFACE OC_GeneratedMesh_CreateStart

  !>Destroys a generated mesh.
  INTERFACE OC_GeneratedMesh_Destroy
    MODULE PROCEDURE OC_GeneratedMesh_DestroyNumber
    MODULE PROCEDURE OC_GeneratedMesh_DestroyObj
  END INTERFACE OC_GeneratedMesh_Destroy

  !>Returns the extent of a generated mesh.
  INTERFACE OC_GeneratedMesh_ExtentGet
    MODULE PROCEDURE OC_GeneratedMesh_ExtentGetNumber
    MODULE PROCEDURE OC_GeneratedMesh_ExtentGetObj
  END INTERFACE OC_GeneratedMesh_ExtentGet

  !>Sets/changes the extent of a generated mesh.
  INTERFACE OC_GeneratedMesh_ExtentSet
    MODULE PROCEDURE OC_GeneratedMesh_ExtentSetNumber0
    MODULE PROCEDURE OC_GeneratedMesh_ExtentSetNumber1
    MODULE PROCEDURE OC_GeneratedMesh_ExtentSetObj0
    MODULE PROCEDURE OC_GeneratedMesh_ExtentSetObj1
  END INTERFACE OC_GeneratedMesh_ExtentSet

  !>Returns the number of elements in a generated mesh.
  INTERFACE OC_GeneratedMesh_NumberOfElementsGet
    MODULE PROCEDURE OC_GeneratedMesh_NumberOfElementsGetNumber
    MODULE PROCEDURE OC_GeneratedMesh_NumberOfElementsGetObj
  END INTERFACE OC_GeneratedMesh_NumberOfElementsGet

  !>Sets/changes the number of elements in a generated mesh.
  INTERFACE OC_GeneratedMesh_NumberOfElementsSet
    MODULE PROCEDURE OC_GeneratedMesh_NumberOfElementsSetNumber0
    MODULE PROCEDURE OC_GeneratedMesh_NumberOfElementsSetNumber1
    MODULE PROCEDURE OC_GeneratedMesh_NumberOfElementsSetObj0
    MODULE PROCEDURE OC_GeneratedMesh_NumberOfElementsSetObj1
  END INTERFACE OC_GeneratedMesh_NumberOfElementsSet

  !>Returns the origin of a generated mesh.
  INTERFACE OC_GeneratedMesh_OriginGet
    MODULE PROCEDURE OC_GeneratedMesh_OriginGetNumber
    MODULE PROCEDURE OC_GeneratedMesh_OriginGetObj
  END INTERFACE OC_GeneratedMesh_OriginGet

  !>Sets/changes the origin of a generated mesh.
  INTERFACE OC_GeneratedMesh_OriginSet
    MODULE PROCEDURE OC_GeneratedMesh_OriginSetNumber
    MODULE PROCEDURE OC_GeneratedMesh_OriginSetObj
  END INTERFACE OC_GeneratedMesh_OriginSet

  !>Returns the type of a generated mesh.
  INTERFACE OC_GeneratedMesh_TypeGet
    MODULE PROCEDURE OC_GeneratedMesh_TypeGetNumber
    MODULE PROCEDURE OC_GeneratedMesh_TypeGetObj
  END INTERFACE OC_GeneratedMesh_TypeGet

  !>Sets/changes the type of a generated mesh.
  INTERFACE OC_GeneratedMesh_TypeSet
    MODULE PROCEDURE OC_GeneratedMesh_TypeSetNumber
    MODULE PROCEDURE OC_GeneratedMesh_TypeSetObj
  END INTERFACE OC_GeneratedMesh_TypeSet

  !>Calculates and sets the geometric field parameters for a generated mesh
  INTERFACE OC_GeneratedMesh_GeometricParametersCalculate
    MODULE PROCEDURE OC_GeneratedMesh_GeometricParametersCalculateNumber
    MODULE PROCEDURE OC_GeneratedMesh_GeometricParametersCalculateObj
  END INTERFACE OC_GeneratedMesh_GeometricParametersCalculate

  !>Returns a list of nodes belonging to a surface of given type
  INTERFACE OC_GeneratedMesh_SurfaceGet
    MODULE PROCEDURE OC_GeneratedMesh_SurfaceGetNumber0
    MODULE PROCEDURE OC_GeneratedMesh_SurfaceGetNumber1
    MODULE PROCEDURE OC_GeneratedMesh_SurfaceGetObj0
    MODULE PROCEDURE OC_GeneratedMesh_SurfaceGetObj1
  END INTERFACE OC_GeneratedMesh_SurfaceGet

  !>Creates an embedding of one mesh in another
  INTERFACE OC_MeshEmbedding_Create
    MODULE PROCEDURE OC_MeshEmbedding_CreateNumber
    MODULE PROCEDURE OC_MeshEmbedding_CreateObj
  END INTERFACE OC_MeshEmbedding_Create

  !>Sets the embedded nodes for one parent element
  INTERFACE OC_MeshEmbedding_SetChildNodePosition
    MODULE PROCEDURE OC_MeshEmbedding_SetChildNodePositionObj
  END INTERFACE OC_MeshEmbedding_SetChildNodePosition

  !>Pushes data from the parent field to the child field
  INTERFACE OC_MeshEmbedding_PushData
    MODULE PROCEDURE OC_MeshEmbedding_PushDataObj
  END INTERFACE OC_MeshEmbedding_PushData

  INTERFACE OC_MeshEmbedding_SetGaussPointData
    MODULE PROCEDURE OC_MeshEmbedding_SetGaussPointDataObj
  END INTERFACE OC_MeshEmbedding_SetGaussPointData

  INTERFACE OC_MeshEmbedding_PullGaussPointData
    MODULE PROCEDURE OC_MeshEmbedding_PullGaussPointDataObj
  END INTERFACE OC_MeshEmbedding_PullGaussPointData

  INTERFACE OC_MeshEmbedding_GetGaussPointCoord
    MODULE PROCEDURE OC_Field_ParameterSetGetGaussPointCoordObj
  END INTERFACE OC_MeshEmbedding_GetGaussPointCoord

  PUBLIC OC_MeshEmbedding_Create,OC_MeshEmbedding_SetChildNodePosition, OC_MeshEmbeddingType

  PUBLIC OC_MeshEmbedding_Initialise,OC_MeshEmbedding_SetGaussPointData

  PUBLIC OC_MeshEmbedding_PushData,OC_MeshEmbedding_PullGaussPointData

  PUBLIC OC_MeshEmbedding_GetGaussPointCoord

  PUBLIC OC_GENERATED_MESH_REGULAR_MESH_TYPE,OC_GENERATED_MESH_POLAR_MESH_TYPE,OC_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE

  PUBLIC OC_GENERATED_MESH_CYLINDER_MESH_TYPE, OC_GENERATED_MESH_ELLIPSOID_MESH_TYPE

  PUBLIC OC_GENERATED_MESH_CYLINDER_INNER_SURFACE,OC_GENERATED_MESH_CYLINDER_OUTER_SURFACE

  PUBLIC OC_GENERATED_MESH_CYLINDER_TOP_SURFACE, OC_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE

  PUBLIC OC_GENERATED_MESH_ELLIPSOID_INNER_SURFACE, OC_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE

  PUBLIC OC_GENERATED_MESH_ELLIPSOID_TOP_SURFACE

  PUBLIC OC_GENERATED_MESH_REGULAR_LEFT_SURFACE, OC_GENERATED_MESH_REGULAR_RIGHT_SURFACE, &
    & OC_GENERATED_MESH_REGULAR_TOP_SURFACE

  PUBLIC OC_GENERATED_MESH_REGULAR_BOTTOM_SURFACE, OC_GENERATED_MESH_REGULAR_FRONT_SURFACE, &
    & OC_GENERATED_MESH_REGULAR_BACK_SURFACE

  PUBLIC OC_GeneratedMesh_BasisGet,OC_GeneratedMesh_BasisSet

  PUBLIC OC_GeneratedMesh_BaseVectorsSet

  PUBLIC OC_GeneratedMesh_CreateFinish,OC_GeneratedMesh_CreateStart

  PUBLIC OC_GeneratedMesh_Destroy

  PUBLIC OC_GeneratedMesh_ExtentGet,OC_GeneratedMesh_ExtentSet

  PUBLIC OC_GeneratedMesh_NumberOfElementsGet,OC_GeneratedMesh_NumberOfElementsSet

  PUBLIC OC_GeneratedMesh_OriginGet,OC_GeneratedMesh_OriginSet

  PUBLIC OC_GeneratedMesh_TypeGet,OC_GeneratedMesh_TypeSet

  PUBLIC OC_GeneratedMesh_GeometricParametersCalculate

  PUBLIC OC_GeneratedMesh_SurfaceGet


  !==================================================================================================================================
  !
  ! INTERFACE_ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Adds a mesh to an interface.
  INTERFACE OC_Interface_MeshAdd
    MODULE PROCEDURE OC_Interface_MeshAddNumber
    MODULE PROCEDURE OC_Interface_MeshAddObj
  END INTERFACE OC_Interface_MeshAdd

  !>Finishes the creation of an interface. \see OpenCMISS::OC_Interface_CreateStart
  INTERFACE OC_Interface_CreateFinish
    MODULE PROCEDURE OC_Interface_CreateFinishNumber
    MODULE PROCEDURE OC_Interface_CreateFinishObj
  END INTERFACE OC_Interface_CreateFinish

  !>Starts the creation of an interface. \see OpenCMISS::OC_Interface_CreateFinish
  INTERFACE OC_Interface_CreateStart
    MODULE PROCEDURE OC_Interface_CreateStartNumber
    MODULE PROCEDURE OC_Interface_CreateStartObj
  END INTERFACE OC_Interface_CreateStart

  !>Set the coordinate system of an inteface
  INTERFACE OC_Interface_CoordinateSystemSet
    MODULE PROCEDURE OC_Interface_CoordinateSystemSetNumber
    MODULE PROCEDURE OC_Interface_CoordinateSystemSetObj
  END INTERFACE OC_Interface_CoordinateSystemSet

  !>Get the coordinate system of an inteface
  INTERFACE OC_Interface_CoordinateSystemGet
    MODULE PROCEDURE OC_Interface_CoordinateSystemGetNumber
    MODULE PROCEDURE OC_Interface_CoordinateSystemGetObj
  END INTERFACE OC_Interface_CoordinateSystemGet

  !>Destroys an interface.
  INTERFACE OC_Interface_Destroy
    MODULE PROCEDURE OC_Interface_DestroyNumber
    MODULE PROCEDURE OC_Interface_DestroyObj
  END INTERFACE OC_Interface_Destroy

  !>Returns the label of an interface.
  INTERFACE OC_Interface_LabelGet
    MODULE PROCEDURE OC_Interface_LabelGetCNumber
    MODULE PROCEDURE OC_Interface_LabelGetCObj
    MODULE PROCEDURE OC_Interface_LabelGetVSNumber
    MODULE PROCEDURE OC_Interface_LabelGetVSObj
  END INTERFACE OC_Interface_LabelGet

  !>Sets/changes the label of an interface.
  INTERFACE OC_Interface_LabelSet
    MODULE PROCEDURE OC_Interface_LabelSetCNumber
    MODULE PROCEDURE OC_Interface_LabelSetCObj
    MODULE PROCEDURE OC_Interface_LabelSetVSNumber
    MODULE PROCEDURE OC_Interface_LabelSetVSObj
  END INTERFACE OC_Interface_LabelSet

  !>Returns the nodes for a interface.
  INTERFACE OC_Interface_NodesGet
    MODULE PROCEDURE OC_Interface_NodesGetObj
  END INTERFACE OC_Interface_NodesGet

  !>Finishes the creation of an interface meshes connectivity. \see OpenCMISS::OC_InterfaceMeshConnectivity_CreateStart
  INTERFACE OC_InterfaceMeshConnectivity_CreateFinish
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_CreateFinishNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_CreateFinishObj
  END INTERFACE OC_InterfaceMeshConnectivity_CreateFinish

  !>Starts the creation of an interface meshes connectivity.
  INTERFACE OC_InterfaceMeshConnectivity_CreateStart
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_CreateStartNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_CreateStartObj
  END INTERFACE OC_InterfaceMeshConnectivity_CreateStart

  !>Sets the element xi values for the mesh connectivity between an element in the interface mesh and an element in a region mesh
  INTERFACE OC_InterfaceMeshConnectivity_ElementXiSet
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_ElementXiSetNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_ElementXiSetObj
  END INTERFACE OC_InterfaceMeshConnectivity_ElementXiSet

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE OC_InterfaceMeshConnectivity_ElementNumberSet
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_ElementNumberSetNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_ElementNumberSetObj
  END INTERFACE OC_InterfaceMeshConnectivity_ElementNumberSet

  !>Sets the coupled node numbers
  INTERFACE OC_InterfaceMeshConnectivity_NodeNumberSet
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_NodeNumberSetNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_NodeNumberSetObj
  END INTERFACE OC_InterfaceMeshConnectivity_NodeNumberSet

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE OC_InterfaceMeshConnectivity_BasisSet
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_BasisSetNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_BasisSetObj
  END INTERFACE OC_InterfaceMeshConnectivity_BasisSet

  !>Destroys an interface meshes connectivity.
  INTERFACE OC_InterfaceMeshConnectivity_Destroy
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_DestroyNumber
    MODULE PROCEDURE OC_InterfaceMeshConnectivity_DestroyObj
  END INTERFACE OC_InterfaceMeshConnectivity_Destroy

  !>Finishes the creation of an interface points connectivity.
  INTERFACE OC_InterfacePointsConnectivity_CreateFinish
    MODULE PROCEDURE OC_InterfacePointsConnectivity_CreateFinishNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_CreateFinishObj
  END INTERFACE OC_InterfacePointsConnectivity_CreateFinish

  !>Starts the creation of an interface points connectivity.
  INTERFACE OC_InterfacePointsConnectivity_CreateStart
    MODULE PROCEDURE OC_InterfacePointsConnectivity_CreateStartNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_CreateStartObj
  END INTERFACE OC_InterfacePointsConnectivity_CreateStart

  !>Destroys an interface points connectivity.
  INTERFACE OC_InterfacePointsConnectivity_Destroy
    MODULE PROCEDURE OC_InterfacePointsConnectivity_DestroyNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_DestroyObj
  END INTERFACE OC_InterfacePointsConnectivity_Destroy

  !>Get the coupled mesh element number that defines points connectivity
  INTERFACE OC_InterfacePointsConnectivity_ElementNumberGet
    MODULE PROCEDURE OC_InterfacePointsConnectivity_ElementNumberGetNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_ElementNumberGetObj
  END INTERFACE OC_InterfacePointsConnectivity_ElementNumberGet

  !>Gets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
  INTERFACE OC_InterfacePointsConnectivity_PointXiGet
    MODULE PROCEDURE OC_InterfacePointsConnectivity_PointXiGetNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_PointXiGetObj
  END INTERFACE OC_InterfacePointsConnectivity_PointXiGet

  !>Sets the coupled mesh element number that defines points connectivity
  INTERFACE OC_InterfacePointsConnectivity_ElementNumberSet
    MODULE PROCEDURE OC_InterfacePointsConnectivity_ElementNumberSetNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_ElementNumberSetObj
  END INTERFACE OC_InterfacePointsConnectivity_ElementNumberSet

  !>Sets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
  INTERFACE OC_InterfacePointsConnectivity_PointXiSet
    MODULE PROCEDURE OC_InterfacePointsConnectivity_PointXiSetNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_PointXiSetObj
  END INTERFACE OC_InterfacePointsConnectivity_PointXiSet

  !>Update points connectivity information with projection results
  INTERFACE OC_InterfacePointsConnectivity_UpdateFromProjection
    MODULE PROCEDURE OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_UpdateFromProjectionINumber
    MODULE PROCEDURE OC_InterfacePointsConnectivity_UpdateFromProjectionObj
  END INTERFACE OC_InterfacePointsConnectivity_UpdateFromProjection

  PUBLIC OC_Interface_MeshAdd

  PUBLIC OC_Interface_CreateFinish,OC_Interface_CreateStart

  PUBLIC OC_Interface_CoordinateSystemSet,OC_Interface_CoordinateSystemGet

  PUBLIC OC_Interface_Destroy

  PUBLIC OC_Interface_LabelGet,OC_Interface_LabelSet

  PUBLIC OC_Interface_NodesGet

  PUBLIC OC_InterfaceMeshConnectivity_CreateFinish,OC_InterfaceMeshConnectivity_CreateStart

  PUBLIC OC_InterfaceMeshConnectivity_Destroy,OC_InterfaceMeshConnectivity_BasisSet

  PUBLIC OC_InterfaceMeshConnectivity_ElementNumberSet,OC_InterfaceMeshConnectivity_ElementXiSet

  PUBLIC OC_InterfaceMeshConnectivity_NodeNumberSet

  PUBLIC OC_InterfacePointsConnectivity_CreateFinish,OC_InterfacePointsConnectivity_CreateStart

  PUBLIC OC_InterfacePointsConnectivity_Destroy

  PUBLIC OC_InterfacePointsConnectivity_ElementNumberGet,OC_InterfacePointsConnectivity_PointXiGet

  PUBLIC OC_InterfacePointsConnectivity_ElementNumberSet,OC_InterfacePointsConnectivity_PointXiSet

  PUBLIC OC_InterfacePointsConnectivity_UpdateFromProjection

  !==================================================================================================================================
  !
  ! INTERFACE_CONDITION_ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_InterfaceConditionConstants OpenCMISS::InterfaceConditions::Constants
  !> \brief Interface conditions constants.
  !>@{
  !> \addtogroup OpenCMISS_InterfaceConditionMethods OpenCMISS::InterfaceConditions::Constants::Methods
  !> \brief Interface condition methods.
  !> \see OpenCMISS::InterfaceConditions,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD = &
    & INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD !<Lagrange multipliers interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD = INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD !<Augmented Lagrange multiplers interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_PENALTY_METHOD = INTERFACE_CONDITION_PENALTY_METHOD !<Penalty interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_POINT_TO_POINT_METHOD = INTERFACE_CONDITION_POINT_TO_POINT_METHOD !<Point to point interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceConditionOperators OpenCMISS::InterfaceConditions::Constants::Operators
  !> \brief Interface condition operator types.
  !> \see OpenCMISS::InterfaceConditions,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR !<Continuous field operator, i.e., lambda.(u1_gauss-u2_gauss). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR !<Continuous field normal operator, i.e., lambda(u_1.n_1-u_2.n_2). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR= &
    & INTERFACE_CONDITION_FLS_CONTACT_OPERATOR !<Frictionless contact operator, i.e., lambda.(x_1.n-x_2.n). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR= &
    & INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR !<Frictionless contact operator, reproject at each newton iteration and has geometric linearisation terms i.e., lambda.(x_1.n-x_2.n). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR = INTERFACE_CONDITION_SOLID_FLUID_OPERATOR !<Solid fluid operator, i.e., lambda.(v_f-du_s/dt). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR = &
    & INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR !<Solid fluid normal operator, i.e., lambda(v_f.n_f-du_s/dt.n_s). \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceConditionOutputTypes OpenCMISS::InterfaceConditions::Constants::OutputTypes
  !> \brief Interface conditions output types
  !> \see OpenCMISS::InterfaceConditions,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_NO_OUTPUT = INTERFACE_CONDITION_NO_OUTPUT!<No output from the interface condition \see OpenCMISS_InterfaceConditionOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_PROGRESS_OUTPUT = INTERFACE_CONDITION_PROGRESS_OUTPUT !<Progress information output for the interface condition \see OpenCMISS_InterfaceConditionOutputTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceConditionIntegrationTypes OpenCMISS::InterfaceConditions::Constants::IntegrationTypes
  !> \brief Interface condition integration types.
  !> \see OpenCMISS::InterfaceConditions,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_GAUSS_INTEGRATION=INTERFACE_CONDITION_GAUSS_INTEGRATION !<Gauss points integration type, i.e. Loop over element Gauss points and sum up their contribution. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION=INTERFACE_CONDITION_DATA_POINTS_INTEGRATION !< Data points integration type i.e. Loop over data points and  sum up their contribution. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of an interface condition. \see OpenCMISS::OC_InterfaceCondition_CreateStart
  INTERFACE OC_InterfaceCondition_CreateFinish
    MODULE PROCEDURE OC_InterfaceCondition_CreateFinishNumber
    MODULE PROCEDURE OC_InterfaceCondition_CreateFinishObj
  END INTERFACE OC_InterfaceCondition_CreateFinish

  !>Starts the creation of an interface condition. \see OpenCMISS::OC_InterfaceCondition_CreateFinish
  INTERFACE OC_InterfaceCondition_CreateStart
    MODULE PROCEDURE OC_InterfaceCondition_CreateStartNumber
    MODULE PROCEDURE OC_InterfaceCondition_CreateStartObj
  END INTERFACE OC_InterfaceCondition_CreateStart

  !>Adds in a dependent variable to an interface condition.
  INTERFACE OC_InterfaceCondition_DependentVariableAdd
    MODULE PROCEDURE OC_InterfaceCondition_DependentVariableAddNumber
    MODULE PROCEDURE OC_InterfaceCondition_DependentVariableAddObj
  END INTERFACE OC_InterfaceCondition_DependentVariableAdd

  !>Destroys an interface condition.
  INTERFACE OC_InterfaceCondition_Destroy
    MODULE PROCEDURE OC_InterfaceCondition_DestroyNumber
    MODULE PROCEDURE OC_InterfaceCondition_DestroyObj
  END INTERFACE OC_InterfaceCondition_Destroy

  !>Finishes the creation of equations for an interface condition. \see OpenCMISS::OC_InterfaceCondition_EquationsCreateStart
  INTERFACE OC_InterfaceCondition_EquationsCreateFinish
    MODULE PROCEDURE OC_InterfaceCondition_EquationsCreateFinishNumber
    MODULE PROCEDURE OC_InterfaceCondition_EquationsCreateFinishObj
  END INTERFACE OC_InterfaceCondition_EquationsCreateFinish

  !>Starts the creation of equations for an interface condition. \see OpenCMISS::OC_InterfaceCondition_EquationsCreateFinish
  INTERFACE OC_InterfaceCondition_EquationsCreateStart
    MODULE PROCEDURE OC_InterfaceCondition_EquationsCreateStartNumber
    MODULE PROCEDURE OC_InterfaceCondition_EquationsCreateStartObj
  END INTERFACE OC_InterfaceCondition_EquationsCreateStart

  !>Destroys the interface equations for an interface condition.
  INTERFACE OC_InterfaceCondition_EquationsDestroy
    MODULE PROCEDURE OC_InterfaceCondition_EquationsDestroyNumber
    MODULE PROCEDURE OC_InterfaceCondition_EquationsDestroyObj
  END INTERFACE OC_InterfaceCondition_EquationsDestroy

  !>Returns the integration type for an interface condition.
  INTERFACE OC_InterfaceCondition_IntegrationTypeGet
    MODULE PROCEDURE OC_InterfaceCondition_IntegrationTypeGetNumber
    MODULE PROCEDURE OC_InterfaceCondition_IntegrationTypeGetObj
  END INTERFACE OC_InterfaceCondition_IntegrationTypeGet

  !>Sets/changes the integration type for an interface condition.
  INTERFACE OC_InterfaceCondition_IntegrationTypeSet
    MODULE PROCEDURE OC_InterfaceCondition_IntegrationTypeSetNumber
    MODULE PROCEDURE OC_InterfaceCondition_IntegrationTypeSetObj
  END INTERFACE OC_InterfaceCondition_IntegrationTypeSet

  !>Finishes the creation of a Lagrange multipliers field for an interface condition. \see OpenCMISS::OC_InterfaceCondition_LagrangeFieldCreateStart
  INTERFACE OC_InterfaceCondition_LagrangeFieldCreateFinish
    MODULE PROCEDURE OC_InterfaceCondition_LagrangeFieldCreateFinishNumber
    MODULE PROCEDURE OC_InterfaceCondition_LagrangeFieldCreateFinishObj
  END INTERFACE OC_InterfaceCondition_LagrangeFieldCreateFinish

  !>Starts the creation of a Lagrange multipliers field for an interface condition. \see OpenCMISS::OC_InterfaceCondition_LagrangeFieldCreateFinish
  INTERFACE OC_InterfaceCondition_LagrangeFieldCreateStart
    MODULE PROCEDURE OC_InterfaceCondition_LagrangeFieldCreateStartNumber
    MODULE PROCEDURE OC_InterfaceCondition_LagrangeFieldCreateStartObj
  END INTERFACE OC_InterfaceCondition_LagrangeFieldCreateStart

  !>Returns the label for an interface condition.
  INTERFACE OC_InterfaceCondition_LabelGet
    MODULE PROCEDURE OC_InterfaceCondition_LabelGetCNumber
    MODULE PROCEDURE OC_InterfaceCondition_LabelGetCObj
    MODULE PROCEDURE OC_InterfaceCondition_LabelGetVSNumber
    MODULE PROCEDURE OC_InterfaceCondition_LabelGetVSObj
  END INTERFACE OC_InterfaceCondition_LabelGet

  !>Sets/changes the label for an interface condition.
  INTERFACE OC_InterfaceCondition_LabelSet
    MODULE PROCEDURE OC_InterfaceCondition_LabelSetCNumber
    MODULE PROCEDURE OC_InterfaceCondition_LabelSetCObj
    MODULE PROCEDURE OC_InterfaceCondition_LabelSetVSNumber
    MODULE PROCEDURE OC_InterfaceCondition_LabelSetVSObj
  END INTERFACE OC_InterfaceCondition_LabelSet

  !>Gets the output type for an interface condition.
  INTERFACE OC_InterfaceCondition_OutputTypeGet
    MODULE PROCEDURE OC_InterfaceCondition_OutputTypeGetNumber
    MODULE PROCEDURE OC_InterfaceCondition_OutputTypeGetObj
  END INTERFACE OC_InterfaceCondition_OutputTypeGet

  !>Sets/changes the output type an equations set.
  INTERFACE OC_InterfaceCondition_OutputTypeSet
    MODULE PROCEDURE OC_InterfaceCondition_OutputTypeSetNumber
    MODULE PROCEDURE OC_InterfaceCondition_OutputTypeSetObj
  END INTERFACE OC_InterfaceCondition_OutputTypeSet

  !>Finishes the creation of a Penalty field for an interface condition. \see OpenCMISS::OC_InterfaceCondition_PenaltyFieldCreateStart
  INTERFACE OC_InterfaceCondition_PenaltyFieldCreateFinish
    MODULE PROCEDURE OC_InterfaceCondition_PenaltyFieldCreateFinishNumber
    MODULE PROCEDURE OC_InterfaceCondition_PenaltyFieldCreateFinishObj
  END INTERFACE OC_InterfaceCondition_PenaltyFieldCreateFinish

  !>Starts the creation of a Penalty field for an interface condition. \see OpenCMISS::OC_InterfaceCondition_PenaltyFieldCreateFinish
  INTERFACE OC_InterfaceCondition_PenaltyFieldCreateStart
    MODULE PROCEDURE OC_InterfaceCondition_PenaltyFieldCreateStartNumber
    MODULE PROCEDURE OC_InterfaceCondition_PenaltyFieldCreateStartObj
  END INTERFACE OC_InterfaceCondition_PenaltyFieldCreateStart

  !>Returns the method for an interface condition.
  INTERFACE OC_InterfaceCondition_MethodGet
    MODULE PROCEDURE OC_InterfaceCondition_MethodGetNumber
    MODULE PROCEDURE OC_InterfaceCondition_MethodGetObj
  END INTERFACE OC_InterfaceCondition_MethodGet

  !>Sets/changes the method for an interface condition.
  INTERFACE OC_InterfaceCondition_MethodSet
    MODULE PROCEDURE OC_InterfaceCondition_MethodSetNumber
    MODULE PROCEDURE OC_InterfaceCondition_MethodSetObj
  END INTERFACE OC_InterfaceCondition_MethodSet

  !>Returns the operator for an interface condition.
  INTERFACE OC_InterfaceCondition_OperatorGet
    MODULE PROCEDURE OC_InterfaceCondition_OperatorGetNumber
    MODULE PROCEDURE OC_InterfaceCondition_OperatorGetObj
  END INTERFACE OC_InterfaceCondition_OperatorGet

  !>Sets/changes the operator for an interface condition.
  INTERFACE OC_InterfaceCondition_OperatorSet
    MODULE PROCEDURE OC_InterfaceCondition_OperatorSetNumber
    MODULE PROCEDURE OC_InterfaceCondition_OperatorSetObj
  END INTERFACE OC_InterfaceCondition_OperatorSet

  PUBLIC OC_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,OC_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD, &
    & OC_INTERFACE_CONDITION_PENALTY_METHOD,OC_INTERFACE_CONDITION_POINT_TO_POINT_METHOD

  PUBLIC OC_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR,OC_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR, &
    & OC_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR,OC_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR, &
    & OC_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR,OC_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR

  PUBLIC OC_INTERFACE_CONDITION_GAUSS_INTEGRATION,OC_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION

  PUBLIC OC_INTERFACE_CONDITION_NO_OUTPUT,OC_INTERFACE_CONDITION_PROGRESS_OUTPUT

  PUBLIC OC_InterfaceCondition_CreateFinish,OC_InterfaceCondition_CreateStart

  PUBLIC OC_InterfaceCondition_DependentVariableAdd

  PUBLIC OC_InterfaceCondition_Destroy

  PUBLIC OC_InterfaceCondition_EquationsCreateFinish,OC_InterfaceCondition_EquationsCreateStart

  PUBLIC OC_InterfaceCondition_EquationsDestroy

  PUBLIC OC_InterfaceCondition_IntegrationTypeGet,OC_InterfaceCondition_IntegrationTypeSet

  PUBLIC OC_InterfaceCondition_LagrangeFieldCreateFinish,OC_InterfaceCondition_LagrangeFieldCreateStart

  PUBLIC OC_InterfaceCondition_LabelGet,OC_InterfaceCondition_LabelSet

  PUBLIC OC_InterfaceCondition_OutputTypeGet,OC_InterfaceCondition_OutputTypeSet

  PUBLIC OC_InterfaceCondition_PenaltyFieldCreateFinish,OC_InterfaceCondition_PenaltyFieldCreateStart

  PUBLIC OC_InterfaceCondition_MethodGet,OC_InterfaceCondition_MethodSet

  PUBLIC OC_InterfaceCondition_OperatorGet,OC_InterfaceCondition_OperatorSet

  !==================================================================================================================================
  !
  ! InterfaceEquationsRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_InterfaceEquationsConstants OpenCMISS::InterfaceEquations::Constants
  !> \brief Interface equations constants.
  !>@{
  !> \addtogroup OpenCMISS_InterfaceEquationsLinearityTypes OpenCMISS::InterfaceEquations::Constants::LinearityTypes
  !> \brief Interface equations linearity types.
  !> \see OpenCMISS::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_LINEAR = INTERFACE_EQUATIONS_LINEAR !<The interface equations are linear. \see OpenCMISS_InterfaceEquationsLinearity,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_NONLINEAR = INTERFACE_EQUATIONS_NONLINEAR !<The interface equations are nonlinear. \see OpenCMISS_InterfaceEquationsLinearity,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_NONLINEAR_BCS = INTERFACE_EQUATIONS_NONLINEAR_BCS !<The interface equations have nonlinear boundary conditions. \see OpenCMISS_InterfaceEquationsLinearity,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceEquationsOutputTypes OpenCMISS::InterfaceEquations::Constants::OutputTypes
  !> \brief The interface equations output types
  !> \see OpenCMISS::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_NO_OUTPUT=INTERFACE_EQUATIONS_NO_OUTPUT !<No output. \see OpenCMISS_InterfaceEquationsOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_TIMING_OUTPUT=INTERFACE_EQUATIONS_TIMING_OUTPUT !<Timing information output. \see 
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_MATRIX_OUTPUT=INTERFACE_EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see 
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT=INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OpenCMISS_InterfaceEquationsOutputTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceEquationsSparsityTypes OpenCMISS::InterfaceEquations::Constants::SparsityTypes
  !> \brief Interface equations matrices sparsity types
  !> \see OpenCMISS::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_SPARSE_MATRICES=INTERFACE_EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the interface equations. \see OpenCMISS_InterfaceEquationsSparsityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_FULL_MATRICES=INTERFACE_EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the interface equations. \see OpenCMISS_InterfaceEquationsSparsityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_InterfaceEquationsTimeDependenceTypes OpenCMISS::InterfaceEquations::Constants::TimeDependenceTypes
  !> \brief The interface equations time dependence type parameters
  !> \see OpenCMISS::InterfaceEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_STATIC=INTERFACE_EQUATIONS_STATIC !<The interface conditions are static and have no time dependence. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_QUASISTATIC=INTERFACE_EQUATIONS_QUASISTATIC !<The interface conditions are quasi-static. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_FIRST_ORDER_DYNAMIC=INTERFACE_EQUATIONS_FIRST_ORDER_DYNAMIC !<The interface conditions are first order dynamic. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_SECOND_ORDER_DYNAMIC=INTERFACE_EQUATIONS_SECOND_ORDER_DYNAMIC !<The interface conditions are a second order dynamic. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_EQUATIONS_TIME_STEPPING=INTERFACE_EQUATIONS_TIME_STEPPING !<The interface conditions are for time stepping. \see OpenCMISS_InterfaceEquationsTimeDependenceTypes,OpenCMISS
  !>@}
  !>@}  

  !Module types

  !Module variables

  !Interfaces

  !>Returns the linearity type for interface equations.
  INTERFACE OC_InterfaceEquations_LinearityTypeGet
    MODULE PROCEDURE OC_InterfaceEquations_LinearityTypeGetNumber
    MODULE PROCEDURE OC_InterfaceEquations_LinearityTypeGetObj
  END INTERFACE OC_InterfaceEquations_LinearityTypeGet

  !>Returns the interface matrix time dependence type for interface equations.
  INTERFACE OC_InterfaceEquations_MatrixTimeDependenceTypeGet
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1
  END INTERFACE OC_InterfaceEquations_MatrixTimeDependenceTypeGet

  !>Sets/changes the interface matrix time dependence type for interface equations.
  INTERFACE OC_InterfaceEquations_MatrixTimeDependenceTypeSet
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0
    MODULE PROCEDURE OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1
  END INTERFACE OC_InterfaceEquations_MatrixTimeDependenceTypeSet

  !>Returns the output type for interface equations.
  INTERFACE OC_InterfaceEquations_OutputTypeGet
    MODULE PROCEDURE OC_InterfaceEquations_OutputTypeGetNumber
    MODULE PROCEDURE OC_InterfaceEquations_OutputTypeGetObj
  END INTERFACE OC_InterfaceEquations_OutputTypeGet

  !>Sets/changes the output type for interface equations.
  INTERFACE OC_InterfaceEquations_OutputTypeSet
    MODULE PROCEDURE OC_InterfaceEquations_OutputTypeSetNumber
    MODULE PROCEDURE OC_InterfaceEquations_OutputTypeSetObj
  END INTERFACE OC_InterfaceEquations_OutputTypeSet

  !>Returns the sparsity for interface equations.
  INTERFACE OC_InterfaceEquations_SparsityGet
    MODULE PROCEDURE OC_InterfaceEquations_SparsityGetNumber
    MODULE PROCEDURE OC_InterfaceEquations_SparsityGetObj
  END INTERFACE OC_InterfaceEquations_SparsityGet

  !>Sets/changes the sparsity for interface equations.
  INTERFACE OC_InterfaceEquations_SparsitySet
    MODULE PROCEDURE OC_InterfaceEquations_SparsitySetNumber
    MODULE PROCEDURE OC_InterfaceEquations_SparsitySetObj
  END INTERFACE OC_InterfaceEquations_SparsitySet

  !>Returns the time dependence type for interface equations.
  INTERFACE OC_InterfaceEquations_TimeDependenceTypeGet
    MODULE PROCEDURE OC_InterfaceEquations_TimeDependenceTypeGetNumber
    MODULE PROCEDURE OC_InterfaceEquations_TimeDependenceTypeGetObj
  END INTERFACE OC_InterfaceEquations_TimeDependenceTypeGet

  PUBLIC OC_INTERFACE_EQUATIONS_LINEAR,OC_INTERFACE_EQUATIONS_NONLINEAR,OC_INTERFACE_EQUATIONS_NONLINEAR_BCS

  PUBLIC OC_INTERFACE_EQUATIONS_NO_OUTPUT,OC_INTERFACE_EQUATIONS_TIMING_OUTPUT,OC_INTERFACE_EQUATIONS_MATRIX_OUTPUT, &
    & OC_INTERFACE_EQUATIONS_ELEMENT_MATRIX_OUTPUT

  PUBLIC OC_INTERFACE_EQUATIONS_SPARSE_MATRICES,OC_INTERFACE_EQUATIONS_FULL_MATRICES

  PUBLIC OC_INTERFACE_EQUATIONS_STATIC,OC_INTERFACE_EQUATIONS_QUASISTATIC,OC_INTERFACE_EQUATIONS_FIRST_ORDER_DYNAMIC, &
    & OC_INTERFACE_EQUATIONS_SECOND_ORDER_DYNAMIC,OC_INTERFACE_EQUATIONS_TIME_STEPPING

  PUBLIC OC_InterfaceEquations_LinearityTypeGet

  PUBLIC OC_InterfaceEquations_MatrixTimeDependenceTypeGet,OC_InterfaceEquations_MatrixTimeDependenceTypeSet

  PUBLIC OC_InterfaceEquations_OutputTypeGet,OC_InterfaceEquations_OutputTypeSet

  PUBLIC OC_InterfaceEquations_SparsityGet,OC_InterfaceEquations_SparsitySet

  PUBLIC OC_InterfaceEquations_TimeDependenceTypeGet

  !==================================================================================================================================
  !
  ! INTERFACE MATRICES ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_InterfaceMatricesTimeDependenceTypes OpenCMISS::InterfaceMatrices::Constants::TimeDependenceTypes
  !> \brief Interface matrices time dependency types
  !> \see OpenCMISS::InterfaceMatrices::Constants,OpenCMISS::InterfaceMatrices
  !>@{
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_MATRIX_STATIC=INTERFACE_MATRIX_STATIC !<Interface matrix is of static type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_MATRIX_QUASI_STATIC=INTERFACE_MATRIX_QUASI_STATIC !<Interface matrix is of quasi-static type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC=INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC !<Interface matrix is of first order dynamic type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC=INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC !<Interface matrix is of second order dynamic type \see OpenCMISS_InterfaceMatricesTimeDependenceTypes,OpenCMISS
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC OC_INTERFACE_MATRIX_STATIC,OC_INTERFACE_MATRIX_QUASI_STATIC,OC_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC, &
    & OC_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC

  !==================================================================================================================================
  !
  ! MESH_ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_MeshConstants OpenCMISS::Mesh::Constants
  !> \brief Mesh constants.
  !>@{
  !> \addtogroup OpenCMISS_MeshBoundaryTypes OpenCMISS::Mesh::MeshBoundaryTypes
  !> \brief The boundary type parameters for a mesh domain
  !> \see OpenCMISS::Mesh,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_MESH_OFF_DOMAIN_BOUNDARY = MESH_OFF_DOMAIN_BOUNDARY !<The node/element is not on the mesh domain boundary \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MESH_ON_DOMAIN_BOUNDARY = MESH_ON_DOMAIN_BOUNDARY !<The node/element is on the mesh domain boundary \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces
  !>Finishes the creation of a mesh. \see OpenCMISS::OC_Mesh_CreateStart
  INTERFACE OC_Mesh_CreateFinish
    MODULE PROCEDURE OC_Mesh_CreateFinishNumber
    MODULE PROCEDURE OC_Mesh_CreateFinishObj
  END INTERFACE OC_Mesh_CreateFinish

  !>Starts the creation of a mesh. \see OpenCMISS::OC_Mesh_CreateFinish
  INTERFACE OC_Mesh_CreateStart
    MODULE PROCEDURE OC_Mesh_CreateStartNumber
    MODULE PROCEDURE OC_Mesh_CreateStartObj
    MODULE PROCEDURE OC_Mesh_CreateStartInterfaceObj
  END INTERFACE OC_Mesh_CreateStart

  !>Destroys a mesh.
  INTERFACE OC_Mesh_Destroy
    MODULE PROCEDURE OC_Mesh_DestroyNumber
    MODULE PROCEDURE OC_Mesh_DestroyObj
  END INTERFACE OC_Mesh_Destroy

  !>Returns the number of mesh components in a mesh.
  INTERFACE OC_Mesh_NumberOfComponentsGet
    MODULE PROCEDURE OC_Mesh_NumberOfComponentsGetNumber
    MODULE PROCEDURE OC_Mesh_NumberOfComponentsGetObj
  END INTERFACE OC_Mesh_NumberOfComponentsGet

  !>Sets/changes the number of mesh components in a mesh.
  INTERFACE OC_Mesh_NumberOfComponentsSet
    MODULE PROCEDURE OC_Mesh_NumberOfComponentsSetNumber
    MODULE PROCEDURE OC_Mesh_NumberOfComponentsSetObj
  END INTERFACE OC_Mesh_NumberOfComponentsSet

  !>Returns the number of elements in a mesh.
  INTERFACE OC_Mesh_NumberOfElementsGet
    MODULE PROCEDURE OC_Mesh_NumberOfElementsGetNumber
    MODULE PROCEDURE OC_Mesh_NumberOfElementsGetObj
  END INTERFACE OC_Mesh_NumberOfElementsGet

  !>Sets/changes the number of elements in a mesh.
  INTERFACE OC_Mesh_NumberOfElementsSet
    MODULE PROCEDURE OC_Mesh_NumberOfElementsSetNumber
    MODULE PROCEDURE OC_Mesh_NumberOfElementsSetObj
  END INTERFACE OC_Mesh_NumberOfElementsSet

  !>Sets/changes the surrounding elements calculate flag for the mesh.
  INTERFACE OC_Mesh_SurroundingElementsCalculateSet
    MODULE PROCEDURE OC_Mesh_SurroundingElementsCalculateSetNumber
    MODULE PROCEDURE OC_Mesh_SurroundingElementsCalculateSetObj
  END INTERFACE OC_Mesh_SurroundingElementsCalculateSet

  !>Sets/changes whether data points topology should be calculated for the decomposition.
  INTERFACE OC_Mesh_TopologyDataPointsCalculateProjection
    MODULE PROCEDURE OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber
    MODULE PROCEDURE OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber
    MODULE PROCEDURE OC_Mesh_TopologyDataPointsCalculateProjectionObj
  END INTERFACE OC_Mesh_TopologyDataPointsCalculateProjection

  !>Returns the basis for an element in a mesh.
  INTERFACE OC_MeshElements_BasisGet
    MODULE PROCEDURE OC_MeshElements_BasisGetNumber
    MODULE PROCEDURE OC_MeshElements_BasisGetObj
  END INTERFACE OC_MeshElements_BasisGet

  !>Sets/changes the basis for an element in a mesh.
  INTERFACE OC_MeshElements_BasisSet
    MODULE PROCEDURE OC_MeshElements_BasisSetNumber
    MODULE PROCEDURE OC_MeshElements_BasisSetObj
  END INTERFACE OC_MeshElements_BasisSet

  !>Returns the adjacent elements for a given element and adjacent xi direction for an element in a mesh.
  INTERFACE OC_MeshElements_AdjacentElementGet
    MODULE PROCEDURE OC_MeshElements_AdjacentElementGetNumber
    MODULE PROCEDURE OC_MeshElements_AdjacentElementGetObj
  END INTERFACE OC_MeshElements_AdjacentElementGet

  !>Finishes the creation of a mesh elements for a mesh component. \see OpenCMISS::OC_MeshElements_CreateStart
  INTERFACE OC_MeshElements_CreateFinish
    MODULE PROCEDURE OC_MeshElements_CreateFinishNumber
    MODULE PROCEDURE OC_MeshElements_CreateFinishObj
  END INTERFACE OC_MeshElements_CreateFinish

  !>Starts the creation of a mesh elements for a mesh component. \see OpenCMISS::OC_MeshElements_CreateFinish
  INTERFACE OC_MeshElements_CreateStart
    MODULE PROCEDURE OC_MeshElements_CreateStartNumber
    MODULE PROCEDURE OC_MeshElements_CreateStartObj
  END INTERFACE OC_MeshElements_CreateStart

  !>Gets the mesh boundary type for an element
  INTERFACE OC_MeshElements_ElementOnBoundaryGet
    MODULE PROCEDURE OC_MeshElements_ElementOnBoundaryGetNumber
    MODULE PROCEDURE OC_MeshElements_ElementOnBoundaryGetObj
  END INTERFACE OC_MeshElements_ElementOnBoundaryGet

  !>Get the mesh elements belonging to a mesh component.
  INTERFACE OC_Mesh_ElementsGet
    MODULE PROCEDURE OC_Mesh_ElementsGetNumber
    MODULE PROCEDURE OC_Mesh_ElementsGetObj
  END INTERFACE OC_Mesh_ElementsGet

  !>Returns the element nodes for an element in a mesh.
  INTERFACE OC_MeshElements_NodesGet
    MODULE PROCEDURE OC_MeshElements_NodesGetNumber
    MODULE PROCEDURE OC_MeshElements_NodesGetObj
  END INTERFACE OC_MeshElements_NodesGet

  !>Sets/changes the element nodes for an element in a mesh.
  INTERFACE OC_MeshElements_NodesSet
    MODULE PROCEDURE OC_MeshElements_NodesSetNumber
    MODULE PROCEDURE OC_MeshElements_NodesSetObj
  END INTERFACE OC_MeshElements_NodesSet

  !>Sets/changes a user node's derivative version for an element in a mesh.
  INTERFACE OC_MeshElements_UserNodeVersionSet
    MODULE PROCEDURE OC_MeshElements_UserNodeVersionSetNumber
    MODULE PROCEDURE OC_MeshElements_UserNodeVersionSetObj
  END INTERFACE OC_MeshElements_UserNodeVersionSet

  !>Sets/changes a local element's node derivative version for an element in a mesh.
  INTERFACE OC_MeshElements_LocalElementNodeVersionSet
    MODULE PROCEDURE OC_MeshElements_LocalElementNodeVersionSetNumber
    MODULE PROCEDURE OC_MeshElements_LocalElementNodeVersionSetObj
  END INTERFACE OC_MeshElements_LocalElementNodeVersionSet

  !>Returns the element user number for an element in a mesh.
  INTERFACE OC_MeshElements_UserNumberGet
    MODULE PROCEDURE OC_MeshElements_UserNumberGetNumber
    MODULE PROCEDURE OC_MeshElements_UserNumberGetObj
  END INTERFACE OC_MeshElements_UserNumberGet

  !>Sets/changes the element user number for an element in a mesh.
  INTERFACE OC_MeshElements_UserNumberSet
    MODULE PROCEDURE OC_MeshElements_UserNumberSetNumber
    MODULE PROCEDURE OC_MeshElements_UserNumberSetObj
  END INTERFACE OC_MeshElements_UserNumberSet

  !>Sets/changes the element user numbers for all element in a mesh.
  INTERFACE OC_MeshElements_UserNumbersAllSet
    MODULE PROCEDURE OC_MeshElements_UserNumbersAllSetNumber
    MODULE PROCEDURE OC_MeshElements_UserNumbersAllSetObj
  END INTERFACE OC_MeshElements_UserNumbersAllSet

  !>Returns true if the given node is in the given mesh component.
  INTERFACE OC_Mesh_NodeExists
    MODULE PROCEDURE OC_Mesh_NodeExistsNumber
    MODULE PROCEDURE OC_Mesh_NodeExistsObj
  END INTERFACE OC_Mesh_NodeExists

  !>Returns true if the given element is in the given mesh component.
  INTERFACE OC_Mesh_ElementExists
    MODULE PROCEDURE OC_Mesh_ElementExistsNumber
    MODULE PROCEDURE OC_Mesh_ElementExistsObj
  END INTERFACE OC_Mesh_ElementExists

  !>Get the mesh nodes belonging to a mesh component.
  INTERFACE OC_Mesh_NodesGet
    MODULE PROCEDURE OC_Mesh_NodesGetNumber
    MODULE PROCEDURE OC_Mesh_NodesGetObj
  END INTERFACE OC_Mesh_NodesGet

  !>Get the mesh boundary type for a node.
  INTERFACE OC_MeshNodes_NodeOnBoundaryGet
    MODULE PROCEDURE OC_MeshNodes_NodeOnBoundaryGetNumber
    MODULE PROCEDURE OC_MeshNodes_NodeOnBoundaryGetObj
  END INTERFACE OC_MeshNodes_NodeOnBoundaryGet

  !>Returns the number of derivatives for a node in a mesh.
  INTERFACE OC_MeshNodes_NumberOfDerivativesGet
    MODULE PROCEDURE OC_MeshNodes_NumberOfDerivativesGetNumber
    MODULE PROCEDURE OC_MeshNodes_NumberOfDerivativesGetObj
  END INTERFACE OC_MeshNodes_NumberOfDerivativesGet

  !>Returns the derivatives for a node in a mesh.
  INTERFACE OC_MeshNodes_DerivativesGet
    MODULE PROCEDURE OC_MeshNodes_DerivativesGetNumber
    MODULE PROCEDURE OC_MeshNodes_DerivativesGetObj
  END INTERFACE OC_MeshNodes_DerivativesGet

  !>Returns the number of versions for a derivative at a node in a mesh.
  INTERFACE OC_MeshNodes_NumberOfVersionsGet
    MODULE PROCEDURE OC_MeshNodes_NumberOfVersionsGetNumber
    MODULE PROCEDURE OC_MeshNodes_NumberOfVersionsGetObj
  END INTERFACE OC_MeshNodes_NumberOfVersionsGet

  !>Returns the number of nodes in a mesh.
  INTERFACE OC_MeshNodes_NumberOfNodesGet
    MODULE PROCEDURE OC_MeshNodes_NumberOfNodesGetNumber
    MODULE PROCEDURE OC_MeshNodes_NumberOfNodesGetObj
  END INTERFACE OC_MeshNodes_NumberOfNodesGet

  PUBLIC OC_MESH_OFF_DOMAIN_BOUNDARY,OC_MESH_ON_DOMAIN_BOUNDARY

  PUBLIC OC_Mesh_CreateFinish,OC_Mesh_CreateStart

  PUBLIC OC_Mesh_Destroy

  PUBLIC OC_Mesh_NumberOfComponentsGet,OC_Mesh_NumberOfComponentsSet

  PUBLIC OC_Mesh_NumberOfElementsGet,OC_Mesh_NumberOfElementsSet

  PUBLIC OC_MeshElements_BasisGet,OC_MeshElements_BasisSet

  PUBLIC OC_MeshElements_AdjacentElementGet

  PUBLIC OC_MeshElements_ElementOnBoundaryGet

  PUBLIC OC_MeshElements_UserNodeVersionSet,OC_MeshElements_LocalElementNodeVersionSet

  PUBLIC OC_MeshElements_CreateFinish,OC_MeshElements_CreateStart

  PUBLIC OC_MeshElements_NodesGet,OC_MeshElements_NodesSet

  PUBLIC OC_MeshElements_UserNumberGet,OC_MeshElements_UserNumberSet

  PUBLIC OC_MeshElements_UserNumbersAllSet

  PUBLIC OC_MeshNodes_NodeOnBoundaryGet

  PUBLIC OC_MeshNodes_NumberOfDerivativesGet,OC_MeshNodes_DerivativesGet

  PUBLIC OC_MeshNodes_NumberOfVersionsGet

  PUBLIC OC_MeshNodes_NumberOfNodesGet

  PUBLIC OC_Mesh_ElementsGet

  PUBLIC OC_Mesh_NodesGet

  PUBLIC OC_Mesh_NodeExists,OC_Mesh_ElementExists

  PUBLIC OC_Mesh_SurroundingElementsCalculateSet

  PUBLIC OC_Mesh_TopologyDataPointsCalculateProjection

  !==================================================================================================================================
  !
  ! DecompositionRoutines
  !
  !==================================================================================================================================

  !> \addtogroup OpenCMISS_DecomposerConstants OpenCMISS::Decomposer::Constants
  !> \brief Decomposer constants.
  !>@{
  !> \addtogroup OpenCMISS_DecomposerOutputTypes  OpenCMISS::Decomposer::DecomposerOutputTypes
  !> \brief The Decomposer output type parameters
  !> \see OpenCMISS::Decomposer,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_DECOMPOSER_NO_OUTPUT=DECOMPOSER_NO_OUTPUT !<No decomposer output. \see OpenCMISS_DecomposerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DECOMPOSER_TIMING_OUTPUT=DECOMPOSER_TIMING_OUTPUT !<Timing decomposer output. \see OpenCMISS_DecomposerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DECOMPOSER_ALL_OUTPUT=DECOMPOSER_ALL_OUTPUT !<All decomposer output. \see OpenCMISS_DecomposerTypes,OpenCMISS
  !>@}
  !>@}

  !> \addtogroup OpenCMISS_DecompositionConstants OpenCMISS::Decomposition::Constants
  !> \brief Decomposition constants.
  !>@{
  !> \addtogroup OpenCMISS_DecompositionTypes OpenCMISS::Decomposition::DecompositionTypes
  !> \brief The Decomposition types parameters
  !> \see OpenCMISS::Decomposition,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_DECOMPOSITION_ALL_TYPE = DECOMPOSITION_ALL_TYPE !<The decomposition contains all elements. \see OpenCMISS_DecompositionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DECOMPOSITION_CALCULATED_TYPE = DECOMPOSITION_CALCULATED_TYPE !<The element decomposition is calculated by graph partitioning. \see OpenCMISS_DecompositionTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_DECOMPOSITION_USER_DEFINED_TYPE = DECOMPOSITION_USER_DEFINED_TYPE !<The user will set the element decomposition. \see OpenCMISS_DecompositionTypes,OpenCMISS
  !>@}
  !>@}

  !>Finishes the creation of a decomposer. \see OpenCMISS::OC_Decomposer_CreateStart
  INTERFACE OC_Decomposer_CreateFinish
    MODULE PROCEDURE OC_Decomposer_CreateFinishNumber
    MODULE PROCEDURE OC_Decomposer_CreateFinishObj
  END INTERFACE OC_Decomposer_CreateFinish

  !>Start the creation of a decomposer. \see OpenCMISS::OC_Decomposer_CreateFinish
  INTERFACE OC_Decomposer_CreateStart
    MODULE PROCEDURE OC_Decomposer_CreateStartNumber
    MODULE PROCEDURE OC_Decomposer_CreateStartObj
  END INTERFACE OC_Decomposer_CreateStart

  !>Adds a decomposition to a decomposer.
  INTERFACE OC_Decomposer_DecompositionAdd
    MODULE PROCEDURE OC_Decomposer_DecompositionAddNumber
    MODULE PROCEDURE OC_Decomposer_DecompositionAddObj
  END INTERFACE OC_Decomposer_DecompositionAdd

  !>Destroys a decomposer.
  INTERFACE OC_Decomposer_Destroy
    MODULE PROCEDURE OC_Decomposer_DestroyNumber
    MODULE PROCEDURE OC_Decomposer_DestroyObj
  END INTERFACE OC_Decomposer_Destroy

  !>Returns the output type for a decomposer.
  INTERFACE OC_Decomposer_OutputTypeGet
    MODULE PROCEDURE OC_Decomposer_OutputTypeGetNumber
    MODULE PROCEDURE OC_Decomposer_OutputTypeGetObj
  END INTERFACE OC_Decomposer_OutputTypeGet

  !>Sets/changes the output type for a decomposer.
  INTERFACE OC_Decomposer_OutputTypeSet
    MODULE PROCEDURE OC_Decomposer_OutputTypeSetNumber
    MODULE PROCEDURE OC_Decomposer_OutputTypeSetObj
  END INTERFACE OC_Decomposer_OutputTypeSet

  !>Finishes the creation of a domain decomposition. \see OpenCMISS::OC_Decomposition_CreateStart
  INTERFACE OC_Decomposition_CreateFinish
    MODULE PROCEDURE OC_Decomposition_CreateFinishNumber
    MODULE PROCEDURE OC_Decomposition_CreateFinishObj
  END INTERFACE OC_Decomposition_CreateFinish

  !>Start the creation of a domain decomposition for a given mesh. \see OpenCMISS::OC_Decomposition_CreateFinish
  INTERFACE OC_Decomposition_CreateStart
    MODULE PROCEDURE OC_Decomposition_CreateStartNumber
    MODULE PROCEDURE OC_Decomposition_CreateStartObj
  END INTERFACE OC_Decomposition_CreateStart

  !>Destroys a domain decomposition.
  INTERFACE OC_Decomposition_Destroy
    MODULE PROCEDURE OC_Decomposition_DestroyNumber
    MODULE PROCEDURE OC_Decomposition_DestroyObj
  END INTERFACE OC_Decomposition_Destroy

  !>Returns a domain of a decomposition.
  INTERFACE OC_Decomposition_DomainGet
    MODULE PROCEDURE OC_Decomposition_DomainGetNumber
    MODULE PROCEDURE OC_Decomposition_DomainGetObj
  END INTERFACE OC_Decomposition_DomainGet

  ! !>Calculates the element domains for the decomposition of a mesh.
  ! INTERFACE OC_Decomposition_ElementDomainCalculate
  !   MODULE PROCEDURE OC_Decomposition_ElementDomainCalculateNumber
  !   MODULE PROCEDURE OC_Decomposition_ElementDomainCalculateObj
  ! END INTERFACE OC_Decomposition_ElementDomainCalculate

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementDomainGet
    MODULE PROCEDURE OC_Decomposition_ElementDomainGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementDomainGetObj
  END INTERFACE OC_Decomposition_ElementDomainGet

  !>Sets/changes the domain for a given element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementDomainSet
    MODULE PROCEDURE OC_Decomposition_ElementDomainSetNumber
    MODULE PROCEDURE OC_Decomposition_ElementDomainSetObj
  END INTERFACE OC_Decomposition_ElementDomainSet

  !>Returns the local element number for a given user element number in a decomposition.
  INTERFACE OC_Decomposition_ElementLocalNumberGet
    MODULE PROCEDURE OC_Decomposition_ElementLocalNumberGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementLocalNumberGetObj
  END INTERFACE OC_Decomposition_ELementLocalNumberGet
  
  !>Returns the user element number for a given (local) element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementNumberGet
    MODULE PROCEDURE OC_Decomposition_ElementNumberGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementNumberGetObj
  END INTERFACE OC_Decomposition_ElementNumberGet

  !>Returns the mesh component number used for the decomposition of a mesh.
  INTERFACE OC_Decomposition_MeshComponentGet
    MODULE PROCEDURE OC_Decomposition_MeshComponentGetNumber
    MODULE PROCEDURE OC_Decomposition_MeshComponentGetObj
  END INTERFACE OC_Decomposition_MeshComponentGet

  !>Sets/changes the mesh component number used for the decomposition of a mesh.
  INTERFACE OC_Decomposition_MeshComponentSet
    MODULE PROCEDURE OC_Decomposition_MeshComponentSetNumber
    MODULE PROCEDURE OC_Decomposition_MeshComponentSetObj
  END INTERFACE OC_Decomposition_MeshComponentSet

  !>Returns the local node number for a given user node number in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NodeLocalNumberGet
    MODULE PROCEDURE OC_Decomposition_NodeLocalNumberGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeLocalNumberGetObj
  END INTERFACE OC_Decomposition_NodeLocalNumberGet
  
  !>Returns the user node number for a given (local) node in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NodeNumberGet
    MODULE PROCEDURE OC_Decomposition_NodeNumberGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeNumberGetObj
  END INTERFACE OC_Decomposition_NodeNumberGet
  
  !>Returns the number of (local+ghost) elements in a decomposition of a mesh.
  INTERFACE OC_Decomposition_NumberOfElementsGet
    MODULE PROCEDURE OC_Decomposition_NumberOfElementsGetNumber
    MODULE PROCEDURE OC_Decomposition_NumberOfElementsGetObj
  END INTERFACE OC_Decomposition_NumberOfElementsGet
  
  !>Returns the number of ghost elements in a decomposition of a mesh.
  INTERFACE OC_Decomposition_NumberOfGhostElementsGet
    MODULE PROCEDURE OC_Decomposition_NumberOfGhostElementsGetNumber
    MODULE PROCEDURE OC_Decomposition_NumberOfGhostElementsGetObj
  END INTERFACE OC_Decomposition_NumberOfGhostElementsGet
  
  !>Returns the number of ghost nodes in a decomposition of a mesh component
  INTERFACE OC_Decomposition_NumberOfGhostNodesGet
    MODULE PROCEDURE OC_Decomposition_NumberOfGhostNodesGetNumber
    MODULE PROCEDURE OC_Decomposition_NumberOfGhostNodesGetObj
  END INTERFACE OC_Decomposition_NumberOfGhostNodesGet
  
  !>Returns the number of local elements in a decomposition of a mesh.
  INTERFACE OC_Decomposition_NumberOfLocalElementsGet
    MODULE PROCEDURE OC_Decomposition_NumberOfLocalElementsGetNumber
    MODULE PROCEDURE OC_Decomposition_NumberOfLocalElementsGetObj
  END INTERFACE OC_Decomposition_NumberOfLocalElementsGet
  
  !>Returns the number of local nodes in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NumberOfLocalNodesGet
    MODULE PROCEDURE OC_Decomposition_NumberOfLocalNodesGetNumber
    MODULE PROCEDURE OC_Decomposition_NumberOfLocalNodesGetObj
  END INTERFACE OC_Decomposition_NumberOfLocalNodesGet
  
  !>Returns the number of (local+ghost) nodes in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NumberOfNodesGet
    MODULE PROCEDURE OC_Decomposition_NumberOfNodesGetNumber
    MODULE PROCEDURE OC_Decomposition_NumberOfNodesGetObj
  END INTERFACE OC_Decomposition_NumberOfNodesGet

  !>Returns the topology of a decomposition.
  INTERFACE OC_Decomposition_TopologyGet
    MODULE PROCEDURE OC_Decomposition_TopologyGetNumber
    MODULE PROCEDURE OC_Decomposition_TopologyGetObj
  END INTERFACE OC_Decomposition_TopologyGet

  !>Returns the type of decomposition.
  INTERFACE OC_Decomposition_TypeGet
    MODULE PROCEDURE OC_Decomposition_TypeGetNumber
    MODULE PROCEDURE OC_Decomposition_TypeGetObj
  END INTERFACE OC_Decomposition_TypeGet

  !>Sets/changes the type of decomposition.
  INTERFACE OC_Decomposition_TypeSet
    MODULE PROCEDURE OC_Decomposition_TypeSetNumber
    MODULE PROCEDURE OC_Decomposition_TypeSetObj
  END INTERFACE OC_Decomposition_TypeSet

  !>Sets/changes the work group for a decomposition.
  INTERFACE OC_Decomposition_WorkGroupSet
    MODULE PROCEDURE OC_Decomposition_WorkGroupSetNumber
    MODULE PROCEDURE OC_Decomposition_WorkGroupSetObj
  END INTERFACE OC_Decomposition_WorkGroupSet

  !>Sets/changes whether lines should be calculated for the decomposition.
  INTERFACE OC_Decomposition_CalculateLinesSet
    MODULE PROCEDURE OC_Decomposition_CalculateLinesSetNumber
    MODULE PROCEDURE OC_Decomposition_CalculateLinesSetObj
  END INTERFACE OC_Decomposition_CalculateLinesSet

  !>Sets/changes whether faces should be calculated for the decomposition.
  INTERFACE OC_Decomposition_CalculateFacesSet
    MODULE PROCEDURE OC_Decomposition_CalculateFacesSetNumber
    MODULE PROCEDURE OC_Decomposition_CalculateFacesSetObj
  END INTERFACE OC_Decomposition_CalculateFacesSet

  !>Returns the adjacent element for a given element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementAdjacentElementGet
    MODULE PROCEDURE OC_Decomposition_ElementAdjacentElementGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementAdjacentElementGetObj
  END INTERFACE OC_Decomposition_ElementAdjacentElementGet

  !>Returns the basis for a given element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementBasisGet
    MODULE PROCEDURE OC_Decomposition_ElementBasisGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementBasisGetObj
  END INTERFACE OC_Decomposition_ElementBasisGet

  !>Returns the number of adjacent elements for a given element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementNumberOfAdjacentGet
    MODULE PROCEDURE OC_Decomposition_ElementNumberOfAdjacentGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementNumberOfAdjacentGetObj
  END INTERFACE OC_Decomposition_ElementNumberOfAdjacentGet

  !>Returns the number of nodes for a given element in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_ElementNodeGet
    MODULE PROCEDURE OC_Decomposition_ElementNodeGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementNodeGetObj
  END INTERFACE OC_Decomposition_ElementNodeGet

  !>Returns the basis for a given element in a decomposition of a mesh.
  INTERFACE OC_Decomposition_ElementOnBoundaryGet
    MODULE PROCEDURE OC_Decomposition_ElementOnBoundaryGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementOnBoundaryGetObj
  END INTERFACE OC_Decomposition_ElementOnBoundaryGet

  !>Returns the version number used for a derivative of a node in a element of a decomposed mesh component.
  INTERFACE OC_Decomposition_ElementVersionGet
    MODULE PROCEDURE OC_Decomposition_ElementVersionGetNumber
    MODULE PROCEDURE OC_Decomposition_ElementVersionGetObj
  END INTERFACE OC_Decomposition_ElementVersionGet

  !>Returns the domain for a given node in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NodeDomainGet
    MODULE PROCEDURE OC_Decomposition_NodeDomainGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeDomainGetObj
  END INTERFACE OC_Decomposition_NodeDomainGet
  
  !>Returns the global derivative index for a given local derivative of node in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NodeGlobalDerivativeGet
    MODULE PROCEDURE OC_Decomposition_NodeGlobalDerivativeGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeGlobalDerivativeGetObj
  END INTERFACE OC_Decomposition_NodeGlobalDerivativeGet
  
  !>Returns the number of derivatives for a node in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NodeNumberOfDerivativesGet
    MODULE PROCEDURE OC_Decomposition_NodeNumberOfDerivativesGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeNumberOfDerivativesGetObj
  END INTERFACE OC_Decomposition_NodeNumberOfDerivativesGet
  
  !>Returns the number of elements surrounding a node in a decomposition of a mesh.
  INTERFACE OC_Decomposition_NodeNumberOfSurroundingElementsGet
    MODULE PROCEDURE OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeNumberOfSurroundingElementsGetObj
  END INTERFACE OC_Decomposition_NodeNumberOfSurroundingElementsGet

  !>Returns the number of elements surrounding a node in a decomposition of a mesh.
  INTERFACE OC_Decomposition_NodeNumberOfVersionsGet
    MODULE PROCEDURE OC_Decomposition_NodeNumberOfVersionsGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeNumberOfVersionsGetObj
  END INTERFACE OC_Decomposition_NodeNumberOfVersionsGet

  !>Returns whether or not a given node in a decomposition of a mesh component is on the boundary of the mesh.
  INTERFACE OC_Decomposition_NodeOnBoundaryGet
    MODULE PROCEDURE OC_Decomposition_NodeOnBoundaryGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeOnBoundaryGetObj
  END INTERFACE OC_Decomposition_NodeOnBoundaryGet

  !>Returns the partial derivative index for a given local derivative of node in a decomposition of a mesh component.
  INTERFACE OC_Decomposition_NodePartialDerivativeGet
    MODULE PROCEDURE OC_Decomposition_NodePartialDerivativeGetNumber
    MODULE PROCEDURE OC_Decomposition_NodePartialDerivativeGetObj
  END INTERFACE OC_Decomposition_NodePartialDerivativeGet
  
  !>Returns an element surrounding a node in a decomposition of a mesh.
  INTERFACE OC_Decomposition_NodeSurroundingElementGet
    MODULE PROCEDURE OC_Decomposition_NodeSurroundingElementGetNumber
    MODULE PROCEDURE OC_Decomposition_NodeSurroundingElementGetObj
  END INTERFACE OC_Decomposition_NodeSurroundingElementGet

  !>Calculates the decomposition topology for data points .
  INTERFACE OC_Decomposition_DataProjectionCalculate
    MODULE PROCEDURE OC_Decomposition_DataProjectionCalculateObj
  END INTERFACE OC_Decomposition_DataProjectionCalculate

  !>Gets the local data point number for data points projected on an element
  INTERFACE OC_Decomposition_ElementDataPointLocalNumberGet
    MODULE PROCEDURE OC_Decomposition_ElementDataPointLocalNumberGetObj
  END INTERFACE OC_Decomposition_ElementDataPointLocalNumberGet

  !>Gets the user data point number for data points projected on an element
  INTERFACE OC_Decomposition_ElementDataPointUserNumberGet
    MODULE PROCEDURE OC_Decomposition_ElementDataPointUserNumberGetObj
  END INTERFACE OC_Decomposition_ElementDataPointUserNumberGet

  !>Gets the number of data points projected on an element
  INTERFACE OC_Decomposition_ElementNumberOfDataPointsGet
    MODULE PROCEDURE OC_Decomposition_ElementNumberOfDataPointsGetObj
  END INTERFACE OC_Decomposition_ElementNumberOfDataPointsGet

  !>Returns a decomposition element
  INTERFACE OC_DecompositionElements_ElementGet
    MODULE PROCEDURE OC_DecompositionElements_ElementGetObj
  END INTERFACE OC_DecompositionElements_ElementGet

  !>Returns a decomposition face
  !INTERFACE OC_DecompositionFaces_FaceGet
  !  MODULE PROCEDURE OC_DecompositionFaces_FaceGetObj
  !END INTERFACE OC_DecompositionFaces_FaceGet

  !>Returns a decomposition line
  !INTERFACE OC_DecompositionLines_LineGet
  !  MODULE PROCEDURE OC_DecompositionLines_LineGetObj
  !END INTERFACE OC_DecompositionLines_LineGet

  !>Returns the decomposition elements of a decomposition toplogy.
  INTERFACE OC_DecompositionTopology_ElementsGet
    MODULE PROCEDURE OC_DecompositionTopology_ElementsGetNumber
    MODULE PROCEDURE OC_DecompositionTopology_ElementsGetObj
  END INTERFACE OC_DecompositionTopology_ElementsGet

  !>Returns the decomposition faces of a decomposition toplogy.
  INTERFACE OC_DecompositionTopology_FacesGet
    MODULE PROCEDURE OC_DecompositionTopology_FacesGetNumber
    MODULE PROCEDURE OC_DecompositionTopology_FacesGetObj
  END INTERFACE OC_DecompositionTopology_FacesGet

  !>Returns the decomposition lines of a decomposition toplogy.
  INTERFACE OC_DecompositionTopology_LinesGet
    MODULE PROCEDURE OC_DecompositionTopology_LinesGetNumber
    MODULE PROCEDURE OC_DecompositionTopology_LinesGetObj
  END INTERFACE OC_DecompositionTopology_LinesGet

  PUBLIC OC_DECOMPOSER_NO_OUTPUT,OC_DECOMPOSER_TIMING_OUTPUT,OC_DECOMPOSER_ALL_OUTPUT

  PUBLIC OC_DECOMPOSITION_ALL_TYPE,OC_DECOMPOSITION_CALCULATED_TYPE,OC_DECOMPOSITION_USER_DEFINED_TYPE

  PUBLIC OC_Decomposer_CreateFinish,OC_Decomposer_CreateStart

  PUBLIC OC_Decomposer_DecompositionAdd

  PUBLIC OC_Decomposer_Destroy

  PUBLIC OC_Decomposer_OutputTypeGet,OC_Decomposer_OutputTypeSet

  PUBLIC OC_Decomposition_CreateFinish,OC_Decomposition_CreateStart

  PUBLIC OC_Decomposition_CalculateFacesSet,OC_Decomposition_CalculateLinesSet

  PUBLIC OC_Decomposition_Destroy

  PUBLIC OC_Decomposition_DataProjectionCalculate

  PUBLIC OC_Decomposition_DomainGet

  PUBLIC OC_Decomposition_ElementAdjacentElementGet

  PUBLIC OC_Decomposition_ElementBasisGet
  
  PUBLIC OC_Decomposition_ElementDataPointLocalNumberGet

  PUBLIC OC_Decomposition_ElementDataPointUserNumberGet

  !PUBLIC OC_Decomposition_ElementDomainCalculate

  PUBLIC OC_Decomposition_ElementDomainGet,OC_Decomposition_ElementDomainSet

  PUBLIC OC_Decomposition_ElementLocalNumberGet

  PUBLIC OC_Decomposition_ElementNodeGet

  PUBLIC OC_Decomposition_ElementNumberGet

  PUBLIC OC_Decomposition_ElementNumberOfAdjacentGet
  
  PUBLIC OC_Decomposition_ElementNumberOfDataPointsGet
  
  PUBLIC OC_Decomposition_ElementOnBoundaryGet

  PUBLIC OC_Decomposition_ElementVersionGet

  PUBLIC OC_Decomposition_MeshComponentGet,OC_Decomposition_MeshComponentSet

  PUBLIC OC_Decomposition_NodeDomainGet

  PUBLIC OC_Decomposition_NodeGlobalDerivativeGet

  PUBLIC OC_Decomposition_NodeLocalNumberGet
  
  PUBLIC OC_Decomposition_NodeNumberGet

  PUBLIC OC_Decomposition_NodeNumberOfDerivativesGet
  
  PUBLIC OC_Decomposition_NodeNumberOfVersionsGet

  PUBLIC OC_Decomposition_NodeNumberOfSurroundingElementsGet

  PUBLIC OC_Decomposition_NodeOnBoundaryGet

  PUBLIC OC_Decomposition_NodePartialDerivativeGet
  
  PUBLIC OC_Decomposition_NodeSurroundingElementGet
  
  PUBLIC OC_Decomposition_NumberOfElementsGet

  PUBLIC OC_Decomposition_NumberOfGhostElementsGet

  PUBLIC OC_Decomposition_NumberOfGhostNodesGet

  PUBLIC OC_Decomposition_NumberOfLocalElementsGet

  PUBLIC OC_Decomposition_NumberOfLocalNodesGet

  PUBLIC OC_Decomposition_NumberOfNodesGet

  PUBLIC OC_Decomposition_TopologyGet

  PUBLIC OC_Decomposition_TypeGet,OC_Decomposition_TypeSet

  PUBLIC OC_Decomposition_WorkGroupSet

  PUBLIC OC_DecompositionElements_ElementGet

  !PUBLIC OC_DecompositionFaces_FaceGet

  !PUBLIC OC_DecompositionLines_LineGet

  PUBLIC OC_DecompositionTopology_ElementsGet

  PUBLIC OC_DecompositionTopology_FacesGet

  PUBLIC OC_DecompositionTopology_LinesGet

  !==================================================================================================================================
  !
  ! DistributedMatrixVector
  !
  !==================================================================================================================================

  !> \addtogroup OpenCMISS_MatrixVectorConstants OpenCMISS::MatrixVector::Constants
  !> \brief Distributed matrix and vector function constants.
  !>@{
  !> \addtogroup OpenCMISS_MatrixStorageTypes OpenCMISS::MatrixVector::MatrixStorageTypes
  !> \brief Type of matrix storage.
  !> \see OpenCMISS::MatrixVectorConstants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_MATRIX_BLOCK_STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE !<Distributed matrix block storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_DIAGONAL_STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE !<Distributed matrix diagonal storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_COLUMN_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE !<Distributed matrix column major storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_ROW_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE !<Distributed matrix row major storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_COMPRESSED_ROW_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE !<Distributed matrix compressed row storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE !<Distributed matrix compressed column storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_ROW_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE !<Distributed matrix row-column storage type \see OpenCMISS_MatrixStorageTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_MatrixVectorDataTypes OpenCMISS::MatrixVector::DataTypes
  !> \brief Type of data stored in matrices and vectors.
  !> \see OpenCMISS::MatrixVectorConstants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_MATRIX_VECTOR_INTG_TYPE=DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE !<Integer distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_VECTOR_SP_TYPE=DISTRIBUTED_MATRIX_VECTOR_SP_TYPE !<Single precision real distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_VECTOR_DP_TYPE=DISTRIBUTED_MATRIX_VECTOR_DP_TYPE !<Double precision real distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_MATRIX_VECTOR_L_TYPE=DISTRIBUTED_MATRIX_VECTOR_L_TYPE !<Logical distributed matrix-vector data type \see OpenCMISS_MatrixVectorDataTypes,OpenCMISS
  !>@}
  !>@}

  PUBLIC OC_MATRIX_BLOCK_STORAGE_TYPE,OC_MATRIX_DIAGONAL_STORAGE_TYPE,OC_MATRIX_COLUMN_MAJOR_STORAGE_TYPE, &
    & OC_MATRIX_ROW_MAJOR_STORAGE_TYPE,OC_MATRIX_COMPRESSED_ROW_STORAGE_TYPE,OC_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE, &
    & OC_MATRIX_ROW_COLUMN_STORAGE_TYPE

  PUBLIC OC_MATRIX_VECTOR_INTG_TYPE,OC_MATRIX_VECTOR_SP_TYPE,OC_MATRIX_VECTOR_DP_TYPE,OC_MATRIX_VECTOR_L_TYPE

  !Note that currently we don't have any user number based routines for distributed matrices
  !as if we can't use a pointer to a CMISS object, a pointer to matrix data isn't going to
  !be much use either. It's also more awkward when matrices and vectors themselves don't have
  !user numbers and there are multiple ways to access them through user numbers, eg. solver equations
  !matrices or equations set matrices

  !>Get the storage type for a distributed matrix
  INTERFACE OC_DistributedMatrix_StorageTypeGet
    MODULE PROCEDURE OC_DistributedMatrix_StorageTypeGetObj
  END INTERFACE OC_DistributedMatrix_StorageTypeGet

  !>Get the data type for a distributed matrix
  INTERFACE OC_DistributedMatrix_DataTypeGet
    MODULE PROCEDURE OC_DistributedMatrix_DataTypeGetObj
  END INTERFACE OC_DistributedMatrix_DataTypeGet

  !>Get the dimensions for a distributed matrix on this computation node
  INTERFACE OC_DistributedMatrix_DimensionsGet
    MODULE PROCEDURE OC_DistributedMatrix_DimensionsGetObj
  END INTERFACE OC_DistributedMatrix_DimensionsGet

  !>Get the row indices and column indices for a sparse matrix
  INTERFACE OC_DistributedMatrix_StorageLocationsGet
    MODULE PROCEDURE OC_DistributedMatrix_StorageLocationsGetObj
  END INTERFACE OC_DistributedMatrix_StorageLocationsGet

  !>Get the data array for this matrix on this computation node
  INTERFACE OC_DistributedMatrix_DataGet
    MODULE PROCEDURE OC_DistributedMatrix_DataGetIntgObj
    MODULE PROCEDURE OC_DistributedMatrix_DataGetDPObj
    MODULE PROCEDURE OC_DistributedMatrix_DataGetSPObj
    MODULE PROCEDURE OC_DistributedMatrix_DataGetLObj
  END INTERFACE OC_DistributedMatrix_DataGet

  !>Restore the data array for this matrix once it has finished being used
  INTERFACE OC_DistributedMatrix_DataRestore
    MODULE PROCEDURE OC_DistributedMatrix_DataRestoreIntgObj
    MODULE PROCEDURE OC_DistributedMatrix_DataRestoreDPObj
    MODULE PROCEDURE OC_DistributedMatrix_DataRestoreSPObj
    MODULE PROCEDURE OC_DistributedMatrix_DataRestoreLObj
  END INTERFACE OC_DistributedMatrix_DataRestore

  !>Get the data type for a distributed vector
  INTERFACE OC_DistributedVector_DataTypeGet
    MODULE PROCEDURE OC_DistributedVector_DataTypeGetObj
  END INTERFACE OC_DistributedVector_DataTypeGet

  !>Get the data array for this vector on this computation node
  INTERFACE OC_DistributedVector_DataGet
    MODULE PROCEDURE OC_DistributedVector_DataGetIntgObj
    MODULE PROCEDURE OC_DistributedVector_DataGetDPObj
    MODULE PROCEDURE OC_DistributedVector_DataGetSPObj
    MODULE PROCEDURE OC_DistributedVector_DataGetLObj
  END INTERFACE OC_DistributedVector_DataGet

  !>Restore the data array for this vector once it has finished being used
  INTERFACE OC_DistributedVector_DataRestore
    MODULE PROCEDURE OC_DistributedVector_DataRestoreIntgObj
    MODULE PROCEDURE OC_DistributedVector_DataRestoreDPObj
    MODULE PROCEDURE OC_DistributedVector_DataRestoreSPObj
    MODULE PROCEDURE OC_DistributedVector_DataRestoreLObj
  END INTERFACE OC_DistributedVector_DataRestore

  PUBLIC OC_DistributedMatrix_StorageTypeGet,OC_DistributedMatrix_StorageLocationsGet
  PUBLIC OC_DistributedMatrix_DataTypeGet,OC_DistributedMatrix_DimensionsGet
  PUBLIC OC_DistributedMatrix_DataGet,OC_DistributedMatrix_DataRestore
  PUBLIC OC_DistributedVector_DataTypeGet
  PUBLIC OC_DistributedVector_DataGet,OC_DistributedVector_DataRestore

  !==================================================================================================================================
  !
  ! DomainRoutines
  !
  !==================================================================================================================================

  !>Returns the topology of a domain.
  INTERFACE OC_Domain_TopologyGet
    MODULE PROCEDURE OC_Domain_TopologyGetNumber
    MODULE PROCEDURE OC_Domain_TopologyGetObj
  END INTERFACE OC_Domain_TopologyGet

  !>Returns the domain elements of a domain toplogy.
  INTERFACE OC_DomainTopology_ElementsGet
    MODULE PROCEDURE OC_DomainTopology_ElementsGetNumber
    MODULE PROCEDURE OC_DomainTopology_ElementsGetObj
  END INTERFACE OC_DomainTopology_ElementsGet

  !>Returns the domain faces of a domain toplogy.
  INTERFACE OC_DomainTopology_FacesGet
    MODULE PROCEDURE OC_DomainTopology_FacesGetNumber
    MODULE PROCEDURE OC_DomainTopology_FacesGetObj
  END INTERFACE OC_DomainTopology_FacesGet

  !>Returns the domain lines of a domain toplogy.
  INTERFACE OC_DomainTopology_LinesGet
    MODULE PROCEDURE OC_DomainTopology_LinesGetNumber
    MODULE PROCEDURE OC_DomainTopology_LinesGetObj
  END INTERFACE OC_DomainTopology_LinesGet

  !>Returns the domain nodes of a domain toplogy.
  INTERFACE OC_DomainTopology_NodesGet
    MODULE PROCEDURE OC_DomainTopology_NodesGetNumber
    MODULE PROCEDURE OC_DomainTopology_NodesGetObj
  END INTERFACE OC_DomainTopology_NodesGet


  !==================================================================================================================================
  !
  ! NodeRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating nodes in a region. \see OpenCMISS::OC_Nodes_CreateStart
  INTERFACE OC_Nodes_CreateFinish
    MODULE PROCEDURE OC_Nodes_CreateFinishNumber
    MODULE PROCEDURE OC_Nodes_CreateFinishObj
  END INTERFACE OC_Nodes_CreateFinish

  !>Starts the process of creating nodes in a region. \see OpenCMISS::OC_Nodes_CreateFinish
  INTERFACE OC_Nodes_CreateStart
    MODULE PROCEDURE OC_Nodes_CreateStartNumber
    MODULE PROCEDURE OC_Nodes_CreateStartObj
    MODULE PROCEDURE OC_Nodes_CreateStartInterfaceObj
  END INTERFACE OC_Nodes_CreateStart

  !>Destroys nodes.
  INTERFACE OC_Nodes_Destroy
    MODULE PROCEDURE OC_Nodes_DestroyNumber
    MODULE PROCEDURE OC_Nodes_DestroyObj
  END INTERFACE OC_Nodes_Destroy

  !>Returns the number of nodes
  INTERFACE OC_Nodes_NumberOfNodesGet
    MODULE PROCEDURE OC_Nodes_NumberOfNodesGetNumber
    MODULE PROCEDURE OC_Nodes_NumberOfNodesGetObj
  END INTERFACE OC_Nodes_NumberOfNodesGet

  !>Returns the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE OC_Nodes_LabelGet
    MODULE PROCEDURE OC_Nodes_LabelGetCNumber
    MODULE PROCEDURE OC_Nodes_LabelGetCObj
    MODULE PROCEDURE OC_Nodes_LabelGetVSNumber
    MODULE PROCEDURE OC_Nodes_LabelGetVSObj
  END INTERFACE OC_Nodes_LabelGet

  !>Sets/changes the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE OC_Nodes_LabelSet
    MODULE PROCEDURE OC_Nodes_LabelSetCNumber
    MODULE PROCEDURE OC_Nodes_LabelSetCObj
    MODULE PROCEDURE OC_Nodes_LabelSetVSNumber
    MODULE PROCEDURE OC_Nodes_LabelSetVSObj
  END INTERFACE OC_Nodes_LabelSet

  !>Returns the user number for a node identified by a given global number.
  INTERFACE OC_Nodes_UserNumberGet
    MODULE PROCEDURE OC_Nodes_UserNumberGetNumber
    MODULE PROCEDURE OC_Nodes_UserNumberGetObj
  END INTERFACE OC_Nodes_UserNumberGet

  !>Sets/changes the user number for a node identified by a given global number.
  INTERFACE OC_Nodes_UserNumberSet
    MODULE PROCEDURE OC_Nodes_UserNumberSetNumber
    MODULE PROCEDURE OC_Nodes_UserNumberSetObj
  END INTERFACE OC_Nodes_UserNumberSet

  !>Sets/changes the all user number for nodes.
  INTERFACE OC_Nodes_UserNumbersAllSet
    MODULE PROCEDURE OC_Nodes_UserNumbersAllSetNumber
    MODULE PROCEDURE OC_Nodes_UserNumbersAllSetObj
  END INTERFACE OC_Nodes_UserNumbersAllSet

  PUBLIC OC_Nodes_CreateFinish,OC_Nodes_CreateStart

  PUBLIC OC_Nodes_Destroy

  PUBLIC OC_Nodes_NumberOfNodesGet

  PUBLIC OC_Nodes_LabelGet,OC_Nodes_LabelSet

  PUBLIC OC_Nodes_UserNumberGet,OC_Nodes_UserNumberSet,OC_Nodes_UserNumbersAllSet

  !==================================================================================================================================
  !
  ! ProblemRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_ProblemConstants OpenCMISS::Problem::Constants
  !> \brief Problem constants.
  !>@{
  !> \addtogroup OpenCMISS_ProblemClasses OpenCMISS::Problem::Classes
  !> \brief Problem classes.
  !> \see OpenCMISS::Problem,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NO_CLASS = PROBLEM_NO_CLASS !<No problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ELASTICITY_CLASS = PROBLEM_ELASTICITY_CLASS !<Elasticity problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FLUID_MECHANICS_CLASS = PROBLEM_FLUID_MECHANICS_CLASS !<Fluid mechanics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ELECTROMAGNETICS_CLASS = PROBLEM_ELECTROMAGNETICS_CLASS !<Electromagnetics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_CLASSICAL_FIELD_CLASS = PROBLEM_CLASSICAL_FIELD_CLASS !<Classical field problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BIOELECTRICS_CLASS = PROBLEM_BIOELECTRICS_CLASS !<Bioelectrics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MODAL_CLASS = PROBLEM_MODAL_CLASS !<Modal problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FITTING_CLASS = PROBLEM_FITTING_CLASS !<Fitting problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_OPTIMISATION_CLASS = PROBLEM_OPTIMISATION_CLASS !<Optimisation problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MULTI_PHYSICS_CLASS = PROBLEM_MULTI_PHYSICS_CLASS !<Multi physics problem class \see OpenCMISS_ProblemClasses,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_ProblemTypes OpenCMISS::Problem::Types
  !> \brief Problem Types.
  !> \see OpenCMISS::Problem,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NO_TYPE = PROBLEM_NO_TYPE !<No problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_ELASTICITY_TYPE = PROBLEM_LINEAR_ELASTICITY_TYPE !<Linear elasticity problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_TYPE = PROBLEM_FINITE_ELASTICITY_TYPE !<Finite elasticity problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE = PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE !<Linear elasticity problem subject to contact contstraint type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE = PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE !<Finite elasticity problem subject to contact constraint type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STOKES_EQUATION_TYPE = PROBLEM_STOKES_EQUATION_TYPE !<Stokes equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NAVIER_STOKES_EQUATION_TYPE = PROBLEM_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DARCY_EQUATION_TYPE = PROBLEM_DARCY_EQUATION_TYPE !<Darcy equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_POISEUILLE_EQUATION_TYPE = PROBLEM_POISEUILLE_EQUATION_TYPE !<Poiseuille equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BURGERS_EQUATION_TYPE = PROBLEM_BURGERS_EQUATION_TYPE !<Burgers equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ELECTROSTATIC_TYPE = PROBLEM_ELECTROSTATIC_TYPE !<Electrostatic problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MAGNETOSTATIC_TYPE = PROBLEM_MAGNETOSTATIC_TYPE !<Magnetostatic problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MAXWELLS_EQUATIONS_TYPE = PROBLEM_MAXWELLS_EQUATIONS_TYPE !<Maxwell's equations problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LAPLACE_EQUATION_TYPE = PROBLEM_LAPLACE_EQUATION_TYPE !<Laplace problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_POISSON_EQUATION_TYPE = PROBLEM_POISSON_EQUATION_TYPE !<Poisson problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_HELMHOLTZ_EQUATION_TYPE = PROBLEM_HELMHOLTZ_EQUATION_TYPE !<Helmholtz problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_WAVE_EQUATION_TYPE = PROBLEM_WAVE_EQUATION_TYPE !<Wave equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DIFFUSION_EQUATION_TYPE = PROBLEM_DIFFUSION_EQUATION_TYPE !<Diffusion equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE = PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE = PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BIHARMONIC_EQUATION_TYPE = PROBLEM_BIHARMONIC_EQUATION_TYPE !<Bi-harmonic equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_EQUATION_TYPE = PROBLEM_MONODOMAIN_EQUATION_TYPE !<Monodomain equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BIDOMAIN_EQUATION_TYPE = PROBLEM_BIDOMAIN_EQUATION_TYPE !<Bidomain equation problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE = PROBLEM_LINEAR_ELASTIC_MODAL_TYPE !<Linear elastic modal problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FITTING_TYPE = PROBLEM_FITTING_TYPE !<Galerkin projection problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE = PROBLEM_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity NavierStokes problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DIFFUSION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE = PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE !<Multi-compartment transport problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE = PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE !<Finite elasticity fluid pressure problem type \see OpenCMISS_ProblemTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE = PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE !<Monodomain finite elasticity problem type \see OpenCMISS_ProblemTypes,OpenCMISS

  !>@}
  !> \addtogroup OpenCMISS_ProblemSubtypes OpenCMISS::Problem::Subtypes
  !> \brief Problem Subtypes.
  !> \see OpenCMISS::Problem,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NO_SUBTYPE = PROBLEM_NO_SUBTYPE !<No problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_STOKES_SUBTYPE = PROBLEM_STATIC_STOKES_SUBTYPE !<Static Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LAPLACE_STOKES_SUBTYPE = PROBLEM_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_TRANSIENT_STOKES_SUBTYPE = PROBLEM_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ALE_STOKES_SUBTYPE = PROBLEM_ALE_STOKES_SUBTYPE !<ALE Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_OPTIMISED_STOKES_SUBTYPE = PROBLEM_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE = PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE = PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE !<Transient stabilised Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE = &
    & PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE !<Transient stabilised Navier-Stokes problem with multiscale boundary coupling subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE = PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE = PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STREE1D0D_SUBTYPE = PROBLEM_STREE1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STREE1D0D_ADV_SUBTYPE = PROBLEM_STREE1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE = PROBLEM_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE = PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STANDARD_DARCY_SUBTYPE = PROBLEM_STANDARD_DARCY_SUBTYPE !<Standard Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_DARCY_SUBTYPE = PROBLEM_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ALE_DARCY_SUBTYPE = PROBLEM_ALE_DARCY_SUBTYPE !<ALE Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STANDARD_LAPLACE_SUBTYPE = PROBLEM_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_POISEUILLE_SUBTYPE = PROBLEM_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE = PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE = PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE = PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE !<Nonlinear source Poisson problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE = PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE = PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_ALE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_ALE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_ALE_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_ALE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GENERALISED_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_GENERALISED_ADVEC_DIFF_SUBTYPE !<Generalised advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ADVEC_DIFF_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE !<Generalised ALE advection-diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Linear source ALE advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE !<Nonlinear source ALE advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE = PROBLEM_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE !<Generlised static advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source static advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Nonlinear source static advection-Diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_BURGERS_SUBTYPE = PROBLEM_STATIC_BURGERS_SUBTYPE !<static Burgers problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DYNAMIC_BURGERS_SUBTYPE = PROBLEM_DYNAMIC_BURGERS_SUBTYPE !<dynamic Burgers problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_CELLML_GUDUNOV_SPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_CELLML_GUDUNOV_SPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a CellML reaction term and Gudunov operator split \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_CELLML_STRANG_SPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_CELLML_STRANG_SPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a CellML reaction term and Strang operator split \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_CELLML_LINEAR_NOSPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_CELLML_LINEAR_NOSPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a linear CellML reaction term and no operator splitting \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_CELLML_NONLINEAR_NOSPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_CELLML_NONLINEAR_NOSPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a nonlinear CellML reaction term and no operator splitting \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GUDUNOV_SPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_GUDUNOV_SPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with Gudunov operator split \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STRANG_SPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_STRANG_SPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a Strang operator split \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LINEAR_NOSPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_NOSPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a linear reaction term and no operator splitting \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_NONLINEAR_NOSPLIT_REACT_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_NOSPLIT_REACT_DIFF_SUBTYPE !<Reaction-diffusion problem with a nonlinear reaction term and no operator splitting \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_LINEAR_FITTING_SUBTYPE = &
    & PROBLEM_STATIC_LINEAR_FITTING_SUBTYPE !<Static linear fitting problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_NONLINEAR_FITTING_SUBTYPE = &
    & PROBLEM_STATIC_NONLINEAR_FITTING_SUBTYPE !<Static nonlinear fitting problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_LINEAR_FITTING_SUBTYPE = &
    & PROBLEM_QUASISTATIC_LINEAR_FITTING_SUBTYPE !<Quasistatic linear fitting problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_NONLINEAR_FITTING_SUBTYPE = &
    & PROBLEM_QUASISTATIC_NONLINEAR_FITTING_SUBTYPE !<Quasistatic nonlinear fitting problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DIV_FREE_VELOCITY_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VELOCITY_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE = PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE !<Quasistatic Elasticity Transient Darcy problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE !<Quasistatic Elasticity Transient Darcy Material Solve problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled diffusion-diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_COUPLED_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled diffusion & advection-diffusion problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE = &
    & PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE !<Standard multi-compartment transport problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE = &
    & PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE !<Standard elasticity fluid pressure problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE = &
    & PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE = &
    & PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE = &
    & PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Transient monodomain simple elasticity problem subtype with titin \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE = &
    & PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype with force-velocity relation \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE = &
    & PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE !<Transient monodomain active strain elasticity problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE = &
    & PROBLEM_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity RBS Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GROWTH_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & PROBLEM_GROWTH_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity with growth Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_GROWTH_FINITE_ELAST_RBS_NAVIER_STOKES_ALE_SUBTYPE = &
    & PROBLEM_GROWTH_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity with growth RBS Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DYNAMIC_FINITE_ELAST_NAV_STOKES_ALE_SUBTYPE = &
    & PROBLEM_DYNAMIC_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled dynamic Finite Elasticity Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DYNAMIC_FINITE_ELAST_RBS_NAV_STOKES_ALE_SUBTYPE = &
    & PROBLEM_DYNAMIC_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE !<Coupled dynamic Finite Elasticity RBS Navier Stokes moving mesh subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STOKES_DAMPING_LINEAR_ELASTICITY_SUBTYPE = &
    & PROBLEM_STOKES_DAMPING_LINEAR_ELASTICITY_SUBTYPE !<Stokes damping linear elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE !<Static finite elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE !<Quasistatic finite elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE = &
    & PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE !<Quasistatic finite elasticity with growth subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE !<Dynamic finite elasticity subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE = PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE !<Quasistatic finite elasticity with active subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE = PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE !<Finite elasticity with CellML subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE =  &
    & PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE !<Finite elasticity with growth and CellML subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_DIRECT_MODEL_SUBTYPE = PROBLEM_MONODOMAIN_DIRECT_MODEL_SUBTYPE !<Monodomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE = PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Monodomain Bueno-Orovio problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE = PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Monodomain ten Tusscher 06 problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS

  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE !<finear elasticity problem subject to contact constraint, transform field at load increments \see OpenCMISS_ProblemSubtypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE !<finear elasticity problem subject to contact constraint, reproject at Newton iterations \see OpenCMISS_ProblemSubtypes,OpenCMISS

  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC OC_PROBLEM_NO_CLASS,OC_PROBLEM_ELASTICITY_CLASS,OC_PROBLEM_FLUID_MECHANICS_CLASS, &
    & OC_PROBLEM_ELECTROMAGNETICS_CLASS, &
    & OC_PROBLEM_CLASSICAL_FIELD_CLASS,OC_PROBLEM_BIOELECTRICS_CLASS,OC_PROBLEM_MODAL_CLASS,OC_PROBLEM_FITTING_CLASS, &
    & OC_PROBLEM_OPTIMISATION_CLASS,OC_PROBLEM_MULTI_PHYSICS_CLASS

  PUBLIC OC_PROBLEM_NO_TYPE

  PUBLIC OC_PROBLEM_LINEAR_ELASTICITY_TYPE,OC_PROBLEM_FINITE_ELASTICITY_TYPE

  PUBLIC OC_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE, OC_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE

  PUBLIC OC_PROBLEM_STOKES_EQUATION_TYPE,OC_PROBLEM_NAVIER_STOKES_EQUATION_TYPE,OC_PROBLEM_DARCY_EQUATION_TYPE, &
    & OC_PROBLEM_POISEUILLE_EQUATION_TYPE,OC_PROBLEM_BURGERS_EQUATION_TYPE

  PUBLIC OC_PROBLEM_ELECTROSTATIC_TYPE,OC_PROBLEM_MAGNETOSTATIC_TYPE,OC_PROBLEM_MAXWELLS_EQUATIONS_TYPE

  PUBLIC OC_PROBLEM_LAPLACE_EQUATION_TYPE,OC_PROBLEM_POISSON_EQUATION_TYPE,OC_PROBLEM_HELMHOLTZ_EQUATION_TYPE, &
    & OC_PROBLEM_WAVE_EQUATION_TYPE,OC_PROBLEM_DIFFUSION_EQUATION_TYPE,OC_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE, &
    & OC_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE,OC_PROBLEM_BIHARMONIC_EQUATION_TYPE

  PUBLIC OC_PROBLEM_MONODOMAIN_EQUATION_TYPE,OC_PROBLEM_BIDOMAIN_EQUATION_TYPE

  PUBLIC OC_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE

  PUBLIC OC_PROBLEM_FITTING_TYPE

  PUBLIC OC_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE, &
    & OC_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE, OC_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & OC_PROBLEM_DIFFUSION_DIFFUSION_TYPE, OC_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE, &
    & OC_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE,OC_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE, &
    & OC_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE

  PUBLIC OC_PROBLEM_NO_SUBTYPE

  PUBLIC OC_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, OC_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE, &
    & OC_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE

  PUBLIC OC_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, OC_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE, &
    & OC_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE

  PUBLIC OC_PROBLEM_STATIC_STOKES_SUBTYPE,OC_PROBLEM_LAPLACE_STOKES_SUBTYPE,OC_PROBLEM_TRANSIENT_STOKES_SUBTYPE, &
    & OC_PROBLEM_OPTIMISED_STOKES_SUBTYPE,OC_PROBLEM_ALE_STOKES_SUBTYPE

  PUBLIC OC_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE,OC_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE, &
    & OC_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE,OC_PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE, &
    & OC_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE, &
    & OC_PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE,OC_PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE, &
    & OC_PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE,OC_PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE, &
    & OC_PROBLEM_STREE1D0D_ADV_SUBTYPE,OC_PROBLEM_STREE1D0D_SUBTYPE, &
    & OC_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE,OC_PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE

  PUBLIC OC_PROBLEM_STANDARD_DARCY_SUBTYPE,OC_PROBLEM_QUASISTATIC_DARCY_SUBTYPE,OC_PROBLEM_ALE_DARCY_SUBTYPE, &
    & OC_PROBLEM_TRANSIENT_DARCY_SUBTYPE

  PUBLIC OC_PROBLEM_STATIC_POISEUILLE_SUBTYPE,OC_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE

  PUBLIC OC_PROBLEM_STATIC_BURGERS_SUBTYPE,OC_PROBLEM_DYNAMIC_BURGERS_SUBTYPE

  PUBLIC OC_PROBLEM_STANDARD_LAPLACE_SUBTYPE

  PUBLIC OC_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE,OC_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE, &
    & OC_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE,OC_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & OC_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE, OC_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE, &
    & OC_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE

  PUBLIC OC_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE,OC_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE

  PUBLIC OC_PROBLEM_LINEAR_DIFFUSION_SUBTYPE,OC_PROBLEM_NONLINEAR_DIFFUSION_SUBTYPE

  PUBLIC OC_PROBLEM_LINEAR_ALE_DIFFUSION_SUBTYPE,OC_PROBLEM_NONLINEAR_ALE_DIFFUSION_SUBTYPE

  PUBLIC OC_PROBLEM_GENERALISED_ADVEC_DIFF_SUBTYPE,OC_PROBLEM_LINEAR_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & OC_PROBLEM_NONLINEAR_SOURCE_ADVEC_DIFF_SUBTYPE

  PUBLIC OC_PROBLEM_GENERALISED_ALE_ADVEC_DIFF_SUBTYPE,OC_PROBLEM_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & OC_PROBLEM_NONLINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE

  PUBLIC OC_PROBLEM_GENERALISED_STATIC_ADVEC_DIFF_SUBTYPE,OC_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & OC_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE

  PUBLIC OC_PROBLEM_CELLML_GUDUNOV_SPLIT_REACT_DIFF_SUBTYPE,OC_PROBLEM_CELLML_STRANG_SPLIT_REACT_DIFF_SUBTYPE, &
    & OC_PROBLEM_CELLML_LINEAR_NOSPLIT_REACT_DIFF_SUBTYPE,OC_PROBLEM_CELLML_NONLINEAR_NOSPLIT_REACT_DIFF_SUBTYPE, &
    & OC_PROBLEM_GUDUNOV_SPLIT_REACT_DIFF_SUBTYPE,OC_PROBLEM_STRANG_SPLIT_REACT_DIFF_SUBTYPE, &
    & OC_PROBLEM_LINEAR_NOSPLIT_REACT_DIFF_SUBTYPE,OC_PROBLEM_NONLINEAR_NOSPLIT_REACT_DIFF_SUBTYPE

  PUBLIC OC_PROBLEM_STATIC_LINEAR_FITTING_SUBTYPE,OC_PROBLEM_STATIC_NONLINEAR_FITTING_SUBTYPE, &
    & OC_PROBLEM_QUASISTATIC_LINEAR_FITTING_SUBTYPE,OC_PROBLEM_QUASISTATIC_NONLINEAR_FITTING_SUBTYPE, &
    & OC_PROBLEM_DIV_FREE_VELOCITY_FITTING_SUBTYPE

  PUBLIC OC_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE,OC_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE, &
    & OC_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE,OC_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE

  PUBLIC OC_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE, OC_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE

  PUBLIC OC_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, &
    & OC_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,OC_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE, &
    & OC_PROBLEM_COUPLED_DIFFUSION_DIFFUSION_SUBTYPE, OC_PROBLEM_COUPLED_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE, &
    & OC_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE,OC_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE, &
    & OC_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE,OC_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE, &
    & OC_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,OC_PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
    & OC_PROBLEM_MONODOMAIN_1D3D_ACTIVE_STRAIN_SUBTYPE, &
    & OC_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE, &
    & OC_PROBLEM_FINITE_ELASTICITY_RBS_NAVIER_STOKES_ALE_SUBTYPE,&
    & OC_PROBLEM_GROWTH_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE, &
    & OC_PROBLEM_GROWTH_FINITE_ELAST_RBS_NAVIER_STOKES_ALE_SUBTYPE, &
    & OC_PROBLEM_DYNAMIC_FINITE_ELAST_NAV_STOKES_ALE_SUBTYPE, &
    & OC_PROBLEM_DYNAMIC_FINITE_ELAST_RBS_NAV_STOKES_ALE_SUBTYPE

  PUBLIC OC_PROBLEM_STOKES_DAMPING_LINEAR_ELASTICITY_SUBTYPE

  PUBLIC OC_PROBLEM_STATIC_FINITE_ELASTICITY_SUBTYPE,OC_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE, &
    & OC_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_WITH_GROWTH_SUBTYPE,OC_PROBLEM_DYNAMIC_FINITE_ELASTICITY_SUBTYPE

  PUBLIC OC_PROBLEM_FINITE_ELASTICITY_WITH_ACTIVE_SUBTYPE,OC_PROBLEM_FINITE_ELASTICITY_WITH_CELLML_SUBTYPE, &
    & OC_PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE

  !==================================================================================================================================
  !
  ! PROBLEM_ROUTINES
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of CellML equations for a problem. \see OpenCMISS::OC_Problem_CellMLEquationsCreateStart
  INTERFACE OC_Problem_CellMLEquationsCreateFinish
    MODULE PROCEDURE OC_Problem_CellMLEquationsCreateFinishNumber
    MODULE PROCEDURE OC_Problem_CellMLEquationsCreateFinishObj
  END INTERFACE OC_Problem_CellMLEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OpenCMISS::OC_Problem_CellMLEquationsCreateFinish
  INTERFACE OC_Problem_CellMLEquationsCreateStart
    MODULE PROCEDURE OC_Problem_CellMLEquationsCreateStartNumber
    MODULE PROCEDURE OC_Problem_CellMLEquationsCreateStartObj
  END INTERFACE OC_Problem_CellMLEquationsCreateStart

  !>Returns the CellML equations for a problem.
  INTERFACE OC_Problem_CellMLEquationsGet
    MODULE PROCEDURE OC_Problem_CellMLEquationsGetNumber0
    MODULE PROCEDURE OC_Problem_CellMLEquationsGetNumber1
    MODULE PROCEDURE OC_Problem_CellMLEquationsGetObj0
    MODULE PROCEDURE OC_Problem_CellMLEquationsGetObj1
  END INTERFACE OC_Problem_CellMLEquationsGet

  !>Finishes the process of creating a problem. \see OpenCMISS::OC_Problem_CreateStart
  INTERFACE OC_Problem_CreateFinish
    MODULE PROCEDURE OC_Problem_CreateFinishNumber
    MODULE PROCEDURE OC_Problem_CreateFinishObj
  END INTERFACE OC_Problem_CreateFinish

  !>Start the process of creating a problem. \see OpenCMISS::OC_Problem_CreateFinish
  INTERFACE OC_Problem_CreateStart
    MODULE PROCEDURE OC_Problem_CreateStartNumber
    MODULE PROCEDURE OC_Problem_CreateStartObj
  END INTERFACE OC_Problem_CreateStart

  !>Finishes the process of creating a control loop on a problem. \see OpenCMISS::OC_Problem_ControlLoopCreateStart
  INTERFACE OC_Problem_ControlLoopCreateFinish
    MODULE PROCEDURE OC_Problem_ControlLoopCreateFinishNumber
    MODULE PROCEDURE OC_Problem_ControlLoopCreateFinishObj
  END INTERFACE OC_Problem_ControlLoopCreateFinish

  !>Starts the process of creating a control loop on a problem. \see OpenCMISS::OC_Problem_ControlLoopCreateFinish
  INTERFACE OC_Problem_ControlLoopCreateStart
    MODULE PROCEDURE OC_Problem_ControlLoopCreateStartNumber
    MODULE PROCEDURE OC_Problem_ControlLoopCreateStartObj
  END INTERFACE OC_Problem_ControlLoopCreateStart

  !>Destroys the control loop for a problem.
  INTERFACE OC_Problem_ControlLoopDestroy
    MODULE PROCEDURE OC_Problem_ControlLoopDestroyNumber
    MODULE PROCEDURE OC_Problem_ControlLoopDestroyObj
  END INTERFACE OC_Problem_ControlLoopDestroy

  !>Returns a control loop for a problem.
  INTERFACE OC_Problem_ControlLoopGet
    MODULE PROCEDURE OC_Problem_ControlLoopGetNumber0
    MODULE PROCEDURE OC_Problem_ControlLoopGetNumber1
    MODULE PROCEDURE OC_Problem_ControlLoopGetObj0
    MODULE PROCEDURE OC_Problem_ControlLoopGetObj1
  END INTERFACE OC_Problem_ControlLoopGet

  !>Destroys a problem.
  INTERFACE OC_Problem_Destroy
    MODULE PROCEDURE OC_Problem_DestroyNumber
    MODULE PROCEDURE OC_Problem_DestroyObj
  END INTERFACE OC_Problem_Destroy

  !>Solve a problem.
  INTERFACE OC_Problem_Solve
    MODULE PROCEDURE OC_Problem_SolveNumber
    MODULE PROCEDURE OC_Problem_SolveObj
  END INTERFACE OC_Problem_Solve

  !>Returns the solver for a problem control loop.
  INTERFACE OC_Problem_SolverGet
    MODULE PROCEDURE OC_Problem_SolverGetNumber0
    MODULE PROCEDURE OC_Problem_SolverGetNumber1
    MODULE PROCEDURE OC_Problem_SolverGetObj0
    MODULE PROCEDURE OC_Problem_SolverGetObj1
  END INTERFACE OC_Problem_SolverGet

  !>Set boundary conditions for solver equations according to the analytic equations.
  INTERFACE OC_SolverEquations_BoundaryConditionsAnalytic
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsAnalyticNumber0
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsAnalyticNumber1
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsAnalyticObj
  END INTERFACE OC_SolverEquations_BoundaryConditionsAnalytic

  !>Finish the creation of solver equations for a problem. \see OpenCMISS::OC_Problem_SolverEquationsCreateStart
  INTERFACE OC_Problem_SolverEquationsCreateFinish
    MODULE PROCEDURE OC_Problem_SolverEquationsCreateFinishNumber
    MODULE PROCEDURE OC_Problem_SolverEquationsCreateFinishObj
  END INTERFACE OC_Problem_SolverEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OpenCMISS::OC_Problem_SolverEquationsCreateFinish
  INTERFACE OC_Problem_SolverEquationsCreateStart
    MODULE PROCEDURE OC_Problem_SolverEquationsCreateStartNumber
    MODULE PROCEDURE OC_Problem_SolverEquationsCreateStartObj
  END INTERFACE OC_Problem_SolverEquationsCreateStart

  !>Destroys the solver equations for a problem.
  INTERFACE OC_Problem_SolverEquationsDestroy
    MODULE PROCEDURE OC_Problem_SolverEquationsDestroyNumber
    MODULE PROCEDURE OC_Problem_SolverEquationsDestroyObj
  END INTERFACE OC_Problem_SolverEquationsDestroy

  !>Returns the solver equations for a problem.
  INTERFACE OC_Problem_SolverEquationsGet
    MODULE PROCEDURE OC_Problem_SolverEquationsGetNumber0
    MODULE PROCEDURE OC_Problem_SolverEquationsGetNumber1
    MODULE PROCEDURE OC_Problem_SolverEquationsGetObj0
    MODULE PROCEDURE OC_Problem_SolverEquationsGetObj1
  END INTERFACE OC_Problem_SolverEquationsGet

  !>Finish the creation of solvers for a problem. \see OpenCMISS::OC_Problem_SolversCreateStart
  INTERFACE OC_Problem_SolversCreateFinish
    MODULE PROCEDURE OC_Problem_SolversCreateFinishNumber
    MODULE PROCEDURE OC_Problem_SolversCreateFinishObj
  END INTERFACE OC_Problem_SolversCreateFinish

  !>Start the creation of solvers for a problem. \see OpenCMISS::OC_Problem_SolversCreateFinish
  INTERFACE OC_Problem_SolversCreateStart
    MODULE PROCEDURE OC_Problem_SolversCreateStartNumber
    MODULE PROCEDURE OC_Problem_SolversCreateStartObj
  END INTERFACE OC_Problem_SolversCreateStart

  !>Destroy the solvers for a problem.
  INTERFACE OC_Problem_SolversDestroy
    MODULE PROCEDURE OC_Problem_SolversDestroyNumber
    MODULE PROCEDURE OC_Problem_SolversDestroyObj
  END INTERFACE OC_Problem_SolversDestroy

  !>Returns the problem specification array for a problem.
  INTERFACE OC_Problem_SpecificationGet
    MODULE PROCEDURE OC_Problem_SpecificationGetNumber
    MODULE PROCEDURE OC_Problem_SpecificationGetObj
  END INTERFACE OC_Problem_SpecificationGet

  !>Returns the size of the problem specification array for a problem.
  INTERFACE OC_Problem_SpecificationSizeGet
    MODULE PROCEDURE OC_Problem_SpecificationSizeGetNumber
    MODULE PROCEDURE OC_Problem_SpecificationSizeGetObj
  END INTERFACE OC_Problem_SpecificationSizeGet

  !>Sets/changes the work group for a problem.
  INTERFACE OC_Problem_WorkGroupSet
    MODULE PROCEDURE OC_Problem_WorkGroupSetNumber
    MODULE PROCEDURE OC_Problem_WorkGroupSetObj
  END INTERFACE OC_Problem_WorkGroupSet

  PUBLIC OC_Problem_CellMLEquationsCreateFinish,OC_Problem_CellMLEquationsCreateStart

  PUBLIC OC_Problem_CellMLEquationsGet

  PUBLIC OC_Problem_CreateFinish,OC_Problem_CreateStart

  PUBLIC OC_Problem_ControlLoopCreateFinish,OC_Problem_ControlLoopCreateStart

  PUBLIC OC_Problem_ControlLoopDestroy

  PUBLIC OC_Problem_ControlLoopGet

  PUBLIC OC_Problem_Destroy

  PUBLIC OC_Problem_Solve

  PUBLIC OC_Problem_SolverGet

  PUBLIC OC_SolverEquations_BoundaryConditionsAnalytic

  PUBLIC OC_Problem_SolverEquationsCreateFinish,OC_Problem_SolverEquationsCreateStart

  PUBLIC OC_Problem_SolverEquationsDestroy

  PUBLIC OC_Problem_SolverEquationsGet

  PUBLIC OC_Problem_SolversCreateFinish,OC_Problem_SolversCreateStart

  PUBLIC OC_Problem_SolversDestroy

  PUBLIC OC_Problem_SpecificationGet,OC_Problem_SpecificationSizeGet

  PUBLIC OC_Problem_WorkGroupSet

  !==================================================================================================================================
  !
  ! RegionRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Returns the coordinate system of region.
  INTERFACE OC_Region_CoordinateSystemGet
    MODULE PROCEDURE OC_Region_CoordinateSystemGetNumber
    MODULE PROCEDURE OC_Region_CoordinateSystemGetObj
  END INTERFACE OC_Region_CoordinateSystemGet

  !>Sets/changes the coordinate system of region.
  INTERFACE OC_Region_CoordinateSystemSet
    MODULE PROCEDURE OC_Region_CoordinateSystemSetNumber
    MODULE PROCEDURE OC_Region_CoordinateSystemSetObj
  END INTERFACE OC_Region_CoordinateSystemSet

  !>Finishes the creation of a region. \see OpenCMISS::OC_Region_CreateStart
  INTERFACE OC_Region_CreateFinish
    MODULE PROCEDURE OC_Region_CreateFinishNumber
    MODULE PROCEDURE OC_Region_CreateFinishObj
  END INTERFACE OC_Region_CreateFinish

  !>Starts the creation of a region. \see OpenCMISS::OC_Region_CreateFinish
  INTERFACE OC_Region_CreateStart
    MODULE PROCEDURE OC_Region_CreateStartNumber
    MODULE PROCEDURE OC_Region_CreateStartObj
  END INTERFACE OC_Region_CreateStart

  !>Returns the data points for a region.
  INTERFACE OC_Region_DataPointsGet
    MODULE PROCEDURE OC_Region_DataPointsGetObj
  END INTERFACE OC_Region_DataPointsGet

  !>Destroys a region.
  INTERFACE OC_Region_Destroy
    MODULE PROCEDURE OC_Region_DestroyNumber
    MODULE PROCEDURE OC_Region_DestroyObj
  END INTERFACE OC_Region_Destroy

  !>Returns the label of a region.
  INTERFACE OC_Region_LabelGet
    MODULE PROCEDURE OC_Region_LabelGetCNumber
    MODULE PROCEDURE OC_Region_LabelGetCObj
    MODULE PROCEDURE OC_Region_LabelGetVSNumber
    MODULE PROCEDURE OC_Region_LabelGetVSObj
  END INTERFACE OC_Region_LabelGet

  !>Sets/changes the label of a region.
  INTERFACE OC_Region_LabelSet
    MODULE PROCEDURE OC_Region_LabelSetCNumber
    MODULE PROCEDURE OC_Region_LabelSetCObj
    MODULE PROCEDURE OC_Region_LabelSetVSNumber
    MODULE PROCEDURE OC_Region_LabelSetVSObj
  END INTERFACE OC_Region_LabelSet

  !>Returns the nodes for a region.
  INTERFACE OC_Region_NodesGet
    MODULE PROCEDURE OC_Region_NodesGetObj
  END INTERFACE OC_Region_NodesGet

  PUBLIC OC_Region_CoordinateSystemGet,OC_Region_CoordinateSystemSet

  PUBLIC OC_Region_CreateFinish,OC_Region_CreateStart

  PUBLIC OC_Region_DataPointsGet

  PUBLIC OC_Region_Destroy

  PUBLIC OC_Region_LabelGet,OC_Region_LabelSet

  PUBLIC OC_Region_NodesGet

  !==================================================================================================================================
  !
  ! SolverRoutines
  !
  !==================================================================================================================================

  !Module parameters

  !> \addtogroup OpenCMISS_CellMLEquationsConstants OpenCMISS::CellMLEquations::Constants
  !> \brief CellML equations constants.
  !>@{
  !> \addtogroup OpenCMISS_CellMLEquationsLinearityTypes OpenCMISS::CellMLEquations::Constants::LinearityTypes
  !> \brief The CellML equations linearity types
  !> \see OpenCMISS::CellMLEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_CELLML_EQUATIONS_LINEAR = CELLML_EQUATIONS_LINEAR !<The CellML equations are linear. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CELLML_EQUATIONS_NONLINEAR = CELLML_EQUATIONS_NONLINEAR !<The CellML equations are non-linear. \see \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_CellMLEquationsTimeDependenceTypes OpenCMISS::CellMLEquations::Constants:TimeDependenceTypes
  !> \brief The CellML equations time dependence types
  !> \see OpenCMISS::CellMLEquations,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_CELLML_EQUATIONS_STATIC = CELLML_EQUATIONS_STATIC !<The CellML equations are static and have no time dependence. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CELLML_EQUATIONS_QUASISTATIC = CELLML_EQUATIONS_QUASISTATIC !<The CellML equations are quasi-static. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_CELLML_EQUATIONS_DYNAMIC = CELLML_EQUATIONS_DYNAMIC !<The equations are dynamic. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
  !>@}
  !>@}

  !> \addtogroup OpenCMISS_SolverConstants OpenCMISS::Solver::Constants
  !> \brief Solver constants.
  !>@{
  !> \addtogroup OpenCMISS_SolverTypes OpenCMISS::Solver::SolverTypes
  !> \brief The types of solver
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_LINEAR_TYPE = SOLVER_LINEAR_TYPE !<A linear solver. \see OpenCMISS_SolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NONLINEAR_TYPE = SOLVER_NONLINEAR_TYPE !<A nonlinear solver. \see OpenCMISS_SolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_TYPE = SOLVER_DYNAMIC_TYPE !<A dynamic solver. \see  OpenCMISS_SolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_TYPE = SOLVER_DAE_TYPE !<A differential-algebraic equation solver. \see OpenCMISS_SolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_EIGENPROBLEM_TYPE = SOLVER_EIGENPROBLEM_TYPE !<A eigenproblem solver. \see OpenCMISS_SolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_OPTIMISER_TYPE = SOLVER_OPTIMISER_TYPE !<An optimiser solver. \see OpenCMISS_SolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SolverCellMLEvaluatorType = SOLVER_CELLML_EVALUATOR_TYPE !<A CellML evaluator solver. \see OpenCMISS_SolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_SolverLibraries OpenCMISS::Solver::SolverLibraries
  !> \brief The types of solver libraries.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_CMISS_LIBRARY = SOLVER_CMISS_LIBRARY !<CMISS (internal) solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_PETSC_LIBRARY = SOLVER_PETSC_LIBRARY !<PETSc solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_MUMPS_LIBRARY = SOLVER_MUMPS_LIBRARY !<MUMPS solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SUPERLU_LIBRARY = SOLVER_SUPERLU_LIBRARY !<SuperLU solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SPOOLES_LIBRARY = SOLVER_SPOOLES_LIBRARY !<SPOOLES solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_UMFPACK_LIBRARY = SOLVER_UMFPACK_LIBRARY !<UMFPACK solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_LUSOL_LIBRARY = SOLVER_LUSOL_LIBRARY !<LUSOL solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ESSL_LIBRARY = SOLVER_ESSL_LIBRARY !<ESSL solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_LAPACK_LIBRARY = SOLVER_LAPACK_LIBRARY !<LAPACK solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_HYPRE_LIBRARY = SOLVER_HYPRE_LIBRARY !<Hypre solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_PASTIX_LIBRARY = SOLVER_PASTIX_LIBRARY !<PaStiX solver library. \see OpenCMISS_SolverLibraries,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_LinearSolverTypes OpenCMISS::Solver::LinearSolverTypes
  !> \brief The types of linear solvers.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_LINEAR_DIRECT_SOLVE_TYPE = SOLVER_LINEAR_DIRECT_SOLVE_TYPE !<Direct linear solver type. \see OpenCMISS_LinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE = SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE !<Iterative linear solver type. \see OpenCMISS_LinearSolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DirectLinearSolverTypes OpenCMISS::Solver::DirectLinearSolverTypes
  !> \brief The types of direct linear solvers. \todo Move libraries to a more appropriate place.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DIRECT_LU = SOLVER_DIRECT_LU !<LU direct linear solver. \see OpenCMISS_DirectLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DIRECT_CHOLESKY = SOLVER_DIRECT_CHOLESKY !<Cholesky direct linear solver. \see OpenCMISS_DirectLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DIRECT_SVD = SOLVER_DIRECT_SVD !<SVD direct linear solver. \see OpenCMISS_DirectLinearSolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_IterativeLinearSolverTypes OpenCMISS::Solver::IterativeLinearSolverTypes
  !> \brief The types of iterative linear solvers.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_RICHARDSON = SOLVER_ITERATIVE_RICHARDSON !<Richardson iterative solver type. \see  OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_CHEBYSHEV = SOLVER_ITERATIVE_CHEBYSHEV !<Chebychev iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_CONJUGATE_GRADIENT = SOLVER_ITERATIVE_CONJUGATE_GRADIENT !<Conjugate gradient iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT = SOLVER_ITERATIVE_BICONJUGATE_GRADIENT !<Bi-conjugate gradient iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_GMRES = SOLVER_ITERATIVE_GMRES !<Generalised minimum residual iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_BiCGSTAB = SOLVER_ITERATIVE_BiCGSTAB !<Stabalised bi-conjugate gradient iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_CONJGRAD_SQUARED = SOLVER_ITERATIVE_CONJGRAD_SQUARED !<Conjugate gradient squared iterative solver type. \see OpenCMISS_IterativeLinearSolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_IterativePreconditionerTypes OpenCMISS::Solver::IterativePreconditionerTypes
  !> \brief The types of iterative preconditioners.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_NO_PRECONDITIONER = SOLVER_ITERATIVE_NO_PRECONDITIONER !<No preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_JACOBI_PRECONDITIONER !<Jacobi preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER !<Iterative block Jacobi preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_SOR_PRECONDITIONER = SOLVER_ITERATIVE_SOR_PRECONDITIONER !<Successive over relaxation preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER = &
    & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER !<Incomplete Cholesky preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER = SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER !<Incomplete LU preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER =  &
    & SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER !<Additive Schwrz preconditioner type. \see OpenCMISS_IterativePreconditionerTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_NonlinearSolverTypes OpenCMISS::Solver::NonlinearSolverTypes
  !> \brief The types of nonlinear solvers.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NONLINEAR_NEWTON = SOLVER_NONLINEAR_NEWTON !<Newton nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NONLINEAR_BFGS_INVERSE = SOLVER_NONLINEAR_BFGS_INVERSE !<BFGS inverse nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NONLINEAR_SQP = SOLVER_NONLINEAR_SQP !<Sequential Quadratic Program nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NONLINEAR_QUASI_NEWTON = SOLVER_NONLINEAR_QUASI_NEWTON !<Quasi-Newton nonlinear solver type. \see OpenCMISS_NonlinearSolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_QuasiNewtonSolverTypes OpenCMISS::Solver::QuasiNewtonSolverTypes
  !> \brief The types of nonlinear Quasi-Newton solvers
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_LINESEARCH=SOLVER_QUASI_NEWTON_LINESEARCH !<Quasi-Newton line search nonlinear solver type \see OpenCMISS_QuasiNewtonSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_TRUSTREGION=SOLVER_QUASI_NEWTON_TRUSTREGION !<Quasi-Newton trust region nonlinear solver type \see OpenCMISS_QuasiNewtonSolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_QuasiNewtonTypes OpenCMISS::Solver::QuasiNewtonTypes
  !> \brief The nonlinear Quasi-Newton types
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_LBFGS=SOLVER_QUASI_NEWTON_LBFGS !<LBFGS Quasi-Newton type \see OpenCMISS_QuasiNewtonTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_GOODBROYDEN=SOLVER_QUASI_NEWTON_GOODBROYDEN !<"Good" Broyden Quasi-Newton type \see OpenCMISS_QuasiNewtonTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_BADBROYDEN=SOLVER_QUASI_NEWTON_BADBROYDEN !<"Bad" Broyden Quasi-Newton type \see OpenCMISS_QuasiNewtonTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_QuasiNewtonLineSearchTypes OpenCMISS::Solver::NonlinearQuasiNewtonLineSearchTypes
  !> \brief The types of line search techniques for Quasi-Newton line search nonlinear solvers
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC=SOLVER_QUASI_NEWTON_LINESEARCH_BASIC !<Simple damping line search. \see OpenCMISS_QuasiNewtonLineSearchTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_LINESEARCH_L2=SOLVER_QUASI_NEWTON_LINESEARCH_L2 !<Secant line search over the L2 norm of the function \see OpenCMISS_QuasiNewtonLineSearchTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_LINESEARCH_CP=SOLVER_QUASI_NEWTON_LINESEARCH_CP !<Critical point secant line search \see OpenCMISS_QuasiNewtonLineSearchTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_QuasiNewtonRestartTypes OpenCMISS::Solver::QuasiNewtonRestartTypes
  !> \brief The nonlinear Quasi-Newton restart types
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_RESTART_NONE=SOLVER_QUASI_NEWTON_RESTART_NONE !<Never restart \see OpenCMISS_QuasiNewtonRestartTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_RESTART_POWELL=SOLVER_QUASI_NEWTON_RESTART_POWELL !<Restart based upon descent criteria \see OpenCMISS_QuasiNewtonRestartTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_RESTART_PERIODIC=SOLVER_QUASI_NEWTON_RESTART_PERIODIC !<Restart after a fixed number of iterations \see OpenCMISS_QuasiNewtonRestartTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_QuasiNewtonScaleTypes OpenCMISS::Solver::QuasiNewtonScaleTypes
  !> \brief The nonlinear Quasi-Newton scale types
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_SCALE_NONE=SOLVER_QUASI_NEWTON_SCALE_NONE !<Don't scale the problem \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_SCALE_SHANNO=SOLVER_QUASI_NEWTON_SCALE_SHANNO !<Use Shanno scaling \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH=SOLVER_QUASI_NEWTON_SCALE_LINESEARCH !<Scale based upon line search lambda \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN=SOLVER_QUASI_NEWTON_SCALE_JACOBIAN !<Scale by inverting a previously computed Jacobian \see OpenCMISS_QuasiNewtonScaleTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_NewtonSolverTypes OpenCMISS::Solver::NewtonSolverTypes
  !> \brief The types of nonlinear Newton solvers.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_LINESEARCH = SOLVER_NEWTON_LINESEARCH !<Newton line search nonlinear solver type. \see OpenCMISS_NewtonSolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_TRUSTREGION = SOLVER_NEWTON_TRUSTREGION !<Newton trust region nonlinear solver type. \see OpenCMISS_NewtonSolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_NewtonLineSearchTypes OpenCMISS::Solver::NewtonLineSearchTypes
  !> \brief The types line search techniques for Newton line search nonlinear solvers.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_LINESEARCH_LINEAR = SOLVER_NEWTON_LINESEARCH_LINEAR !<Linear line search for Newton line search nonlinear solves \see OpenCMISS_NewtonLineSearchTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_LINESEARCH_QUADRATIC = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OpenCMISS_NewtonLineSearchTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_LINESEARCH_CUBIC = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OpenCMISS_NewtonLineSearchTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_JacobianCalculationTypes OpenCMISS::Solver::JacobianCalculationTypes
  !> \brief The Jacobian calculation types for a nonlinear solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED = SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED !<The Jacobian values will not be calculated for the nonlinear equations set. \see OpenCMISS_JacobianCalculationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED = SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED !<The Jacobian values will be calculated  analytically for the nonlinear equations set. \see OpenCMISS_JacobianCalculationTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED = SOLVER_NEWTON_JACOBIAN_FD_CALCULATED !<The Jacobian values will be calcualted using finite differences for the nonlinear equations set. \see OpenCMISS_JacobianCalculationTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_NewtonConvergenceTypes OpenCMISS::Solver::NewtonConvergenceTypes
  !> \brief The convergence test types for a nonlinear newton solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT = SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT !<Newton solver Petsc default convergence test type. \see OpenCMISS_NewtonConvergenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM = SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM !<Newton solver energy norm convergence test type. \see OpenCMISS_NewtonConvergenceTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO = SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO !<Newton solver Sum of differentiated ratios of unconstrained to constrained residuals convergence test type. \see OpenCMISS_NewtonConvergenceTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DynamicOrderTypes OpenCMISS::Solver::DynamicOrderTypes
  !> \brief The order types for a dynamic solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_FIRST_ORDER = SOLVER_DYNAMIC_FIRST_ORDER !<Dynamic solver has first order terms. \see OpenCMISS_DynamicOrderTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_SECOND_ORDER = SOLVER_DYNAMIC_SECOND_ORDER !<Dynamic solver has second order terms. \see OpenCMISS_DynamicOrderTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DynamicLinearityTypes OpenCMISS::Solver::DynamicLinearityTypes
  !> \brief The time linearity types for a dynamic solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_LINEAR = SOLVER_DYNAMIC_LINEAR !<Dynamic solver has linear terms. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_NONLINEAR = SOLVER_DYNAMIC_NONLINEAR !<Dynamic solver has nonlinear terms. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DynamicDegreeTypes OpenCMISS::Solver::DynamicDegreeTypes
  !> \brief The time interpolation polynomial degree types for a dynamic solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_FIRST_DEGREE = SOLVER_DYNAMIC_FIRST_DEGREE !<Dynamic solver uses a first degree polynomial for time interpolation. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_SECOND_DEGREE = SOLVER_DYNAMIC_SECOND_DEGREE !<Dynamic solver uses a second degree polynomial for time interpolation. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_THIRD_DEGREE = SOLVER_DYNAMIC_THIRD_DEGREE !<Dynamic solver uses a third degree polynomial for time interpolation. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DynamicSchemeTypes OpenCMISS::Solver::DynamicSchemeTypes
  !> \brief The types of dynamic solver scheme.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_EULER_SCHEME = SOLVER_DYNAMIC_EULER_SCHEME !<Euler (explicit) dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME = SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME !<Backward Euler (implicit) dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME = SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME !<Crank-Nicolson dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_GALERKIN_SCHEME = SOLVER_DYNAMIC_GALERKIN_SCHEME !<Galerkin dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_ZLAMAL_SCHEME = SOLVER_DYNAMIC_ZLAMAL_SCHEME !<Zlamal dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME !<2nd degree Gear dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME !<1st 2nd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME !<2nd 2nd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_NEWMARK1_SCHEME = SOLVER_DYNAMIC_NEWMARK1_SCHEME !<1st Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_NEWMARK2_SCHEME = SOLVER_DYNAMIC_NEWMARK2_SCHEME !<2nd Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_NEWMARK3_SCHEME = SOLVER_DYNAMIC_NEWMARK3_SCHEME !<3rd Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME !<3rd degree Gear dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME !<1st 3rd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME !<2nd 3rd degree Liniger dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_HOUBOLT_SCHEME = SOLVER_DYNAMIC_HOUBOLT_SCHEME !<Houbolt dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_WILSON_SCHEME = SOLVER_DYNAMIC_WILSON_SCHEME !<Wilson dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME !<1st Bossak-Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME !<2nd Bossak-Newmark dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DYNAMIC_USER_DEFINED_SCHEME = SOLVER_DYNAMIC_USER_DEFINED_SCHEME !<User specified degree and theta dynamic solver. \see OpenCMISS_DynamicSchemeTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DAETypes OpenCMISS::Solver::DAETypes
  !> \brief The type of differential-algebraic equation.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_DIFFERENTIAL_ONLY = SOLVER_DAE_DIFFERENTIAL_ONLY !<Differential equations only. \see OpenCMISS_DAETypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_INDEX_1 = SOLVER_DAE_INDEX_1 !<Index 1 differential-algebraic equation. \see OpenCMISS_DAETypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_INDEX_2 = SOLVER_DAE_INDEX_2 !<Index 2 differential-algebraic equation. \see OpenCMISS_DAETypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_INDEX_3 = SOLVER_DAE_INDEX_3 !<Index 3 differential-algebraic equation. \see OpenCMISS_DAETypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_DAESolverTypes OpenCMISS::Solver::DAESolverTypes
  !> \brief The differential-algebraic equation solver types for a differential-algebraic equation solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_EULER = SOLVER_DAE_EULER !<Euler differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_CRANK_NICOLSON = SOLVER_DAE_CRANK_NICOLSON !<Crank-Nicolson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_RUNGE_KUTTA = SOLVER_DAE_RUNGE_KUTTA !<Runge-Kutta differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_ADAMS_MOULTON = SOLVER_DAE_ADAMS_MOULTON !<Adams-Moulton differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_BDF = SOLVER_DAE_BDF !<General BDF differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_RUSH_LARSON = SOLVER_DAE_RUSH_LARSON !<Rush-Larson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_EXTERNAL = SOLVER_DAE_EXTERNAL !<External (e.g., CellML generated) differential-algebraic equation solver. \see
  !>@}
  !> \addtogroup OpenCMISS_EulerDAESolverTypes OpenCMISS::Solver::EulerDAESolverTypes
  !> \brief The Euler solver types for a differential-algebriac equation solver.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_EULER_FORWARD = SOLVER_DAE_EULER_FORWARD !<Forward Euler differential equation solver. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_EULER_BACKWARD = SOLVER_DAE_EULER_BACKWARD !<Backward Euler differential equation solver. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_DAE_EULER_IMPROVED = SOLVER_DAE_EULER_IMPROVED !<Improved Euler differential equation solver. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_SolutionInitialiseTypes OpenCMISS::Solver::SolutionInitialiseTypes
  !> \brief The types of solution initialisation.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SOLUTION_INITIALISE_ZERO = SOLVER_SOLUTION_INITIALISE_ZERO !<Initialise the solution by zeroing it before a solve. \see OpenCMISS_SolutionInitialiseTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD = SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD !<Initialise the solution by copying in the current dependent field values. \see OpenCMISS_SolutionInitialiseTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SOLUTION_INITIALISE_NO_CHANGE = SOLVER_SOLUTION_INITIALISE_NO_CHANGE !<Do not change the solution before a solve. \see OpenCMISS_SolutionInitialiseTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_SolverOutputTypes OpenCMISS::Solver::OutputTypes
  !> \brief The types of output.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_NO_OUTPUT = SOLVER_NO_OUTPUT !<No output from the solver routines. \see OpenCMISS_SolverOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_MONITOR_OUTPUT = SOLVER_MONITOR_OUTPUT !<Monitor output from solver routines. \see OpenCMISS_SolverOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_PROGRESS_OUTPUT = SOLVER_PROGRESS_OUTPUT !<Progress output from solver routines. \see OpenCMISS_SolverOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_TIMING_OUTPUT = SOLVER_TIMING_OUTPUT !<Timing output from the solver routines plus below. \see OpenCMISS_SolverOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SOLVER_OUTPUT = SOLVER_SOLVER_OUTPUT !<Solver specific output from the solver routines plus below. \see OpenCMISS_SolverOutputTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_MATRIX_OUTPUT = SOLVER_MATRIX_OUTPUT !<Solver matrices output from the solver routines plus below. \see OpenCMISS_SolverOutputTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_SolverEquationsSparsityTypes OpenCMISS::SolverEquations::SparsityTypes
  !> \brief The types of sparse solver equations matrices.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SPARSE_MATRICES = SOLVER_SPARSE_MATRICES !<Use sparse solver matrices. \see OpenCMISS_SolverEquationsSparsityTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_FULL_MATRICES = SOLVER_FULL_MATRICES !<Use fully populated solver matrices. \see OpenCMISS_SolverEquationsSparsityTypes,OpenCMISS
  !>@}
  !> \addtogroup OpenCMISS_SolverEquationsSymmetryTypes OpenCMISS::SolverEquations::SymmetryTypes
  !> \brief The types of symmetry for the solver equations matrices.
  !> \see OpenCMISS::Solver::Constants,OpenCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: OC_SOLVER_SYMMETRIC_MATRICES = SOLVER_SYMMETRIC_MATRICES !<Use symmetric solver matrices. \see OpenCMISS_SolverEquationsSymmetryTypes,OpenCMISS
  INTEGER(INTG), PARAMETER :: OC_SOLVER_UNSYMMETRIC_MATRICES = SOLVER_UNSYMMETRIC_MATRICES !<Use unsymmetric solver matrices. \see OpenCMISS_SolverEquationsSymmetryTypes,OpenCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the CellML equations for a solver.
  INTERFACE OC_Solver_CellMLEquationsGet
    MODULE PROCEDURE OC_Solver_CellMLEquationsGetNumber0
    MODULE PROCEDURE OC_Solver_CellMLEquationsGetNumber1
    MODULE PROCEDURE OC_Solver_CellMLEquationsGetObj
  END INTERFACE OC_Solver_CellMLEquationsGet

  !>Adds CellML environments to CellML equations.
  INTERFACE OC_CellMLEquations_CellMLAdd
    MODULE PROCEDURE OC_CellMLEquations_CellMLAddNumber0
    MODULE PROCEDURE OC_CellMLEquations_CellMLAddNumber1
    MODULE PROCEDURE OC_CellMLEquations_CellMLAddObj
  END INTERFACE OC_CellMLEquations_CellMLAdd

  !>Returns the linearity type of CellML equations.
  INTERFACE OC_CellMLEquations_LinearityTypeGet
    MODULE PROCEDURE OC_CellMLEquations_LinearityTypeGetNumber
    MODULE PROCEDURE OC_CellMLEquations_LinearityTypeGetObj
  END INTERFACE OC_CellMLEquations_LinearityTypeGet

  !>Sets/changes the linearity type of CellML equations.
  INTERFACE OC_CellMLEquations_LinearityTypeSet
    MODULE PROCEDURE OC_CellMLEquations_LinearityTypeSetNumber
    MODULE PROCEDURE OC_CellMLEquations_LinearityTypeSetObj
  END INTERFACE OC_CellMLEquations_LinearityTypeSet

  !>Returns the time dependence type of CellML equations.
  INTERFACE OC_CellMLEquations_TimeDependenceTypeGet
    MODULE PROCEDURE OC_CellMLEquations_TimeDependenceTypeGetNumber
    MODULE PROCEDURE OC_CellMLEquations_TimeDependenceTypeGetObj
  END INTERFACE OC_CellMLEquations_TimeDependenceTypeGet

  !>Sets/changes the time dependence type of CellML equations.
  INTERFACE OC_CellMLEquations_TimeDependenceTypeSet
    MODULE PROCEDURE OC_CellMLEquations_TimeDependenceTypeSetNumber
    MODULE PROCEDURE OC_CellMLEquations_TimeDependenceTypeSetObj
  END INTERFACE OC_CellMLEquations_TimeDependenceTypeSet

  !>Returns the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeGet???
  INTERFACE OC_Solver_DAEEulerSolverTypeGet
    MODULE PROCEDURE OC_Solver_DAEEulerSolverTypeGetNumber0
    MODULE PROCEDURE OC_Solver_DAEEulerSolverTypeGetNumber1
    MODULE PROCEDURE OC_Solver_DAEEulerSolverTypeGetObj
  END INTERFACE OC_Solver_DAEEulerSolverTypeGet

  !>Sets/changes the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeSet???
  INTERFACE OC_Solver_DAEEulerSolverTypeSet
    MODULE PROCEDURE OC_Solver_DAEEulerSolverTypeSetNumber0
    MODULE PROCEDURE OC_Solver_DAEEulerSolverTypeSetNumber1
    MODULE PROCEDURE OC_Solver_DAEEulerSolverTypeSetObj
  END INTERFACE OC_Solver_DAEEulerSolverTypeSet

  !>Returns the solver type for an differential-algebraic equation solver.
  INTERFACE OC_Solver_DAESolverTypeGet
    MODULE PROCEDURE OC_Solver_DAESolverTypeGetNumber0
    MODULE PROCEDURE OC_Solver_DAESolverTypeGetNumber1
    MODULE PROCEDURE OC_Solver_DAESolverTypeGetObj
  END INTERFACE OC_Solver_DAESolverTypeGet

  !>Sets/changes the solver type for an differential-algebraic equation solver.
  INTERFACE OC_Solver_DAESolverTypeSet
    MODULE PROCEDURE OC_Solver_DAESolverTypeSetNumber0
    MODULE PROCEDURE OC_Solver_DAESolverTypeSetNumber1
    MODULE PROCEDURE OC_Solver_DAESolverTypeSetObj
  END INTERFACE OC_Solver_DAESolverTypeSet

  !>Sets/changes the times for a differential-algebraic equation solver.
  INTERFACE OC_Solver_DAETimesSet
    MODULE PROCEDURE OC_Solver_DAETimesSetNumber0
    MODULE PROCEDURE OC_Solver_DAETimesSetNumber1
    MODULE PROCEDURE OC_Solver_DAETimesSetObj
  END INTERFACE OC_Solver_DAETimesSet

  !>Sets/changes the (initial) time step for a differential-algebraic equation solver.
  INTERFACE OC_Solver_DAETimeStepSet
    MODULE PROCEDURE OC_Solver_DAETimeStepSetNumber0
    MODULE PROCEDURE OC_Solver_DAETimeStepSetNumber1
    MODULE PROCEDURE OC_Solver_DAETimeStepSetObj
  END INTERFACE OC_Solver_DAETimeStepSet

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE OC_Solver_DynamicDegreeGet
    MODULE PROCEDURE OC_Solver_DynamicDegreeGetNumber0
    MODULE PROCEDURE OC_Solver_DynamicDegreeGetNumber1
    MODULE PROCEDURE OC_Solver_DynamicDegreeGetObj
  END INTERFACE OC_Solver_DynamicDegreeGet

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE OC_Solver_DynamicDegreeSet
    MODULE PROCEDURE OC_Solver_DynamicDegreeSetNumber0
    MODULE PROCEDURE OC_Solver_DynamicDegreeSetNumber1
    MODULE PROCEDURE OC_Solver_DynamicDegreeSetObj
  END INTERFACE OC_Solver_DynamicDegreeSet

  !>Returns the linearity type for the dynamic solver.
  INTERFACE OC_Solver_DynamicLinearityTypeGet
    MODULE PROCEDURE OC_Solver_DynamicLinearityTypeGetNumber0
    MODULE PROCEDURE OC_Solver_DynamicLinearityTypeGetNumber1
    MODULE PROCEDURE OC_Solver_DynamicLinearityTypeGetObj
  END INTERFACE OC_Solver_DynamicLinearityTypeGet

  !>Returns the linear solver associated with a linear dynamic solver.
  INTERFACE OC_Solver_DynamicLinearSolverGet
    MODULE PROCEDURE OC_Solver_DynamicLinearSolverGetNumber0
    MODULE PROCEDURE OC_Solver_DynamicLinearSolverGetNumber1
    MODULE PROCEDURE OC_Solver_DynamicLinearSolverGetObj
  END INTERFACE OC_Solver_DynamicLinearSolverGet

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver.
  INTERFACE OC_Solver_DynamicNonlinearSolverGet
    MODULE PROCEDURE OC_Solver_DynamicNonlinearSolverGetNumber0
    MODULE PROCEDURE OC_Solver_DynamicNonlinearSolverGetNumber1
    MODULE PROCEDURE OC_Solver_DynamicNonlinearSolverGetObj
  END INTERFACE OC_Solver_DynamicNonlinearSolverGet

  !>Sets/changes the scheme for a dynamic solver.
  INTERFACE OC_Solver_DynamicSchemeSet
    MODULE PROCEDURE OC_Solver_DynamicSchemeSetNumber0
    MODULE PROCEDURE OC_Solver_DynamicSchemeSetNumber1
    MODULE PROCEDURE OC_Solver_DynamicSchemeSetObj
  END INTERFACE OC_Solver_DynamicSchemeSet

  !>Sets/changes the theta scheme values for a dynamic solver.
  INTERFACE OC_Solver_DynamicThetaSet
    MODULE PROCEDURE OC_Solver_DynamicThetaSetNumber00
    MODULE PROCEDURE OC_Solver_DynamicThetaSetNumber01
    MODULE PROCEDURE OC_Solver_DynamicThetaSetNumber10
    MODULE PROCEDURE OC_Solver_DynamicThetaSetNumber11
    MODULE PROCEDURE OC_Solver_DynamicThetaSetObj0
    MODULE PROCEDURE OC_Solver_DynamicThetaSetObj1
  END INTERFACE OC_Solver_DynamicThetaSet

  !>Sets/changes the dynamic times for a dynamic solver.
  INTERFACE OC_Solver_DynamicTimesSet
    MODULE PROCEDURE OC_Solver_DynamicTimesSetNumber0
    MODULE PROCEDURE OC_Solver_DynamicTimesSetNumber1
    MODULE PROCEDURE OC_Solver_DynamicTimesSetObj
  END INTERFACE OC_Solver_DynamicTimesSet

  !Sets the arbitrary path logical for the transformation
  INTERFACE OC_Solver_GeometricTransformationArbitraryPathSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationArbitraryPathSetNumber
    MODULE PROCEDURE OC_Solver_GeometricTransformationArbitraryPathSetObj
  END INTERFACE OC_Solver_GeometricTransformationArbitraryPathSet

  !Clear transformation for a geometric transformation solver
  INTERFACE OC_Solver_GeometricTransformationClear
    MODULE PROCEDURE OC_Solver_GeometricTransformationClearNumber
    MODULE PROCEDURE OC_Solver_GeometricTransformationClearObj
  END INTERFACE OC_Solver_GeometricTransformationClear

  !Sets the field to transform
  INTERFACE OC_Solver_GeometricTransformationFieldSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationFieldSetNumber
    MODULE PROCEDURE OC_Solver_GeometricTransformationFieldSetObj
  END INTERFACE OC_Solver_GeometricTransformationFieldSet

  !Sets the full transformation matrix for a geometric transformation
  INTERFACE OC_Solver_GeometricTransformationMatrixSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationMatrixSetNumber0
    MODULE PROCEDURE OC_Solver_GeometricTransformationMatrixSetObj0
    MODULE PROCEDURE OC_Solver_GeometricTransformationMatrixSetNumber1
    MODULE PROCEDURE OC_Solver_GeometricTransformationMatrixSetObj1
  END INTERFACE OC_Solver_GeometricTransformationMatrixSet

  !Sets number of load increments for the transformation
  INTERFACE OC_Solver_GeometricTransformationNumberOfLoadIncrementsSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber
    MODULE PROCEDURE OC_Solver_GeometricTransformationNoLoadIncrementsSetObj
  END INTERFACE OC_Solver_GeometricTransformationNumberOfLoadIncrementsSet

  !Sets the rotation for a geometric transformation
  INTERFACE OC_Solver_GeometricTransformationRotationSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationRotationSetNumber0
    MODULE PROCEDURE OC_Solver_GeometricTransformationRotationSetObj0
    MODULE PROCEDURE OC_Solver_GeometricTransformationRotationSetNumber1
    MODULE PROCEDURE OC_Solver_GeometricTransformationRotationSetObj1
  END INTERFACE OC_Solver_GeometricTransformationRotationSet

  !Sets the scalings for a uni-directional geometric transformation
  INTERFACE OC_Solver_GeometricTransformationScalingsSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationScalingsSetNumber
    MODULE PROCEDURE OC_Solver_GeometricTransformationScalingsSetObj
  END INTERFACE OC_Solver_GeometricTransformationScalingsSet

  !Sets the translation for a geometric transformation
  INTERFACE OC_Solver_GeometricTransformationTranslationSet
    MODULE PROCEDURE OC_Solver_GeometricTransformationTranslationSetNumber0
    MODULE PROCEDURE OC_Solver_GeometricTransformationTranslationSetObj0
    MODULE PROCEDURE OC_Solver_GeometricTransformationTranslationSetNumber1
    MODULE PROCEDURE OC_Solver_GeometricTransformationTranslationSetObj1
  END INTERFACE OC_Solver_GeometricTransformationTranslationSet

  !>Returns the label of a solver.
  INTERFACE OC_Solver_LabelGet
    MODULE PROCEDURE OC_Solver_LabelGetCNumber0
    MODULE PROCEDURE OC_Solver_LabelGetCNumber1
    MODULE PROCEDURE OC_Solver_LabelGetCObj
    MODULE PROCEDURE OC_Solver_LabelGetVSNumber0
    MODULE PROCEDURE OC_Solver_LabelGetVSNumber1
    MODULE PROCEDURE OC_Solver_LabelGetVSObj
  END INTERFACE OC_Solver_LabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE OC_Solver_LabelSet
    MODULE PROCEDURE OC_Solver_LabelSetCNumber0
    MODULE PROCEDURE OC_Solver_LabelSetCNumber1
    MODULE PROCEDURE OC_Solver_LabelSetCObj
    MODULE PROCEDURE OC_Solver_LabelSetVSNumber0
    MODULE PROCEDURE OC_Solver_LabelSetVSNumber1
    MODULE PROCEDURE OC_Solver_LabelSetVSObj
  END INTERFACE OC_Solver_LabelSet

  !>Returns the type of library to use for the solver.
  INTERFACE OC_Solver_LibraryTypeGet
    MODULE PROCEDURE OC_Solver_LibraryTypeGetNumber0
    MODULE PROCEDURE OC_Solver_LibraryTypeGetNumber1
    MODULE PROCEDURE OC_Solver_LibraryTypeGetObj
  END INTERFACE OC_Solver_LibraryTypeGet

  !>Sets/changes the type of library to use for the solver.
  INTERFACE OC_Solver_LibraryTypeSet
    MODULE PROCEDURE OC_Solver_LibraryTypeSetNumber0
    MODULE PROCEDURE OC_Solver_LibraryTypeSetNumber1
    MODULE PROCEDURE OC_Solver_LibraryTypeSetObj
  END INTERFACE OC_Solver_LibraryTypeSet

  !>Sets/changes the type of direct linear solver.
  INTERFACE OC_Solver_LinearDirectTypeSet
    MODULE PROCEDURE OC_Solver_LinearDirectTypeSetNumber0
    MODULE PROCEDURE OC_Solver_LinearDirectTypeSetNumber1
    MODULE PROCEDURE OC_Solver_LinearDirectTypeSetObj
  END INTERFACE OC_Solver_LinearDirectTypeSet

  !>Sets/changes the absolute tolerance for an iterative linear solver.
  INTERFACE OC_Solver_LinearIterativeAbsoluteToleranceSet
    MODULE PROCEDURE OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativeAbsoluteToleranceSetObj
  END INTERFACE OC_Solver_LinearIterativeAbsoluteToleranceSet

  !>Sets/changes the divergence tolerance for an iterative linear solver.
  INTERFACE OC_Solver_LinearIterativeDivergenceToleranceSet
    MODULE PROCEDURE OC_Solver_LinearIterativeDivergenceToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativeDivergenceToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativeDivergenceToleranceSetObj
  END INTERFACE OC_Solver_LinearIterativeDivergenceToleranceSet

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver.
  INTERFACE OC_Solver_LinearIterativeGMRESRestartSet
    MODULE PROCEDURE OC_Solver_LinearIterativeGMRESRestartSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativeGMRESRestartSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativeGMRESRestartSetObj
  END INTERFACE OC_Solver_LinearIterativeGMRESRestartSet

  !>Sets/changes the maximum number of iterations for an iterative linear solver.
  INTERFACE OC_Solver_LinearIterativeMaximumIterationsSet
    MODULE PROCEDURE OC_Solver_LinearIterativeMaximumIterationsSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativeMaximumIterationsSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativeMaximumIterationsSetObj
  END INTERFACE OC_Solver_LinearIterativeMaximumIterationsSet

  !>Sets/changes the type of preconditioner for an iterative linear solver.
  INTERFACE OC_Solver_LinearIterativePreconditionerTypeSet
    MODULE PROCEDURE OC_Solver_LinearIterativePreconditionerTypeSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativePreconditionerTypeSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativePreconditionerTypeSetObj
  END INTERFACE OC_Solver_LinearIterativePreconditionerTypeSet

  !>Sets/changes the relative tolerance for an iterative linear solver.
  INTERFACE OC_Solver_LinearIterativeRelativeToleranceSet
    MODULE PROCEDURE OC_Solver_LinearIterativeRelativeToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativeRelativeToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativeRelativeToleranceSetObj
  END INTERFACE OC_Solver_LinearIterativeRelativeToleranceSet

  !>Sets/changes the type of iterative linear solver.
  INTERFACE OC_Solver_LinearIterativeTypeSet
    MODULE PROCEDURE OC_Solver_LinearIterativeTypeSetNumber0
    MODULE PROCEDURE OC_Solver_LinearIterativeTypeSetNumber1
    MODULE PROCEDURE OC_Solver_LinearIterativeTypeSetObj
  END INTERFACE OC_Solver_LinearIterativeTypeSet

  !>Sets/changes the type of linear solver.
  INTERFACE OC_Solver_LinearTypeSet
    MODULE PROCEDURE OC_Solver_LinearTypeSetNumber0
    MODULE PROCEDURE OC_Solver_LinearTypeSetNumber1
    MODULE PROCEDURE OC_Solver_LinearTypeSetObj
  END INTERFACE OC_Solver_LinearTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonAbsoluteToleranceSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonAbsoluteToleranceSetObj
  END INTERFACE OC_Solver_QuasiNewtonAbsoluteToleranceSet

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver.
  INTERFACE OC_Solver_QuasiNewtonLineSearchMonitorOutputSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj
  END INTERFACE OC_Solver_QuasiNewtonLineSearchMonitorOutputSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonJacobianCalculationTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonLinearSolverGet
    MODULE PROCEDURE OC_Solver_QuasiNewtonLinearSolverGetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonLinearSolverGetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonLinearSolverGetObj
  END INTERFACE OC_Solver_QuasiNewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonCellMLSolverGet
    MODULE PROCEDURE OC_Solver_QuasiNewtonCellMLSolverGetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonCellMLSolverGetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonCellMLSolverGetObj
  END INTERFACE OC_Solver_QuasiNewtonCellMLSolverGet

  !>Sets/change the convergence test for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonConvergenceTestTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonConvergenceTestTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonConvergenceTestTypeSet

  !>Sets/changes the line search maximum step for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonLineSearchMaxStepSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchMaxStepSetObj
  END INTERFACE OC_Solver_QuasiNewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonLineSearchStepTolSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchStepTolSetObj
  END INTERFACE OC_Solver_QuasiNewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonLineSearchTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonLineSearchTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonMaximumIterationsSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonMaximumIterationsSetObj
  END INTERFACE OC_Solver_QuasiNewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonRelativeToleranceSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonRelativeToleranceSetObj
  END INTERFACE OC_Solver_QuasiNewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonSolutionToleranceSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonSolutionToleranceSetObj
  END INTERFACE OC_Solver_QuasiNewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Quasi-Newton trust region solver.
  INTERFACE OC_Solver_QuasiNewtonTrustRegionDelta0Set
    MODULE PROCEDURE OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonTrustRegionDelta0SetObj
  END INTERFACE OC_Solver_QuasiNewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Quasi-Newton trust region solver.
  INTERFACE OC_Solver_QuasiNewtonTrustRegionToleranceSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonTrustRegionToleranceSetObj
  END INTERFACE OC_Solver_QuasiNewtonTrustRegionToleranceSet

  !>Sets/changes the nonlinear Quasi-Newton restart.
  INTERFACE OC_Solver_QuasiNewtonRestartSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonRestartSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonRestartSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonRestartSetObj
  END INTERFACE OC_Solver_QuasiNewtonRestartSet

  !>Sets/changes the nonlinear Quasi-Newton restart type.
  INTERFACE OC_Solver_QuasiNewtonRestartTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonRestartTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonRestartTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonRestartTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonRestartTypeSet

  !>Sets/changes the nonlinear Quasi-Newton scale type.
  INTERFACE OC_Solver_QuasiNewtonScaleTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonScaleTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonScaleTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonScaleTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonScaleTypeSet

  !>Sets/changes the type of nonlinear Quasi-Newton solver.
  INTERFACE OC_Solver_QuasiNewtonSolveTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonSolveTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonSolveTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonSolveTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonSolveTypeSet

  !>Sets/changes the nonlinear Quasi-Newton type.
  INTERFACE OC_Solver_QuasiNewtonTypeSet
    MODULE PROCEDURE OC_Solver_QuasiNewtonTypeSetNumber0
    MODULE PROCEDURE OC_Solver_QuasiNewtonTypeSetNumber1
    MODULE PROCEDURE OC_Solver_QuasiNewtonTypeSetObj
  END INTERFACE OC_Solver_QuasiNewtonTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonAbsoluteToleranceSet
    MODULE PROCEDURE OC_Solver_NewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonAbsoluteToleranceSetObj
  END INTERFACE OC_Solver_NewtonAbsoluteToleranceSet

  !>Enables/disables output monitoring for a nonlinear Newton line search solver.
  INTERFACE OC_Solver_NewtonLineSearchMonitorOutputSet
    MODULE PROCEDURE OC_Solver_NewtonLineSearchMonitorOutputSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonLineSearchMonitorOutputSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonLineSearchMonitorOutputSetObj
  END INTERFACE OC_Solver_NewtonLineSearchMonitorOutputSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonJacobianCalculationTypeSet
    MODULE PROCEDURE OC_Solver_NewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonJacobianCalculationTypeSetObj
  END INTERFACE OC_Solver_NewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonLinearSolverGet
    MODULE PROCEDURE OC_Solver_NewtonLinearSolverGetNumber0
    MODULE PROCEDURE OC_Solver_NewtonLinearSolverGetNumber1
    MODULE PROCEDURE OC_Solver_NewtonLinearSolverGetObj
  END INTERFACE OC_Solver_NewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonCellMLSolverGet
    MODULE PROCEDURE OC_Solver_NewtonCellMLSolverGetNumber0
    MODULE PROCEDURE OC_Solver_NewtonCellMLSolverGetNumber1
    MODULE PROCEDURE OC_Solver_NewtonCellMLSolverGetObj
  END INTERFACE OC_Solver_NewtonCellMLSolverGet

  !>Sets/change the convergence test for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonConvergenceTestTypeSet
    MODULE PROCEDURE OC_Solver_NewtonConvergenceTestTypeSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonConvergenceTestTypeSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonConvergenceTestTypeSetObj
  END INTERFACE OC_Solver_NewtonConvergenceTestTypeSet

  !>Sets/changes the line search alpha for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonLineSearchAlphaSet
    MODULE PROCEDURE OC_Solver_NewtonLineSearchAlphaSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonLineSearchAlphaSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonLineSearchAlphaSetObj
  END INTERFACE OC_Solver_NewtonLineSearchAlphaSet

  !>Sets/changes the line search maximum step for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonLineSearchMaxStepSet
    MODULE PROCEDURE OC_Solver_NewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonLineSearchMaxStepSetObj
  END INTERFACE OC_Solver_NewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonLineSearchStepTolSet
    MODULE PROCEDURE OC_Solver_NewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonLineSearchStepTolSetObj
  END INTERFACE OC_Solver_NewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonLineSearchTypeSet
    MODULE PROCEDURE OC_Solver_NewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonLineSearchTypeSetObj
  END INTERFACE OC_Solver_NewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE OC_Solver_NewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonMaximumIterationsSet
    MODULE PROCEDURE OC_Solver_NewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonMaximumIterationsSetObj
  END INTERFACE OC_Solver_NewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonRelativeToleranceSet
    MODULE PROCEDURE OC_Solver_NewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonRelativeToleranceSetObj
  END INTERFACE OC_Solver_NewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Newton solver.
  INTERFACE OC_Solver_NewtonSolutionToleranceSet
    MODULE PROCEDURE OC_Solver_NewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonSolutionToleranceSetObj
  END INTERFACE OC_Solver_NewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Newton trust region solver.
  INTERFACE OC_Solver_NewtonTrustRegionDelta0Set
    MODULE PROCEDURE OC_Solver_NewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE OC_Solver_NewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE OC_Solver_NewtonTrustRegionDelta0SetObj
  END INTERFACE OC_Solver_NewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver.
  INTERFACE OC_Solver_NewtonTrustRegionToleranceSet
    MODULE PROCEDURE OC_Solver_NewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonTrustRegionToleranceSetObj
  END INTERFACE OC_Solver_NewtonTrustRegionToleranceSet

  !>Sets/changes the type of nonlinear Newton trust region solver.
  INTERFACE OC_Solver_NewtonTypeSet
    MODULE PROCEDURE OC_Solver_NewtonTypeSetNumber0
    MODULE PROCEDURE OC_Solver_NewtonTypeSetNumber1
    MODULE PROCEDURE OC_Solver_NewtonTypeSetObj
  END INTERFACE OC_Solver_NewtonTypeSet

  !>Sets/changes the type of nonlinear solver.
  INTERFACE OC_Solver_NonlinearTypeSet
    MODULE PROCEDURE OC_Solver_NonlinearTypeSetNumber0
    MODULE PROCEDURE OC_Solver_NonlinearTypeSetNumber1
    MODULE PROCEDURE OC_Solver_NonlinearTypeSetObj
  END INTERFACE OC_Solver_NonlinearTypeSet

  !>Sets/changes the output type for a solver.
  INTERFACE OC_Solver_OutputTypeSet
    MODULE PROCEDURE OC_Solver_OutputTypeSetNumber0
    MODULE PROCEDURE OC_Solver_OutputTypeSetNumber1
    MODULE PROCEDURE OC_Solver_OutputTypeSetObj
  END INTERFACE OC_Solver_OutputTypeSet

  !>Returns the solver equations for a solver.
  INTERFACE OC_Solver_SolverEquationsGet
    MODULE PROCEDURE OC_Solver_SolverEquationsGetNumber0
    MODULE PROCEDURE OC_Solver_SolverEquationsGetNumber1
    MODULE PROCEDURE OC_Solver_SolverEquationsGetObj
  END INTERFACE OC_Solver_SolverEquationsGet

  !>Adds equations sets to solver equations.
  INTERFACE OC_SolverEquations_EquationsSetAdd
    MODULE PROCEDURE OC_SolverEquations_EquationsSetAddNumber0
    MODULE PROCEDURE OC_SolverEquations_EquationsSetAddNumber1
    MODULE PROCEDURE OC_SolverEquations_EquationsSetAddObj
  END INTERFACE OC_SolverEquations_EquationsSetAdd

  !>Adds an interface condition to solver equations.
  INTERFACE OC_SolverEquations_InterfaceConditionAdd
    MODULE PROCEDURE OC_SolverEquations_InterfaceConditionAddNumber0
    MODULE PROCEDURE OC_SolverEquations_InterfaceConditionAddNumber1
    MODULE PROCEDURE OC_SolverEquations_InterfaceConditionAddObj
  END INTERFACE OC_SolverEquations_InterfaceConditionAdd

  !>Gets the sparsity type for solver equations.
  INTERFACE OC_SolverEquations_SparsityTypeGet
    MODULE PROCEDURE OC_SolverEquations_SparsityTypeGetNumber0
    MODULE PROCEDURE OC_SolverEquations_SparsityTypeGetNumber1
    MODULE PROCEDURE OC_SolverEquations_SparsityTypeGetObj
  END INTERFACE OC_SolverEquations_SparsityTypeGet

  !>Sets/changes the sparsity type for solver equations.
  INTERFACE OC_SolverEquations_SparsityTypeSet
    MODULE PROCEDURE OC_SolverEquations_SparsityTypeSetNumber0
    MODULE PROCEDURE OC_SolverEquations_SparsityTypeSetNumber1
    MODULE PROCEDURE OC_SolverEquations_SparsityTypeSetObj
  END INTERFACE OC_SolverEquations_SparsityTypeSet

  !>Gets the symmetry type for solver equations.
  INTERFACE OC_SolverEquations_SymmetryTypeGet
    MODULE PROCEDURE OC_SolverEquations_SymmetryTypeGetNumber0
    MODULE PROCEDURE OC_SolverEquations_SymmetryTypeGetNumber1
    MODULE PROCEDURE OC_SolverEquations_SymmetryTypeGetObj
  END INTERFACE OC_SolverEquations_SymmetryTypeGet

  !>Sets/changes the symmetry type for solver equations.
  INTERFACE OC_SolverEquations_SymmetryTypeSet
    MODULE PROCEDURE OC_SolverEquations_SymmetryTypeSetNumber0
    MODULE PROCEDURE OC_SolverEquations_SymmetryTypeSetNumber1
    MODULE PROCEDURE OC_SolverEquations_SymmetryTypeSetObj
  END INTERFACE OC_SolverEquations_SymmetryTypeSet

  !>Finish the creation of boundary conditions for solver equations. \see OpenCMISS::OC_SolverEquations_BoundaryConditionsCreateStart
  INTERFACE OC_SolverEquations_BoundaryConditionsCreateFinish
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsCreateFinishNumber0
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsCreateFinishNumber1
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsCreateFinishObj
  END INTERFACE OC_SolverEquations_BoundaryConditionsCreateFinish

  !>Start the creation of boundary conditions for solver equations. \see OpenCMISS::OC_SolverEquations_BoundaryConditionsCreateFinish
  INTERFACE OC_SolverEquations_BoundaryConditionsCreateStart
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsCreateStartNumber0
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsCreateStartNumber1
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsCreateStartObj
  END INTERFACE OC_SolverEquations_BoundaryConditionsCreateStart

  !>Get the boundary conditions for solver equations. \see OpenCMISS::OC_SolverEquations_BoundaryConditionsCreateFinish
  INTERFACE OC_SolverEquations_BoundaryConditionsGet
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsGetNumber0
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsGetNumber1
    MODULE PROCEDURE OC_SolverEquations_BoundaryConditionsGetObj
  END INTERFACE OC_SolverEquations_BoundaryConditionsGet

  PUBLIC OC_CELLML_EQUATIONS_LINEAR,OC_CELLML_EQUATIONS_NONLINEAR

  PUBLIC OC_CELLML_EQUATIONS_STATIC,OC_CELLML_EQUATIONS_QUASISTATIC,OC_CELLML_EQUATIONS_DYNAMIC

  PUBLIC OC_SOLVER_LINEAR_TYPE,OC_SOLVER_NONLINEAR_TYPE,OC_SOLVER_DYNAMIC_TYPE,OC_SOLVER_DAE_TYPE, &
    & OC_SOLVER_EIGENPROBLEM_TYPE, &
    & OC_SOLVER_OPTIMISER_TYPE

  PUBLIC OC_SOLVER_CMISS_LIBRARY,OC_SOLVER_PETSC_LIBRARY,OC_SOLVER_MUMPS_LIBRARY,OC_SOLVER_SUPERLU_LIBRARY, &
    & OC_SOLVER_SPOOLES_LIBRARY,OC_SOLVER_UMFPACK_LIBRARY,OC_SOLVER_LUSOL_LIBRARY,OC_SOLVER_ESSL_LIBRARY, &
    & OC_SOLVER_LAPACK_LIBRARY,OC_SOLVER_HYPRE_LIBRARY,OC_SOLVER_PASTIX_LIBRARY

  PUBLIC OC_SOLVER_LINEAR_DIRECT_SOLVE_TYPE,OC_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE

  PUBLIC OC_SOLVER_DIRECT_LU,OC_SOLVER_DIRECT_CHOLESKY,OC_SOLVER_DIRECT_SVD

  PUBLIC OC_SOLVER_ITERATIVE_RICHARDSON,OC_SOLVER_ITERATIVE_CONJUGATE_GRADIENT,OC_SOLVER_ITERATIVE_CHEBYSHEV, &
    & OC_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT,OC_SOLVER_ITERATIVE_GMRES,OC_SOLVER_ITERATIVE_BiCGSTAB, &
    & OC_SOLVER_ITERATIVE_CONJGRAD_SQUARED

  PUBLIC OC_SOLVER_ITERATIVE_NO_PRECONDITIONER,OC_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER, &
    & OC_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER,OC_SOLVER_ITERATIVE_SOR_PRECONDITIONER, &
    & OC_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER,OC_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER, &
    & OC_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER

  PUBLIC OC_SOLVER_NONLINEAR_NEWTON,OC_SOLVER_NONLINEAR_BFGS_INVERSE,OC_SOLVER_NONLINEAR_SQP

  PUBLIC OC_SOLVER_NONLINEAR_QUASI_NEWTON

  PUBLIC OC_SOLVER_QUASI_NEWTON_LINESEARCH,OC_SOLVER_QUASI_NEWTON_TRUSTREGION

  PUBLIC OC_SOLVER_QUASI_NEWTON_LBFGS,OC_SOLVER_QUASI_NEWTON_GOODBROYDEN,OC_SOLVER_QUASI_NEWTON_BADBROYDEN

  PUBLIC OC_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC,OC_SOLVER_QUASI_NEWTON_LINESEARCH_L2, &
    & OC_SOLVER_QUASI_NEWTON_LINESEARCH_CP

  PUBLIC OC_SOLVER_QUASI_NEWTON_RESTART_NONE,OC_SOLVER_QUASI_NEWTON_RESTART_POWELL, &
    & OC_SOLVER_QUASI_NEWTON_RESTART_PERIODIC

  PUBLIC OC_SOLVER_QUASI_NEWTON_SCALE_NONE,OC_SOLVER_QUASI_NEWTON_SCALE_SHANNO, &
    & OC_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH,OC_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN

  PUBLIC OC_SOLVER_NEWTON_LINESEARCH,OC_SOLVER_NEWTON_TRUSTREGION

  PUBLIC OC_SOLVER_NEWTON_LINESEARCH_LINEAR,OC_SOLVER_NEWTON_LINESEARCH_QUADRATIC,OC_SOLVER_NEWTON_LINESEARCH_CUBIC

  PUBLIC OC_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED,OC_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED, &
    & OC_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED

  PUBLIC OC_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT,OC_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM, &
    & OC_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO

  PUBLIC OC_SOLVER_DYNAMIC_FIRST_ORDER,OC_SOLVER_DYNAMIC_SECOND_ORDER

  PUBLIC OC_SOLVER_DYNAMIC_LINEAR,OC_SOLVER_DYNAMIC_NONLINEAR

  PUBLIC OC_SOLVER_DYNAMIC_FIRST_DEGREE,OC_SOLVER_DYNAMIC_SECOND_DEGREE,OC_SOLVER_DYNAMIC_THIRD_DEGREE

  PUBLIC OC_SOLVER_DYNAMIC_EULER_SCHEME,OC_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME,OC_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME, &
    & OC_SOLVER_DYNAMIC_GALERKIN_SCHEME,OC_SOLVER_DYNAMIC_ZLAMAL_SCHEME,OC_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME, &
    & OC_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME,OC_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME, &
    & OC_SOLVER_DYNAMIC_NEWMARK1_SCHEME,OC_SOLVER_DYNAMIC_NEWMARK2_SCHEME,OC_SOLVER_DYNAMIC_NEWMARK3_SCHEME, &
    & OC_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME,OC_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME, &
    & OC_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME,OC_SOLVER_DYNAMIC_HOUBOLT_SCHEME,OC_SOLVER_DYNAMIC_WILSON_SCHEME, &
    & OC_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME,OC_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME, &
    & OC_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME, &
    & OC_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME,OC_SOLVER_DYNAMIC_USER_DEFINED_SCHEME

  PUBLIC OC_SOLVER_DAE_DIFFERENTIAL_ONLY,OC_SOLVER_DAE_INDEX_1,OC_SOLVER_DAE_INDEX_2,OC_SOLVER_DAE_INDEX_3

  PUBLIC OC_SOLVER_DAE_EULER,OC_SOLVER_DAE_CRANK_NICOLSON,OC_SOLVER_DAE_RUNGE_KUTTA,OC_SOLVER_DAE_ADAMS_MOULTON, &
    & OC_SOLVER_DAE_BDF, &
    & OC_SOLVER_DAE_RUSH_LARSON,OC_SOLVER_DAE_EXTERNAL

  PUBLIC OC_SOLVER_DAE_EULER_FORWARD,OC_SOLVER_DAE_EULER_BACKWARD,OC_SOLVER_DAE_EULER_IMPROVED

  PUBLIC OC_SOLVER_SOLUTION_INITIALISE_ZERO,OC_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD, &
    & OC_SOLVER_SOLUTION_INITIALISE_NO_CHANGE

  PUBLIC OC_SOLVER_NO_OUTPUT,OC_SOLVER_MONITOR_OUTPUT,OC_SOLVER_PROGRESS_OUTPUT,OC_SOLVER_TIMING_OUTPUT, &
    & OC_SOLVER_SOLVER_OUTPUT,OC_SOLVER_MATRIX_OUTPUT

  PUBLIC OC_SOLVER_SPARSE_MATRICES,OC_SOLVER_FULL_MATRICES

  PUBLIC OC_SOLVER_SYMMETRIC_MATRICES,OC_SOLVER_UNSYMMETRIC_MATRICES

  PUBLIC OC_Solver_CellMLEquationsGet

  PUBLIC OC_CellMLEquations_CellMLAdd

  PUBLIC OC_CellMLEquations_LinearityTypeGet,OC_CellMLEquations_LinearityTypeSet

  PUBLIC OC_CellMLEquations_TimeDependenceTypeGet,OC_CellMLEquations_TimeDependenceTypeSet

  PUBLIC OC_Solver_DAEEulerSolverTypeGet,OC_Solver_DAEEulerSolverTypeSet

  PUBLIC OC_Solver_DAESolverTypeGet,OC_Solver_DAESolverTypeSet

  PUBLIC OC_Solver_DAETimesSet,OC_Solver_DAETimeStepSet

  PUBLIC OC_Solver_DynamicDegreeGet,OC_Solver_DynamicDegreeSet

  PUBLIC OC_Solver_DynamicLinearityTypeGet

  PUBLIC OC_Solver_DynamicLinearSolverGet,OC_Solver_DynamicNonlinearSolverGet

  PUBLIC OC_Solver_DynamicSchemeSet

  PUBLIC OC_Solver_DynamicThetaSet

  PUBLIC OC_Solver_DynamicTimesSet

  PUBLIC OC_Solver_GeometricTransformationArbitraryPathSet,OC_Solver_GeometricTransformationClear

  PUBLIC OC_Solver_GeometricTransformationNumberOfLoadIncrementsSet

  PUBLIC OC_Solver_GeometricTransformationScalingsSet

  PUBLIC OC_Solver_GeometricTransformationFieldSet

  PUBLIC OC_Solver_GeometricTransformationMatrixSet

  PUBLIC OC_Solver_GeometricTransformationRotationSet,OC_Solver_GeometricTransformationTranslationSet

  PUBLIC OC_Solver_LabelGet,OC_Solver_LabelSet

  PUBLIC OC_Solver_LibraryTypeGet,OC_Solver_LibraryTypeSet

  PUBLIC OC_Solver_LinearDirectTypeSet

  PUBLIC OC_Solver_MumpsSetIcntl,OC_Solver_MumpsSetCntl

  PUBLIC OC_Solver_LinearIterativeAbsoluteToleranceSet

  PUBLIC OC_Solver_LinearIterativeDivergenceToleranceSet

  PUBLIC OC_Solver_LinearIterativeGMRESRestartSet

  PUBLIC OC_Solver_LinearIterativeMaximumIterationsSet

  PUBLIC OC_Solver_LinearIterativePreconditionerTypeSet

  PUBLIC OC_Solver_LinearIterativeRelativeToleranceSet

  PUBLIC OC_Solver_LinearIterativeTypeSet

  PUBLIC OC_Solver_LinearTypeSet

  PUBLIC OC_Solver_NewtonAbsoluteToleranceSet

  PUBLIC OC_Solver_NewtonLineSearchMonitorOutputSet

  PUBLIC OC_Solver_NewtonJacobianCalculationTypeSet

  PUBLIC OC_Solver_NewtonLinearSolverGet

  PUBLIC OC_Solver_NewtonCellMLSolverGet

  PUBLIC OC_Solver_NewtonConvergenceTestTypeSet

  PUBLIC OC_Solver_NewtonLineSearchAlphaSet

  PUBLIC OC_Solver_NewtonLineSearchMaxStepSet

  PUBLIC OC_Solver_NewtonLineSearchStepTolSet

  PUBLIC OC_Solver_NewtonLineSearchTypeSet

  PUBLIC OC_Solver_NewtonMaximumFunctionEvaluationsSet

  PUBLIC OC_Solver_NewtonMaximumIterationsSet

  PUBLIC OC_Solver_NewtonRelativeToleranceSet

  PUBLIC OC_Solver_NewtonSolutionToleranceSet

  PUBLIC OC_Solver_NewtonTrustRegionDelta0Set

  PUBLIC OC_Solver_NewtonTrustRegionToleranceSet

  PUBLIC OC_Solver_NewtonTypeSet

  PUBLIC OC_Solver_QuasiNewtonAbsoluteToleranceSet

  PUBLIC OC_Solver_QuasiNewtonLineSearchMonitorOutputSet

  PUBLIC OC_Solver_QuasiNewtonJacobianCalculationTypeSet

  PUBLIC OC_Solver_QuasiNewtonLinearSolverGet

  PUBLIC OC_Solver_QuasiNewtonCellMLSolverGet

  PUBLIC OC_Solver_QuasiNewtonConvergenceTestTypeSet

  PUBLIC OC_Solver_QuasiNewtonLineSearchMaxStepSet

  PUBLIC OC_Solver_QuasiNewtonLineSearchStepTolSet

  PUBLIC OC_Solver_QuasiNewtonLineSearchTypeSet

  PUBLIC OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSet

  PUBLIC OC_Solver_QuasiNewtonMaximumIterationsSet

  PUBLIC OC_Solver_QuasiNewtonRelativeToleranceSet

  PUBLIC OC_Solver_QuasiNewtonSolutionToleranceSet

  PUBLIC OC_Solver_QuasiNewtonTrustRegionDelta0Set

  PUBLIC OC_Solver_QuasiNewtonTrustRegionToleranceSet

  PUBLIC OC_Solver_QuasiNewtonRestartSet

  PUBLIC OC_Solver_QuasiNewtonRestartTypeSet

  PUBLIC OC_Solver_QuasiNewtonScaleTypeSet

  PUBLIC OC_Solver_QuasiNewtonSolveTypeSet

  PUBLIC OC_Solver_QuasiNewtonTypeSet

  PUBLIC OC_Solver_NonlinearTypeSet

  PUBLIC OC_Solver_OutputTypeSet

  PUBLIC OC_Solver_SolverEquationsGet

  PUBLIC OC_SolverEquations_BoundaryConditionsCreateFinish,OC_SolverEquations_BoundaryConditionsCreateStart

  PUBLIC OC_SolverEquations_BoundaryConditionsGet

  PUBLIC OC_SolverEquations_EquationsSetAdd

  PUBLIC OC_SolverEquations_InterfaceConditionAdd

  PUBLIC OC_SolverEquations_JacobianMatrixGet

  PUBLIC OC_SolverEquations_MatrixGet

  PUBLIC OC_SolverEquations_NumberOfMatricesGet

  PUBLIC OC_SolverEquations_ResidualVectorGet

  PUBLIC OC_SolverEquations_RHSVectorGet

  PUBLIC OC_SolverEquations_SparsityTypeGet,OC_SolverEquations_SparsityTypeSet

  PUBLIC OC_SolverEquations_SymmetryTypeGet,OC_SolverEquations_SymmetryTypeSet

  PUBLIC OC_SolverEquations_VectorGet

  PUBLIC OC_BioelectricsFiniteElasticity_UpdateGeometricField

  !==================================================================================================================================
  !
  ! FieldML routines
  !
  !==================================================================================================================================

  !> Provides input and output of fields through the FieldML API
  TYPE OC_FieldMLIOType
    PRIVATE
#ifdef WITH_FIELDML
    TYPE(FIELDML_IO_TYPE), POINTER :: fieldmlInfo
#endif
  END TYPE OC_FieldMLIOType

  !> Creates a mesh component using the given FieldML evaluator.
  INTERFACE OC_FieldML_InputCreateMeshComponent
    MODULE PROCEDURE OC_FieldML_InputCreateMeshComponentObjVS
    MODULE PROCEDURE OC_FieldML_InputCreateMeshComponentNumberVS
    MODULE PROCEDURE OC_FieldML_InputCreateMeshComponentObjC
    MODULE PROCEDURE OC_FieldML_InputCreateMeshComponentNumberC
  END INTERFACE OC_FieldML_InputCreateMeshComponent

  !> Creates a field component using the given FieldML evaluator.
  INTERFACE OC_FieldML_InputFieldCreateStart
    MODULE PROCEDURE OC_FieldML_InputFieldCreateStartObjVS
    MODULE PROCEDURE OC_FieldML_InputFieldCreateStartNumberVS
    MODULE PROCEDURE OC_FieldML_InputFieldCreateStartObjC
    MODULE PROCEDURE OC_FieldML_InputFieldCreateStartNumberC
  END INTERFACE OC_FieldML_InputFieldCreateStart

  !> Updates the given field's dofs using the given parameter evaluator.
  INTERFACE OC_FieldML_InputFieldParametersUpdate
    MODULE PROCEDURE OC_FieldML_InputFieldParametersUpdateObjVS
    MODULE PROCEDURE OC_FieldML_InputFieldParametersUpdateNumberVS
    MODULE PROCEDURE OC_FieldML_InputFieldParametersUpdateObjC
    MODULE PROCEDURE OC_FieldML_InputFieldParametersUpdateNumberC
  END INTERFACE OC_FieldML_InputFieldParametersUpdate

  !> Creates a basis using the given FieldML evaluator.
  INTERFACE OC_FieldML_InputBasisCreateStart
    MODULE PROCEDURE OC_FieldML_InputBasisCreateStartObjVS
    MODULE PROCEDURE OC_FieldML_InputBasisCreateStartNumberVS
    MODULE PROCEDURE OC_FieldML_InputBasisCreateStartObjC
    MODULE PROCEDURE OC_FieldML_InputBasisCreateStartNumberC
  END INTERFACE OC_FieldML_InputBasisCreateStart

  !> Creates the region's nodes using the given FieldML evaluator.
  INTERFACE OC_FieldML_InputNodesCreateStart
    MODULE PROCEDURE OC_FieldML_InputNodesCreateStartObjVS
    MODULE PROCEDURE OC_FieldML_InputNodesCreateStartNumberVS
    MODULE PROCEDURE OC_FieldML_InputNodesCreateStartObjC
    MODULE PROCEDURE OC_FieldML_InputNodesCreateStartNumberC
  END INTERFACE OC_FieldML_InputNodesCreateStart

  !> Creates the region's coordinate system using the given FieldML evaluator.
  INTERFACE OC_FieldML_InputCoordinateSystemCreateStart
    MODULE PROCEDURE OC_FieldML_InputCoordinateSystemCreateStartObjVS
    MODULE PROCEDURE OC_FieldML_InputCoordinateSystemCreateStartNumberVS
    MODULE PROCEDURE OC_FieldML_InputCoordinateSystemCreateStartObjC
    MODULE PROCEDURE OC_FieldML_InputCoordinateSystemCreateStartNumberC
  END INTERFACE OC_FieldML_InputCoordinateSystemCreateStart

  !> Creates a mesh using the given FieldML evaluator.
  INTERFACE OC_FieldML_InputMeshCreateStart
    MODULE PROCEDURE OC_FieldML_InputMeshCreateStartObjVS
    MODULE PROCEDURE OC_FieldML_InputMeshCreateStartNumberVS
    MODULE PROCEDURE OC_FieldML_InputMeshCreateStartObjC
    MODULE PROCEDURE OC_FieldML_InputMeshCreateStartNumberC
  END INTERFACE OC_FieldML_InputMeshCreateStart

  !> Initialise the given FieldML context using the given FieldML XML file.
  INTERFACE OC_FieldML_InputCreateFromFile
    MODULE PROCEDURE OC_FieldML_InputCreateFromFileVS
    MODULE PROCEDURE OC_FieldML_InputCreateFromFileC
  END INTERFACE OC_FieldML_InputCreateFromFile

  PUBLIC :: OC_FieldML_InputCreateFromFile,OC_FieldML_InputMeshCreateStart, &
    & OC_FieldML_InputCoordinateSystemCreateStart,OC_FieldML_InputCreateMeshComponent, &
    & OC_FieldML_InputFieldCreateStart,OC_FieldML_InputBasisCreateStart,OC_FieldML_InputNodesCreateStart, &
    & OC_FieldML_InputFieldParametersUpdate

  PUBLIC :: OC_FieldMLIO_Finalise,OC_FieldMLIO_Initialise,OC_FieldMLIO_GetSession

  !> Add the given field to the current FieldML context.
  INTERFACE OC_FieldML_OutputAddField
    MODULE PROCEDURE OC_FieldML_OutputAddFieldNoTypeObjVS
    MODULE PROCEDURE OC_FieldML_OutputAddFieldNoTypeNumberVS
    MODULE PROCEDURE OC_FieldML_OutputAddFieldWithTypeObjVS
    MODULE PROCEDURE OC_FieldML_OutputAddFieldWithTypeNumberVS
    MODULE PROCEDURE OC_FieldML_OutputAddFieldNoTypeObjC
    MODULE PROCEDURE OC_FieldML_OutputAddFieldNoTypeNumberC
    MODULE PROCEDURE OC_FieldML_OutputAddFieldWithTypeObjC
    MODULE PROCEDURE OC_FieldML_OutputAddFieldWithTypeNumberC
  END INTERFACE OC_FieldML_OutputAddField

  !> Initialise a new FieldML context.
  INTERFACE OC_FieldML_OutputCreate
    MODULE PROCEDURE OC_FieldML_OutputCreateObjVS
    MODULE PROCEDURE OC_FieldML_OutputCreateNumberVS
    MODULE PROCEDURE OC_FieldML_OutputCreateObjC
    MODULE PROCEDURE OC_FieldML_OutputCreateNumberC
  END INTERFACE OC_FieldML_OutputCreate

  !> Add the given field to the current FieldML context, using only the given components.
  INTERFACE OC_FieldML_OutputAddFieldComponents
    MODULE PROCEDURE OC_FieldML_OutputAddFieldComponentsObjVS
    MODULE PROCEDURE OC_FieldML_OutputAddFieldComponentsNumberVS
    MODULE PROCEDURE OC_FieldML_OutputAddFieldComponentsObjC
    MODULE PROCEDURE OC_FieldML_OutputAddFieldComponentsNumberC
  END INTERFACE OC_FieldML_OutputAddFieldComponents

  !> Write the current FieldML document to the given file.
  INTERFACE OC_FieldML_OutputWrite
    MODULE PROCEDURE OC_FieldML_OutputWriteVS
    MODULE PROCEDURE OC_FieldML_OutputWriteC
  END INTERFACE OC_FieldML_OutputWrite

  PUBLIC :: OC_FieldMLIOType

  PUBLIC :: OC_FieldML_OutputWrite,OC_FieldML_OutputAddField,OC_FieldML_OutputCreate, &
    & OC_FieldML_OutputAddFieldComponents, &
    & OC_FieldML_OutputAddImport

  !==================================================================================================================================
  !
  ! GENERAL_ROUTINES
  !
  !==================================================================================================================================

  !>Returns the user number of an object.
  INTERFACE OC_UserNumberGet
    MODULE PROCEDURE OC_Region_UserNumberGet
    MODULE PROCEDURE OC_Mesh_UserNumberGet
    MODULE PROCEDURE OC_Basis_UserNumberGet
  END INTERFACE OC_UserNumberGet

  PUBLIC OC_UserNumberGet


  !==================================================================================================================================


CONTAINS

  !
  !================================================================================================================================
  !

  !>Finalises OpenCMISS.
  SUBROUTINE OC_Finalise(err)
    !DLLEXPORT(OC_Finalise)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL OC_Finalise_(err,error,*999)

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises OpenCMISS.
  SUBROUTINE OC_Initialise(err)
    !DLLEXPORT(OC_Initialise)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL OC_Initialise_(OC_MAJOR_VERSION,OC_MINOR_VERSION,OC_PATCH_VERSION,err,error,*999)

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Initialise

  !
  !================================================================================================================================
  !

  !>Return the rank 2 tensor component numbers in OpenCMISS for a given component.
  SUBROUTINE OC_ComponentToTensorTwoComponentsGet(numberOfDimensions,component,tensorComponent1,tensorComponent2,err)
    !DLLEXPORT(OC_ComponentToTensorTwoComponentsGet)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions to get the tensor components for
    INTEGER(INTG), INTENT(IN) :: component !<The component to get the tensor components for
    INTEGER(INTG), INTENT(OUT) :: tensorComponent1 !<On return, the first tensor component corresponding to the component
    INTEGER(INTG), INTENT(OUT) :: tensorComponent2 !<On return, the second tensor component corresponding to the component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: error

    tensorComponent1 = 0_Intg
    tensorComponent2 = 0_Intg
    IF(numberOfDimensions>=1.AND.numberOfDimensions<=3) THEN
      IF(component>=1.AND.component<=NUMBER_OF_TENSOR_TWO(numberOfDimensions)) THEN
        tensorComponent1 = COMPONENT_TO_TENSOR_TWO(1,component,numberOfDimensions)
        tensorComponent2 = COMPONENT_TO_TENSOR_TWO(2,component,numberOfDimensions)
      ELSE
        error="The specified component of "//TRIM(NumberToVString(component,"*",err,error))// &
          & " is invalid. The component must be >= 1 and <= "// &
          & TRIM(NumberToVString(NUMBER_OF_TENSOR_TWO(numberOfDimensions),"*",err,error))// &
          & " for a rank 2 tensor in "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" dimensions."
        GOTO 999
      ENDIF
    ELSE
      error="The specified number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
        & " is invalid. The number of dimensions must be >= 1 and <= 3."
      GOTO 999
    ENDIF

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComponentToTensorTwoComponentsGet
  
  !
  !================================================================================================================================
  !

  !>Return the number of rank 2 tensor components in OpenCMISS for the given number of dimensions.
  SUBROUTINE OC_NumberOfTensorTwoComponentsGet(numberOfDimensions,numberOfTensor,err)
    !DLLEXPORT(OC_NumberOfTensorTwoComponentsGet)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions to get the number of tensor components for
    INTEGER(INTG), INTENT(OUT) :: numberOfTensor !<On return, the number of Tensor components for the number of dimensions
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: error

    numberOfTensor = 0_Intg
    IF(numberOfDimensions>=1.AND.numberOfDimensions<=3) THEN
      numberOfTensor = NUMBER_OF_TENSOR_TWO(numberOfDimensions)
    ELSE
      error="The specified number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
        & " is invalid. The number of dimensions must be >= 1 and <= 3."
      GOTO 999
    ENDIF

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_NumberOfTensorTwoComponentsGet

  !
  !================================================================================================================================
  !

  !>Return the number of Voigt components in OpenCMISS for the given number of dimensions.
  SUBROUTINE OC_NumberOfVoigtComponentsGet(numberOfDimensions,numberOfVoigt,err)
    !DLLEXPORT(OC_NumberOfVoigtComponentsGet)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions to get the number of Voigt components for
    INTEGER(INTG), INTENT(OUT) :: numberOfVoigt !<On return, the number of Voigt components for the number of dimensions
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: error

    numberOfVoigt = 0_Intg
    IF(numberOfDimensions>=1.AND.numberOfDimensions<=3) THEN
      numberOfVoigt = NUMBER_OF_VOIGT(numberOfDimensions)
    ELSE
      error="The specified number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
        & " is invalid. The number of dimensions must be >= 1 and <= 3."
      GOTO 999
    ENDIF

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_NumberOfVoigtComponentsGet

  !
  !================================================================================================================================
  !

  !>Sets a PETSc option (so that they can be set from python when we don't have the command line.)
  SUBROUTINE OC_PetscOptionsSetValue(name,VALUE,err)
    !DLLEXPORT(OC_PetscOptionsSetValue)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: name !<The name of the PETSc option
    CHARACTER(LEN=*), INTENT(IN) :: value !<The value of the PETSc option
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_PetscOptionsSetValue",err,error,*999)

    CALL Petsc_OptionsSetValue(name,VALUE,err,error,*999)

    EXITS("OC_PetscOptionsSetValue")
    RETURN
999 ERRORSEXITS("OC_PetscOptionsSetValue",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_PetscOptionsSetValue

  !
  !================================================================================================================================
  !

  !>Return the component number in OpenCMISS for the given second order tensor components.
  SUBROUTINE OC_TensorTwoComponentsToComponentGet(numberOfDimensions,tensorComponent1,tensorComponent2,component,err)
    !DLLEXPORT(OC_TensorTwoComponentsToComponentGet)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions to get the tensor component for
    INTEGER(INTG), INTENT(IN) :: tensorComponent1 !<The first tensor component to get the tensor component for
    INTEGER(INTG), INTENT(IN) :: tensorComponent2 !<The second tensor component to get the tensor component for
    INTEGER(INTG), INTENT(OUT) :: component !<On return, the component for the tensor components
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: error

    component = 0_Intg
    IF(numberOfDimensions>=1.AND.numberOfDimensions<=3) THEN
      IF(tensorComponent1>=1.AND.tensorComponent2<=numberOfDimensions) THEN
        IF(tensorCOmponent2>=1.AND.tensorComponent2<=numberOfDimensions) THEN
           component= TENSOR_TWO_TO_COMPONENT(tensorComponent1,tensorComponent2,numberOfDimensions)
        ELSE
          error="The specified second tensor component of "//TRIM(NumberToVString(tensorComponent2,"*",err,error))// &
            & " is invalid. The tensor component must be >= 1 and <= "// &
            & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
          GOTO 999
        ENDIF
      ELSE
        error="The specified first tensor component of "//TRIM(NumberToVString(tensorComponent1,"*",err,error))// &
          & " is invalid. The tensor component must be >= 1 and <= "// &
          & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
        GOTO 999
      ENDIF
    ELSE
      error="The specified number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
        & " is invalid. The number of dimensions must be >= 1 and <= 3."
      GOTO 999
    ENDIF

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_TensorTwoComponentsToComponentGet
  
  !
  !================================================================================================================================
  !

  !>Return the Voigt component number in OpenCMISS for the given symmetric second order tensor components.
  SUBROUTINE OC_TensorComponentsToVoigtComponentGet(numberOfDimensions,tensorComponent1,tensorComponent2,voigtComponent,err)
    !DLLEXPORT(OC_TensorComponentsToVoigtComponentGet)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions to get the Voigt component for
    INTEGER(INTG), INTENT(IN) :: tensorComponent1 !<The first tensor component to get the Voigt component for
    INTEGER(INTG), INTENT(IN) :: tensorComponent2 !<The second tensor component to get the Voigt component for
    INTEGER(INTG), INTENT(OUT) :: voigtComponent !<On return, the Voigt component for the tensor components
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: error

    voigtComponent = 0_Intg
    IF(numberOfDimensions>=1.AND.numberOfDimensions<=3) THEN
      IF(tensorComponent1>=1.AND.tensorComponent2<=numberOfDimensions) THEN
        IF(tensorCOmponent2>=1.AND.tensorComponent2<=numberOfDimensions) THEN
           voigtComponent= TENSOR_TO_VOIGT(tensorComponent1,tensorComponent2,numberOfDimensions)
        ELSE
          error="The specified second tensor component of "//TRIM(NumberToVString(tensorComponent2,"*",err,error))// &
            & " is invalid. The tensor component must be >= 1 and <= "// &
            & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
          GOTO 999
        ENDIF
      ELSE
        error="The specified first tensor component of "//TRIM(NumberToVString(tensorComponent1,"*",err,error))// &
          & " is invalid. The tensor component must be >= 1 and <= "// &
          & TRIM(NumberToVString(numberOfDimensions,"*",err,error))//"."
        GOTO 999
      ENDIF
    ELSE
      error="The specified number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
        & " is invalid. The number of dimensions must be >= 1 and <= 3."
      GOTO 999
    ENDIF

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_TensorComponentsToVoigtComponentGet
  
  !
  !================================================================================================================================
  !

  !>Return the tensor component numbers in OpenCMISS for a given Voigt tensor component.
  SUBROUTINE OC_VoigtComponentToTensorComponentsGet(numberOfDimensions,voigtComponent,tensorComponent1,tensorComponent2,err)
    !DLLEXPORT(OC_VoigtComponentToTensorComponentsGet)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions to get the tensor components for
    INTEGER(INTG), INTENT(IN) :: voigtComponent !<The Voigt component to get the tensor components for
    INTEGER(INTG), INTENT(OUT) :: tensorComponent1 !<On return, the first tensor component corresponding to the Voigt component
    INTEGER(INTG), INTENT(OUT) :: tensorComponent2 !<On return, the second tensor component corresponding to the Voigt component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: error

    tensorComponent1 = 0_Intg
    tensorComponent2 = 0_Intg
    IF(numberOfDimensions>=1.AND.numberOfDimensions<=3) THEN
      IF(voigtComponent>=1.AND.voigtComponent<=NUMBER_OF_VOIGT(numberOfDimensions)) THEN
        tensorComponent1 = VOIGT_TO_TENSOR(1,voigtComponent,numberOfDimensions)
        tensorComponent2 = VOIGT_TO_TENSOR(2,voigtComponent,numberOfDimensions)
      ELSE
        error="The specified Voigt component of "//TRIM(NumberToVString(voigtComponent,"*",err,error))// &
          & " is invalid. The Voigt component must be >= 1 and <= "// &
          & TRIM(NumberToVString(NUMBER_OF_VOIGT(numberOfDimensions),"*",err,error))// &
          & " for "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))//" dimensions."
        GOTO 999
      ENDIF
    ELSE
      error="The specified number of dimensions of "//TRIM(NumberToVString(numberOfDimensions,"*",err,error))// &
        & " is invalid. The number of dimensions must be >= 1 and <= 3."
      GOTO 999
    ENDIF

    RETURN
999 CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_VoigtComponentToTensorComponentsGet
  
  !
  !================================================================================================================================
  !

  !>Returns the working precision
  SUBROUTINE OC_WorkingRealPrecisionGet(workingRealPrecision,err)
    !DLLEXPORT(OC_WorkingRealPrecisionGet)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: workingRealPrecision !<On return, the working real precision
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_WorkingRealPrecisionGet",err,error,*999)

#ifdef SINGLE_REAL_PRECISION
    workingRealPrecision=OC_SINGLE_REAL_TYPE
#else
    workingRealPrecision=OC_DOUBLE_REAL_TYPE
#endif

    EXITS("OC_WorkingRealPrecisionGet")
    RETURN
999 ERRORSEXITS("OC_WorkingRealPrecisionGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkingRealPrecisionGet

  !
  !================================================================================================================================
  !

  !> \addtogroup OpenCMISS_Basis OpenCMISS::Basis
  !>@{
  !>Copy an array of OC_BasisTypes from C to an allocated Fortran array, for use by the C bindings
  SUBROUTINE OC_BasisTypesCopy(bases,basesSize,basesPtr,err)
    !DLLEXPORT(OC_BasisTypesCopy)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: bases(:) !<On return, the array of OC_BasisTypes
    INTEGER(C_INT), INTENT(IN) :: basesSize !<The length of the C array of pointers to OC_BasisTypes
    TYPE(C_PTR), INTENT(IN) :: basesPtr !<Th pointer to the first OC_BasisType pointer
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basisIdx
    TYPE(C_PTR), POINTER :: basesCPtrs(:)
    TYPE(OC_BasisType), POINTER :: basis

    ENTERS("OC_BasisTypesCopy",err,error,*999)

    IF(C_ASSOCIATED(basesPtr)) THEN
      CALL C_F_POINTER(basesPtr,basesCPtrs,[basesSize])
      IF(ASSOCIATED(basesCPtrs)) THEN
        DO basisIdx=1,basesSize
          CALL C_F_POINTER(basesCPtrs(basisIdx),Basis)
          IF(ASSOCIATED(basesCPtrs)) THEN
            bases(basisIdx)%basis => basis%basis
          ELSE
            CALL FlagError("Error converting C pointer.",err,error,*999)
          ENDIF
        ENDDO !basisIdx
      ELSE
        CALL FlagError("Error converting C pointer.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Bases C pointer is not associated.",err,error,*999)
    ENDIF

    EXITS("OC_BasisTypesCopy")
    RETURN
999 ERRORSEXITS("OC_BasisTypesCopy",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BasisTypesCopy

  !
  !================================================================================================================================
  !

  !>Finalises a OC_BasisType object.
  SUBROUTINE OC_Basis_Finalise(OC_Basis,err)
    !DLLEXPORT(OC_Basis_Finalise)

    !Argument variables
    TYPE(OC_BasisType), INTENT(OUT) :: OC_Basis !<The OC_BasisType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Basis%basis)) CALL Basis_Destroy(OC_Basis%basis,err,error,*999)

    EXITS("OC_Basis_Finalise")
    RETURN
999 ERRORSEXITS("OC_Basis_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_BasisType object.
  SUBROUTINE OC_Basis_Initialise(OC_Basis,err)
    !DLLEXPORT(OC_Basis_Initialise)

    !Argument variables
    TYPE(OC_BasisType), INTENT(OUT) :: OC_Basis !<The OC_BasisType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_Initialise",err,error,*999)

    NULLIFY(OC_Basis%basis)

    EXITS("OC_Basis_Initialise")
    RETURN
999 ERRORSEXITS("OC_Basis_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_Initialise

  !>@}
  
  !
  !================================================================================================================================
  !

  !>Finalises a OC_BoundaryConditionsType object.
  SUBROUTINE OC_BoundaryConditions_Finalise(OC_BoundaryConditions,err)
    !DLLEXPORT(OC_BoundaryConditions_Finalise)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(OUT) :: OC_BoundaryConditions !<The OC_BoundaryConditionsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_BoundaryConditions%boundaryConditions))  &
      & CALL BoundaryConditions_Destroy(OC_BoundaryConditions%boundaryConditions,err,error,*999)

    EXITS("OC_BoundaryConditions_Finalise")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a OC_BoundaryConditionsType object.
  SUBROUTINE OC_BoundaryConditions_Initialise(OC_BoundaryConditions,err)
    !DLLEXPORT(OC_BoundaryConditions_Initialise)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(OUT) :: OC_BoundaryConditions !<The OC_BoundaryConditionsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_Initialise",err,error,*999)

    NULLIFY(OC_BoundaryConditions%boundaryConditions)

    EXITS("OC_BoundaryConditions_Initialise")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_CellMLType object.
  SUBROUTINE OC_CellML_Finalise(OC_CellML,err)
    !DLLEXPORT(OC_CellML_Finalise)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(OUT) :: OC_CellML !<The OC_CellMLType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_CellML%cellml)) CALL Cellml_Destroy(OC_CellML%cellml,err,error,*999)

    EXITS("OC_CellML_Finalise")
    RETURN
999 ERRORSEXITS("OC_CellML_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a OC_CellMLType object.
  SUBROUTINE OC_CellML_Initialise(OC_CellML,err)
    !DLLEXPORT(OC_CellML_Initialise)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(OUT) :: OC_CellML !<The OC_CellMLType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_Initialise",err,error,*999)

    NULLIFY(OC_CellML%cellml)

    EXITS("OC_CellML_Initialise")
    RETURN
999 ERRORSEXITS("OC_CellML_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_CellMLEquationsType object.
  SUBROUTINE OC_CellMLEquations_Finalise(OC_CellMLEquations,err)
    !DLLEXPORT(OC_CellMLEquations_Finalise)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(OUT) :: OC_CellMLEquations !<The OC_CellMLEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_CellMLEquations%cellmlEquations))  &
      & CALL CellMLEquations_Destroy(OC_CellMLEquations%cellmlEquations,err,error,*999)

    EXITS("OC_CellMLEquations_Finalise")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_CellMLEquationsType object.
  SUBROUTINE OC_CellMLEquations_Initialise(OC_CellMLEquations,err)
    !DLLEXPORT(OC_CellMLEquations_Initialise)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(OUT) :: OC_CellMLEquations !<The OC_CellMLEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_Initialise",err,error,*999)

    NULLIFY(OC_CellMLEquations%cellmlEquations)

    EXITS("OC_CellMLEquations_Initialise")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_ComputationEnvironmentType object.
  SUBROUTINE OC_ComputationEnvironment_Finalise(OC_ComputationEnvironment,err)
    !DLLEXPORT(OC_ComputationEnvironment_Finalise)

    !Argument variables
    TYPE(OC_ComputationEnvironmentType), INTENT(OUT) :: OC_ComputationEnvironment !<The OC_ComputationEnvironmentType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ComputationEnvironment_Finalise",err,error,*999)

    NULLIFY(OC_ComputationEnvironment%computationEnvironment)

    EXITS("OC_ComputationEnvironment_Finalise")
    RETURN
999 ERRORSEXITS("OC_ComputationEnvironment_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_ComputationEnvironmentType object.
  SUBROUTINE OC_ComputationEnvironment_Initialise(OC_ComputationEnvironment,err)
    !DLLEXPORT(OC_ComputationEnvironment_Initialise)

    !Argument variables
    TYPE(OC_ComputationEnvironmentType), INTENT(OUT) :: OC_ComputationEnvironment !<The OC_ComputationEnvironmentType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ComputationEnvironment_Initialise",err,error,*999)

    NULLIFY(OC_ComputationEnvironment%computationEnvironment)

    EXITS("OC_ComputationEnvironment_Initialise")
    RETURN
999 ERRORSEXITS("OC_ComputationEnvironment_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_ContextType object.
  SUBROUTINE OC_Context_Finalise(OC_Context,err)
    !DLLEXPORT(OC_Context_Finalise)

    !Argument variables
    TYPE(OC_ContextType), INTENT(OUT) :: OC_Context !<The OC_ContextType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Context%context))  &
      & CALL Context_Destroy(OC_Context%context,err,error,*999)

    EXITS("OC_Context_Finalise")
    RETURN
999 ERRORSEXITS("OC_Context_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_Finalise

  !  
  !================================================================================================================================
  !

  !>Initialises a OC_ContextType object.
  SUBROUTINE OC_Context_Initialise(OC_Context,err)
    !DLLEXPORT(OC_Context_Initialise)

    !Argument variables
    TYPE(OC_ContextType), INTENT(OUT) :: OC_Context !<The OC_ContextType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_Initialise",err,error,*999)

    NULLIFY(OC_Context%context)

    EXITS("OC_Context_Initialise")
    RETURN
999 ERRORSEXITS("OC_Context_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_ControlLoopType object.
  SUBROUTINE OC_ControlLoop_Finalise(OC_ControlLoop,err)
    !DLLEXPORT(OC_ControlLoop_Finalise)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(OUT) :: OC_ControlLoop !<The OC_ControlLoopType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_ControlLoop%controlLoop))  &
      & CALL ControlLoop_Destroy(OC_ControlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_Finalise")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_Finalise

  !  
  !================================================================================================================================
  !

  !>Initialises a OC_ControlLoopType object.
  SUBROUTINE OC_ControlLoop_Initialise(OC_ControlLoop,err)
    !DLLEXPORT(OC_ControlLoop_Initialise)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(OUT) :: OC_ControlLoop !<The OC_ControlLoopType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_Initialise",err,error,*999)

    NULLIFY(OC_ControlLoop%controlLoop)

    EXITS("OC_ControlLoop_Initialise")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_CoordinateSystemType object.
  SUBROUTINE OC_CoordinateSystem_Finalise(OC_CoordinateSystem,err)
    !DLLEXPORT(OC_CoordinateSystem_Finalise)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(OUT) :: OC_CoordinateSystem !<The OC_CoordinateSystemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_CoordinateSystem%coordinateSystem))  &
      & CALL CoordinateSystem_Destroy(OC_CoordinateSystem%coordinateSystem,err,error,*999)

    EXITS("OC_CoordinateSystem_Finalise")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a OC_CoordinateSystemType object.
  SUBROUTINE OC_CoordinateSystem_Initialise(OC_CoordinateSystem,err)
    !DLLEXPORT(OC_CoordinateSystem_Initialise)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(OUT) :: OC_CoordinateSystem !<The OC_CoordinateSystemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_Initialise",err,error,*999)

    NULLIFY(OC_CoordinateSystem%coordinateSystem)

    EXITS("OC_CoordinateSystem_Initialise")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DataPointsType object.
  SUBROUTINE OC_DataPoints_Finalise(OC_DataPoints,err)
    !DLLEXPORT(OC_DataPoints_Finalise)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(OUT) :: OC_DataPoints !<The OC_DataPointsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_DataPoints%dataPoints))  &
      & CALL DataPoints_Destroy(OC_DataPoints%dataPoints,err,error,*999)

    EXITS("OC_DataPoints_Finalise")
    RETURN
999 ERRORSEXITS("OC_DataPoints_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DataPointsType object.
  SUBROUTINE OC_DataPoints_Initialise(OC_DataPoints,err)
    !DLLEXPORT(OC_DataPoints_Initialise)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(OUT) :: OC_DataPoints !<The OC_DataPointsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_Initialise",err,error,*999)

    NULLIFY(OC_DataPoints%dataPoints)

    EXITS("OC_DataPoints_Initialise")
    RETURN
999 ERRORSEXITS("OC_DataPoints_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DataProjectionType object.
  SUBROUTINE OC_DataProjection_Finalise(OC_DataProjection,err)
    !DLLEXPORT(OC_DataProjection_Finalise)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(OUT) :: OC_DataProjection !<The OC_DataProjectionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_DataProjection%dataProjection))  &
      & CALL DataProjection_Destroy(OC_DataProjection%dataProjection,err,error,*999)

    EXITS("OC_DataProjection_Finalise")
    RETURN
999 ERRORSEXITS("OC_DataProjection_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DataProjectionType object.
  SUBROUTINE OC_DataProjection_Initialise(OC_DataProjection,err)
    !DLLEXPORT(OC_DataProjection_Initialise)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(OUT) :: OC_DataProjection !<The OC_DataProjectionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_Initialise",err,error,*999)

    NULLIFY(OC_DataProjection%dataProjection)

    EXITS("OC_DataProjection_Initialise")
    RETURN
999 ERRORSEXITS("OC_DataProjection_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecomposerType object.
  SUBROUTINE OC_Decomposer_Finalise(OC_Decomposer,err)
    !DLLEXPORT(OC_Decomposer_Finalise)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(OUT) :: OC_Decomposer !<The OC_DecomposerType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Decomposer%decomposer)) CALL Decomposer_Destroy(OC_Decomposer%decomposer,err,error,*999)

    EXITS("OC_Decomposer_Finalise")
    RETURN
999 ERRORSEXITS("OC_Decomposer_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecomposerType object.
  SUBROUTINE OC_Decomposer_Initialise(OC_Decomposer,err)
    !DLLEXPORT(OC_Decomposer_Initialise)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(OUT) :: OC_Decomposer !<The OC_DecomposerType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_Initialise",err,error,*999)

    NULLIFY(OC_Decomposer%decomposer)

    EXITS("OC_Decomposer_Initialise")
    RETURN
999 ERRORSEXITS("OC_Decomposer_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionType object.
  SUBROUTINE OC_Decomposition_Finalise(OC_Decomposition,err)
    !DLLEXPORT(OC_Decomposition_Finalise)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(OUT) :: OC_Decomposition !<The OC_DecompositionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Decomposition%decomposition)) CALL Decomposition_Destroy(OC_Decomposition%decomposition,err,error,*999)

    EXITS("OC_Decomposition_Finalise")
    RETURN
999 ERRORSEXITS("OC_Decomposition_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionType object.
  SUBROUTINE OC_Decomposition_Initialise(OC_Decomposition,err)
    !DLLEXPORT(OC_Decomposition_Initialise)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(OUT) :: OC_Decomposition !<The OC_DecompositionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_Initialise",err,error,*999)

    NULLIFY(OC_Decomposition%decomposition)

    EXITS("OC_Decomposition_Initialise")
    RETURN
999 ERRORSEXITS("OC_Decomposition_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionElementType object.
  SUBROUTINE OC_DecompositionElement_Finalise(OC_DecompositionElement,err)
    !DLLEXPORT(OC_DecompositionElement_Finalise)

    !Argument variables
    TYPE(OC_DecompositionElementType), INTENT(OUT) :: OC_DecompositionElement !<The OC_DecompositionElementType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionElement_Finalise",err,error,*999)

    !Don't destroy the decomposition element, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionElement%decompositionElement)) NULLIFY(OC_DecompositionElement%decompositionElement)

    EXITS("OC_DecompositionElement_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionElement_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionElement_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionElementType object.
  SUBROUTINE OC_DecompositionElement_Initialise(OC_DecompositionElement,err)
    !DLLEXPORT(OC_DecompositionElement_Initialise)

    !Argument variables
    TYPE(OC_DecompositionElementType), INTENT(OUT) :: OC_DecompositionElement !<The OC_DecompositionElementType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionElement_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionElement%decompositionElement)

    EXITS("OC_DecompositionElement_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionElement_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionElement_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionElementsType object.
  SUBROUTINE OC_DecompositionElements_Finalise(OC_DecompositionElements,err)
    !DLLEXPORT(OC_DecompositionElements_Finalise)

    !Argument variables
    TYPE(OC_DecompositionElementsType), INTENT(OUT) :: OC_DecompositionElements !<The OC_DecompositionElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionElements_Finalise",err,error,*999)

    !Don't destroy the decomposition elements, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionElements%decompositionElements)) NULLIFY(OC_DecompositionElements%decompositionElements)

    EXITS("OC_DecompositionElements_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionElements_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionElements_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionElementsType object.
  SUBROUTINE OC_DecompositionElements_Initialise(OC_DecompositionElements,err)
    !DLLEXPORT(OC_DecompositionElements_Initialise)

    !Argument variables
    TYPE(OC_DecompositionElementsType), INTENT(OUT) :: OC_DecompositionElements !<The OC_DecompositionElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionElements_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionElements%decompositionElements)

    EXITS("OC_DecompositionElements_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionElements_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionElements_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionFaceType object.
  SUBROUTINE OC_DecompositionFace_Finalise(OC_DecompositionFace,err)
    !DLLEXPORT(OC_DecompositionFace_Finalise)

    !Argument variables
    TYPE(OC_DecompositionFaceType), INTENT(OUT) :: OC_DecompositionFace !<The OC_DecompositionFaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionFace_Finalise",err,error,*999)

    !Don't destroy the decomposition face, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionFace%decompositionFace)) NULLIFY(OC_DecompositionFace%decompositionFace)

    EXITS("OC_DecompositionFace_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionFace_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionFace_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionFaceType object.
  SUBROUTINE OC_DecompositionFace_Initialise(OC_DecompositionFace,err)
    !DLLEXPORT(OC_DecompositionFace_Initialise)

    !Argument variables
    TYPE(OC_DecompositionFaceType), INTENT(OUT) :: OC_DecompositionFace !<The OC_DecompositionFaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionFace_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionFace%decompositionFace)

    EXITS("OC_DecompositionFace_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionFace_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionFace_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionFacesType object.
  SUBROUTINE OC_DecompositionFaces_Finalise(OC_DecompositionFaces,err)
    !DLLEXPORT(OC_DecompositionFaces_Finalise)

    !Argument variables
    TYPE(OC_DecompositionFacesType), INTENT(OUT) :: OC_DecompositionFaces !<The OC_DecompositionFacesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionFaces_Finalise",err,error,*999)

    !Don't destroy the decomposition faces, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionFaces%decompositionFaces)) NULLIFY(OC_DecompositionFaces%decompositionFaces)

    EXITS("OC_DecompositionFaces_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionFaces_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionFaces_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionFacesType object.
  SUBROUTINE OC_DecompositionFaces_Initialise(OC_DecompositionFaces,err)
    !DLLEXPORT(OC_DecompositionFaces_Initialise)

    !Argument variables
    TYPE(OC_DecompositionFacesType), INTENT(OUT) :: OC_DecompositionFaces !<The OC_DecompositionFacesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionFaces_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionFaces%decompositionFaces)

    EXITS("OC_DecompositionFaces_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionFaces_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionFaces_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionLineType object.
  SUBROUTINE OC_DecompositionLine_Finalise(OC_DecompositionLine,err)
    !DLLEXPORT(OC_DecompositionLine_Finalise)

    !Argument variables
    TYPE(OC_DecompositionLineType), INTENT(OUT) :: OC_DecompositionLine !<The OC_DecompositionLineType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionLine_Finalise",err,error,*999)

    !Don't destroy the decomposition line, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionLine%decompositionLine)) NULLIFY(OC_DecompositionLine%decompositionLine)

    EXITS("OC_DecompositionLine_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionLine_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionLine_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionLineType object.
  SUBROUTINE OC_DecompositionLine_Initialise(OC_DecompositionLine,err)
    !DLLEXPORT(OC_DecompositionLine_Initialise)

    !Argument variables
    TYPE(OC_DecompositionLineType), INTENT(OUT) :: OC_DecompositionLine !<The OC_DecompositionLineType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionLine_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionLine%decompositionLine)

    EXITS("OC_DecompositionLine_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionLine_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionLine_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionLinesType object.
  SUBROUTINE OC_DecompositionLines_Finalise(OC_DecompositionLines,err)
    !DLLEXPORT(OC_DecompositionLines_Finalise)

    !Argument variables
    TYPE(OC_DecompositionLinesType), INTENT(OUT) :: OC_DecompositionLines !<The OC_DecompositionLinesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionLines_Finalise",err,error,*999)

    !Don't destroy the decomposition lines, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionLines%decompositionLines)) NULLIFY(OC_DecompositionLines%decompositionLines)

    EXITS("OC_DecompositionLines_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionLines_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionLines_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionLinesType object.
  SUBROUTINE OC_DecompositionLines_Initialise(OC_DecompositionLines,err)
    !DLLEXPORT(OC_DecompositionLines_Initialise)

    !Argument variables
    TYPE(OC_DecompositionLinesType), INTENT(OUT) :: OC_DecompositionLines !<The OC_DecompositionLinesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionLines_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionLines%decompositionLines)

    EXITS("OC_DecompositionLines_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionLines_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionLines_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DecompositionTopologyType object.
  SUBROUTINE OC_DecompositionTopology_Finalise(OC_DecompositionTopology,err)
    !DLLEXPORT(OC_DecompositionTopology_Finalise)

    !Argument variables
    TYPE(OC_DecompositionTopologyType), INTENT(OUT) :: OC_DecompositionTopology !<The OC_DecompositionTopologyType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionTopology_Finalise",err,error,*999)

    !Don't destroy the topology, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DecompositionTopology%decompositionTopology)) NULLIFY(OC_DecompositionTopology%decompositionTopology)

    EXITS("OC_DecompositionTopology_Finalise")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DecompositionTopologyType object.
  SUBROUTINE OC_DecompositionTopology_Initialise(OC_DecompositionTopology,err)
    !DLLEXPORT(OC_DecompositionTopology_Initialise)

    !Argument variables
    TYPE(OC_DecompositionTopologyType), INTENT(OUT) :: OC_DecompositionTopology !<The OC_DecompositionTopologyType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionTopology_Initialise",err,error,*999)

    NULLIFY(OC_DecompositionTopology%decompositionTopology)

    EXITS("OC_DecompositionTopology_Initialise")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DistributedMatrixType object.
  SUBROUTINE OC_DistributedMatrix_Initialise(OC_DistributedMatrix,err)
    !DLLEXPORT(OC_DistributedMatrix_Initialise)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(OUT) :: OC_DistributedMatrix !<The OC_DistributedMatrixType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DistributedMatrix_Initialise",err,error,*999)

    NULLIFY(OC_DistributedMatrix%distributedMatrix)

    EXITS("OC_DistributedMatrix_Initialise")
    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DistributedVectorType object.
  SUBROUTINE OC_DistributedVector_Initialise(OC_DistributedVector,err)
    !DLLEXPORT(OC_DistributedVector_Initialise)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(OUT) :: OC_DistributedVector !<The OC_DistributedVectorType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DistributedVector_Initialise",err,error,*999)

    NULLIFY(OC_DistributedVector%distributedVector)

    EXITS("OC_DistributedVector_Initialise")
    RETURN
999 ERRORSEXITS("OC_DistributedVector_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainType object.
  SUBROUTINE OC_Domain_Finalise(OC_Domain,err)
    !DLLEXPORT(OC_Domain_Finalise)

    !Argument variables
    TYPE(OC_DomainType), INTENT(OUT) :: OC_Domain !<The OC_DomainType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Domain_Finalise",err,error,*999)

    !Don't destroy, just nullify. Destroy will happen when the decomposition is destroyed.
    IF(ASSOCIATED(OC_Domain%domain)) NULLIFY(OC_Domain%domain)

    EXITS("OC_Domain_Finalise")
    RETURN
999 ERRORSEXITS("OC_Domain_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Domain_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainType object.
  SUBROUTINE OC_Domain_Initialise(OC_Domain,err)
    !DLLEXPORT(OC_Domain_Initialise)

    !Argument variables
    TYPE(OC_DomainType), INTENT(OUT) :: OC_Domain !<The OC_DomainType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Domain_Initialise",err,error,*999)

    NULLIFY(OC_Domain%domain)

    EXITS("OC_Domain_Initialise")
    RETURN
999 ERRORSEXITS("OC_Domain_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Domain_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainElementType object.
  SUBROUTINE OC_DomainElement_Finalise(OC_DomainElement,err)
    !DLLEXPORT(OC_DomainElement_Finalise)

    !Argument variables
    TYPE(OC_DomainElementType), INTENT(OUT) :: OC_DomainElement !<The OC_DomainElementType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainElement_Finalise",err,error,*999)

    !Don't destroy the domain element, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainElement%domainElement)) NULLIFY(OC_DomainElement%domainElement)

    EXITS("OC_DomainElement_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainElement_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainElement_Finalise

  !
  !================================================================================================================================
  ! 

  !>Initialises a OC_DomainElementType object.
  SUBROUTINE OC_DomainElement_Initialise(OC_DomainElement,err)
    !DLLEXPORT(OC_DomainElement_Initialise)

    !Argument variables
    TYPE(OC_DomainElementType), INTENT(OUT) :: OC_DomainElement !<The OC_DomainElementType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainElement_Initialise",err,error,*999)

    NULLIFY(OC_DomainElement%domainElement)

    EXITS("OC_DomainElement_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainElement_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainElement_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainElementsType object.
  SUBROUTINE OC_DomainElements_Finalise(OC_DomainElements,err)
    !DLLEXPORT(OC_DomainElements_Finalise)

    !Argument variables
    TYPE(OC_DomainElementsType), INTENT(OUT) :: OC_DomainElements !<The OC_DomainElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainElements_Finalise",err,error,*999)

    !Don't destroy the domain elements, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainElements%domainElements)) NULLIFY(OC_DomainElements%domainElements)

    EXITS("OC_DomainElements_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainElements_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainElements_Finalise

  !
  !================================================================================================================================
  ! 

  !>Initialises a OC_DomainElementsType object.
  SUBROUTINE OC_DomainElements_Initialise(OC_DomainElements,err)
    !DLLEXPORT(OC_DomainElements_Initialise)

    !Argument variables
    TYPE(OC_DomainElementsType), INTENT(OUT) :: OC_DomainElements !<The OC_DomainElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainElements_Initialise",err,error,*999)

    NULLIFY(OC_DomainElements%domainElements)

    EXITS("OC_DomainElements_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainElements_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainElements_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainFaceType object.
  SUBROUTINE OC_DomainFace_Finalise(OC_DomainFace,err)
    !DLLEXPORT(OC_DomainFace_Finalise)

    !Argument variables
    TYPE(OC_DomainFaceType), INTENT(OUT) :: OC_DomainFace !<The OC_DomainFaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainFace_Finalise",err,error,*999)

    !Don't destroy the domain face, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainFace%domainFace)) NULLIFY(OC_DomainFace%domainFace)

    EXITS("OC_DomainFace_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainFace_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainFace_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainFaceType object.
  SUBROUTINE OC_DomainFace_Initialise(OC_DomainFace,err)
    !DLLEXPORT(OC_DomainFace_Initialise)

    !Argument variables
    TYPE(OC_DomainFaceType), INTENT(OUT) :: OC_DomainFace !<The OC_DomainFaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainFace_Initialise",err,error,*999)

    NULLIFY(OC_DomainFace%domainFace)

    EXITS("OC_DomainFace_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainFace_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainFace_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainFacesType object.
  SUBROUTINE OC_DomainFaces_Finalise(OC_DomainFaces,err)
    !DLLEXPORT(OC_DomainFaces_Finalise)

    !Argument variables
    TYPE(OC_DomainFacesType), INTENT(OUT) :: OC_DomainFaces !<The OC_DomainFacesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainFaces_Finalise",err,error,*999)

    !Don't destroy the domain faces, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainFaces%domainFaces)) NULLIFY(OC_DomainFaces%domainFaces)

    EXITS("OC_DomainFaces_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainFaces_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainFaces_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainFacesType object.
  SUBROUTINE OC_DomainFaces_Initialise(OC_DomainFaces,err)
    !DLLEXPORT(OC_DomainFaces_Initialise)

    !Argument variables
    TYPE(OC_DomainFacesType), INTENT(OUT) :: OC_DomainFaces !<The OC_DomainFacesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainFaces_Initialise",err,error,*999)

    NULLIFY(OC_DomainFaces%domainFaces)

    EXITS("OC_DomainFaces_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainFaces_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainFaces_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainLineType object.
  SUBROUTINE OC_DomainLine_Finalise(OC_DomainLine,err)
    !DLLEXPORT(OC_DomainLine_Finalise)

    !Argument variables
    TYPE(OC_DomainLineType), INTENT(OUT) :: OC_DomainLine !<The OC_DomainLineType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainLine_Finalise",err,error,*999)

    !Don't destroy the domain line, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainLine%domainLine)) NULLIFY(OC_DomainLine%domainLine)

    EXITS("OC_DomainLine_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainLine_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainLine_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainLineType object.
  SUBROUTINE OC_DomainLine_Initialise(OC_DomainLine,err)
    !DLLEXPORT(OC_DomainLine_Initialise)

    !Argument variables
    TYPE(OC_DomainLineType), INTENT(OUT) :: OC_DomainLine !<The OC_DomainLineType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainLine_Initialise",err,error,*999)

    NULLIFY(OC_DomainLine%domainLine)

    EXITS("OC_DomainLine_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainLine_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainLine_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainLinesType object.
  SUBROUTINE OC_DomainLines_Finalise(OC_DomainLines,err)
    !DLLEXPORT(OC_DomainLines_Finalise)

    !Argument variables
    TYPE(OC_DomainLinesType), INTENT(OUT) :: OC_DomainLines !<The OC_DomainLinesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainLines_Finalise",err,error,*999)

    !Don't destroy the domain lines, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainLines%domainLines)) NULLIFY(OC_DomainLines%domainLines)

    EXITS("OC_DomainLines_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainLines_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainLines_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainLinesType object.
  SUBROUTINE OC_DomainLines_Initialise(OC_DomainLines,err)
    !DLLEXPORT(OC_DomainLines_Initialise)

    !Argument variables
    TYPE(OC_DomainLinesType), INTENT(OUT) :: OC_DomainLines !<The OC_DomainLinesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainLines_Initialise",err,error,*999)

    NULLIFY(OC_DomainLines%domainLines)

    EXITS("OC_DomainLines_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainLines_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainLines_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainNodeType object.
  SUBROUTINE OC_DomainNode_Finalise(OC_DomainNode,err)
    !DLLEXPORT(OC_DomainNode_Finalise)

    !Argument variables
    TYPE(OC_DomainNodeType), INTENT(OUT) :: OC_DomainNode !<The OC_DomainNodeType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainNode_Finalise",err,error,*999)

    !Don't destroy the domain node, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainNode%domainNode)) NULLIFY(OC_DomainNode%domainNode)

    EXITS("OC_DomainNode_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainNode_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainNode_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainNodeType object.
  SUBROUTINE OC_DomainNode_Initialise(OC_DomainNode,err)
    !DLLEXPORT(OC_DomainNode_Initialise)

    !Argument variables
    TYPE(OC_DomainNodeType), INTENT(OUT) :: OC_DomainNode !<The OC_DomainNodeType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainNode_Initialise",err,error,*999)

    NULLIFY(OC_DomainNode%domainNode)

    EXITS("OC_DomainNode_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainNode_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainNode_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainNodesType object.
  SUBROUTINE OC_DomainNodes_Finalise(OC_DomainNodes,err)
    !DLLEXPORT(OC_DomainNodes_Finalise)

    !Argument variables
    TYPE(OC_DomainNodesType), INTENT(OUT) :: OC_DomainNodes !<The OC_DomainNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainNodes_Finalise",err,error,*999)

    !Don't destroy the domain nodes, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainNodes%domainNodes)) NULLIFY(OC_DomainNodes%domainNodes)

    EXITS("OC_DomainNodes_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainNodes_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainNodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainNodesType object.
  SUBROUTINE OC_DomainNodes_Initialise(OC_DomainNodes,err)
    !DLLEXPORT(OC_DomainNodes_Initialise)

    !Argument variables
    TYPE(OC_DomainNodesType), INTENT(OUT) :: OC_DomainNodes !<The OC_DomainNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainNodes_Initialise",err,error,*999)

    NULLIFY(OC_DomainNodes%domainNodes)

    EXITS("OC_DomainNodes_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainNodes_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainNodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_DomainTopologyType object.
  SUBROUTINE OC_DomainTopology_Finalise(OC_DomainTopology,err)
    !DLLEXPORT(OC_DomainTopology_Finalise)

    !Argument variables
    TYPE(OC_DomainTopologyType), INTENT(OUT) :: OC_DomainTopology !<The OC_DomainTopologyType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainTopology_Finalise",err,error,*999)

    !Don't destroy the toplogy, just nullify it. It will be destroyed with the decomposition.
    IF(ASSOCIATED(OC_DomainTopology%domainTopology)) NULLIFY(OC_DomainTopology%domainTopology)

    EXITS("OC_DomainToplogy_Finalise")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_DomainTopologyType object.
  SUBROUTINE OC_DomainTopology_Initialise(OC_DomainTopology,err)
    !DLLEXPORT(OC_DomainTopology_Initialise)

    !Argument variables
    TYPE(OC_DomainTopologyType), INTENT(OUT) :: OC_DomainTopology !<The OC_DomainTopologyType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainTopology_Initialise",err,error,*999)

    NULLIFY(OC_DomainTopology%domainTopology)

    EXITS("OC_DomainTopology_Initialise")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_EquationsType object.
  SUBROUTINE OC_Equations_Finalise(OC_Equations,err)
    !DLLEXPORT(OC_Equations_Finalise)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(OUT) :: OC_Equations !<The OC_EquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Equations%equations))  &
      & CALL Equations_Destroy(OC_Equations%equations,err,error,*999)

    EXITS("OC_Equations_Finalise")
    RETURN
999 ERRORSEXITS("OC_Equations_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_EquationsType object.
  SUBROUTINE OC_Equations_Initialise(OC_Equations,err)
    !DLLEXPORT(OC_Equations_Initialise)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(OUT) :: OC_Equations !<The OC_EquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_Initialise",err,error,*999)

    NULLIFY(OC_Equations%equations)

    EXITS("OC_Equations_Initialise")
    RETURN
999 ERRORSEXITS("OC_Equations_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_EquationsSetType object.
  SUBROUTINE OC_EquationsSet_Finalise(OC_EquationsSet,err)
    !DLLEXPORT(OC_EquationsSet_Finalise)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(OUT) :: OC_EquationsSet !<The OC_EquationsSetType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_EquationsSet%equationsSet))  &
      & CALL EquationsSet_Destroy(OC_EquationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_Finalise")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_EquationsSetType object.
  SUBROUTINE OC_EquationsSet_Initialise(OC_EquationsSet,err)
    !DLLEXPORT(OC_EquationsSet_Initialise)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(OUT) :: OC_EquationsSet !<The OC_EquationsSetType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_Initialise",err,error,*999)

    NULLIFY(OC_EquationsSet%equationsSet)

    EXITS("OC_EquationsSet_Initialise")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_ExportType object.
  SUBROUTINE OC_Export_Finalise(OC_Export,err)
    !DLLEXPORT(OC_Export_Finalise)

    !Argument variables
    TYPE(OC_ExportType), INTENT(OUT) :: OC_Export !<The OC_ExportType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Export%export)) CALL Export_Destroy(OC_Export%export,err,error,*999)

    EXITS("OC_Export_Finalise")
    RETURN
999 ERRORSEXITS("OC_Export_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_ExportType object.
  SUBROUTINE OC_Export_Initialise(OC_Export,err)
    !DLLEXPORT(OC_Export_Initialise)

    !Argument variables
    TYPE(OC_ExportType), INTENT(OUT) :: OC_Export !<The OC_ExportType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_Initialise",err,error,*999)

    NULLIFY(OC_Export%export)

    EXITS("OC_Export_Initialise")
    RETURN
999 ERRORSEXITS("OC_Export_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_FieldType object.
  SUBROUTINE OC_Field_Finalise(OC_Field,err)
    !DLLEXPORT(OC_Field_Finalise)

    !Argument variables
    TYPE(OC_FieldType), INTENT(OUT) :: OC_Field !<The OC_FieldType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables


    ENTERS("OC_Field_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Field%field)) CALL Field_Destroy(OC_Field%field,err,error,*999)

    EXITS("OC_Field_Finalise")
    RETURN
999 ERRORSEXITS("OC_Field_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_FieldType object.
  SUBROUTINE OC_Field_Initialise(OC_Field,err)
    !DLLEXPORT(OC_Field_Initialise)

    !Argument variables
    TYPE(OC_FieldType), INTENT(OUT) :: OC_Field !<The OC_FieldType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_Initialise",err,error,*999)

    NULLIFY(OC_Field%field)

    EXITS("OC_Field_Initialise")
    RETURN
999 ERRORSEXITS("OC_Field_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_Initialise

  !
  !================================================================================================================================
  !

  !>Creates a OC_FieldsType object for an inteface by an object reference.
  SUBROUTINE OC_Fields_AddFieldObj(fields,field,err)
    !DLLEXPORT(OC_Fields_AddFieldObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields attached to the specified interface.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add to the fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_AddFieldObj",err,error,*999)

    CALL Fields_AddField(fields%fields,field%field,err,error,*999)

    EXITS("OC_Fields_AddFieldObj")
    RETURN
999 ERRORSEXITS("OC_Fields_AddFieldObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_AddFieldObj

  !
  !================================================================================================================================
  !

  !>Creates a OC_FieldsType object for an inteface by an object reference.
  SUBROUTINE OC_Fields_CreateInterface(interface,fields,err)
    !DLLEXPORT(OC_Fields_CreateInterface)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to get the fields from
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified interface. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_CreateInterface",err,error,*999)

    IF(ASSOCIATED(interface%interface)) THEN
      IF(ASSOCIATED(fields%fields)) THEN
        CALL FlagError("Fields is already associated.",err,error,*999)
      ELSE
        fields%fields=>interface%interface%fields
      END IF
    ELSE
      CALL FlagError("The interface is not associated.",err,error,*999)
    END IF

    EXITS("OC_Fields_CreateInterface")
    RETURN
999 ERRORSEXITS("OC_Fields_CreateInterface",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_CreateInterface

  !
  !================================================================================================================================
  !

  !>Creates a OC_FieldsType object for a region by an object reference.
  SUBROUTINE OC_Fields_CreateRegion(region,fields,err)
    !DLLEXPORT(OC_Fields_CreateRegion)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the fields from
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_CreateRegion",err,error,*999)

    IF(ASSOCIATED(region%region)) THEN
      IF(ASSOCIATED(fields%fields)) THEN
        CALL FlagError("fields is already associated.",err,error,*999)
      ELSE
        fields%fields=>region%region%fields
      END IF
    ELSE
      CALL FlagError("The region is not associated.",err,error,*999)
    END IF

    EXITS("OC_Fields_CreateRegion")
    RETURN
999 ERRORSEXITS("OC_Fields_CreateRegion",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_CreateRegion

  !
  !================================================================================================================================
  !

  !>Finalises a OC_FieldsType object.
  SUBROUTINE OC_Fields_Finalise(OC_Fields,err)
    !DLLEXPORT(OC_Fields_Finalise)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(OUT) :: OC_Fields !<The OC_FieldsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_Finalise",err,error,*999)

    NULLIFY(OC_Fields%fields)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Fields Type')
#endif

    EXITS("OC_Fields_Finalise")
    RETURN
999 ERRORSEXITS("OC_Fields_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_FieldsType object.
  SUBROUTINE OC_Fields_Initialise(OC_Fields,err)
    !DLLEXPORT(OC_Fields_Initialise)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(OUT) :: OC_Fields !<The OC_FieldsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_Initialise",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Fields Type')
#endif

    NULLIFY(OC_Fields%fields)

    EXITS("OC_Fields_Initialise")
    RETURN
999 ERRORSEXITS("OC_Fields_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_GeneratedMeshType object.
  SUBROUTINE OC_GeneratedMesh_Finalise(OC_GeneratedMesh,err)
    !DLLEXPORT(OC_GeneratedMesh_Finalise)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(OUT) :: OC_GeneratedMesh !<The OC_GeneratedMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_GeneratedMesh%generatedMesh))  &
      & CALL GeneratedMesh_Destroy(OC_GeneratedMesh%generatedMesh,err,error,*999)

    EXITS("OC_GeneratedMesh_Finalise")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_GeneratedMeshType object.
  SUBROUTINE OC_GeneratedMesh_Initialise(OC_GeneratedMesh,err)
    !DLLEXPORT(OC_GeneratedMesh_Initialise)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(OUT) :: OC_GeneratedMesh !<The OC_GeneratedMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_Initialise",err,error,*999)

    NULLIFY(OC_GeneratedMesh%generatedMesh)

    EXITS("OC_GeneratedMesh_Initialise")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_InterfaceType object.
  SUBROUTINE OC_Interface_Finalise(OC_Interface,err)
    !DLLEXPORT(OC_Interface_Finalise)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(OUT) :: OC_Interface !<The OC_InterfaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Interface%interface))  &
      & CALL Interface_Destroy(OC_Interface%interface,err,error,*999)

    EXITS("OC_Interface_Finalise")
    RETURN
999 ERRORSEXITS("OC_Interface_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_InterfaceType object.
  SUBROUTINE OC_Interface_Initialise(OC_Interface,err)
    !DLLEXPORT(OC_Interface_Initialise)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(OUT) :: OC_Interface !<The OC_InterfaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_Initialise",err,error,*999)

    NULLIFY(OC_Interface%interface)

    EXITS("OC_Interface_Initialise")
    RETURN
999 ERRORSEXITS("OC_Interface_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_InterfaceConditionType object.
  SUBROUTINE OC_InterfaceCondition_Finalise(OC_InterfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_Finalise)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(OUT) :: OC_InterfaceCondition !<The OC_InterfaceConditionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_InterfaceCondition%interfaceCondition))  &
      & CALL InterfaceCondition_Destroy(OC_InterfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_Finalise")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_InterfaceConditionType object.
  SUBROUTINE OC_InterfaceCondition_Initialise(OC_InterfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_Initialise)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(OUT) :: OC_InterfaceCondition !<The OC_InterfaceConditionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_Initialise",err,error,*999)

    NULLIFY(OC_InterfaceCondition%interfaceCondition)

    EXITS("OC_InterfaceCondition_Initialise")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_InterfaceEquationsType object.
  SUBROUTINE OC_InterfaceEquations_Finalise(OC_InterfaceEquations,err)
    !DLLEXPORT(OC_InterfaceEquations_Finalise)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(OUT) :: OC_InterfaceEquations !<The OC_InterfaceEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_InterfaceEquations%interfaceEquations))  &
      & CALL InterfaceEquations_Destroy(OC_InterfaceEquations%interfaceEquations,err,error,*999)

    EXITS("OC_InterfaceEquations_Finalise")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_InterfaceEquationsType object.
  SUBROUTINE OC_InterfaceEquations_Initialise(OC_InterfaceEquations,err)
    !DLLEXPORT(OC_InterfaceEquations_Initialise)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(OUT) :: OC_InterfaceEquations !<The OC_InterfaceEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_Initialise",err,error,*999)

    NULLIFY(OC_InterfaceEquations%interfaceEquations)

    EXITS("OC_InterfaceEquations_Initialise")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalise a OC_InterfaceMeshConnectivityType object.
  SUBROUTINE OC_InterfacePointsConnectivity_Finalise(OC_InterfacePointsConnectivity,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_Finalise)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(OUT) :: OC_InterfacePointsConnectivity !<The OC_InterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_InterfacePointsConnectivity_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_InterfacePointsConnectivity%pointsConnectivity)) &
      & CALL InterfacePointsConnectivity_DESTROY(OC_InterfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_Finalise")
    RETURN
999 ERRORSEXITS("OC_InterfacePointsConnectivity_Finalise",err,error)
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_InterfaceMeshConnectivityType object.
  SUBROUTINE OC_InterfacePointsConnectivity_Initialise(OC_InterfacePointsConnectivity,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_Initialise)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(OUT) :: OC_InterfacePointsConnectivity !<The OC_InterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_InterfacePointsConnectivity_Initialise",err,error,*999)

    NULLIFY(OC_InterfacePointsConnectivity%pointsConnectivity)

    EXITS("OC_InterfacePointsConnectivity_Initialise")
    RETURN
999 ERRORSEXITS("OC_InterfacePointsConnectivity_Initialise",err,error)
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_InterfaceMeshConnectivityType object.
  SUBROUTINE OC_InterfaceMeshConnectivity_Finalise(OC_InterfaceMeshConnectivity,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_Finalise)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(OUT) :: OC_InterfaceMeshConnectivity !<The OC_InterfaceMeshConnectivityType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_InterfaceMeshConnectivity%meshConnectivity)) &
      & CALL InterfaceMeshConnectivity_Destroy(OC_InterfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_Finalise")
    RETURN
999 ERRORSEXITS("OC_InterfaceMeshConnectivity_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_InterfaceMeshConnectivityType object.
  SUBROUTINE OC_InterfaceMeshConnectivity_Initialise(OC_InterfaceMeshConnectivity,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_Initialise)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(OUT) :: OC_InterfaceMeshConnectivity !<The OC_InterfaceMeshConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_Initialise",err,error,*999)

    NULLIFY(OC_InterfaceMeshConnectivity%meshConnectivity)

    EXITS("OC_InterfaceMeshConnectivity_Initialise")
    RETURN
999 ERRORSEXITS("OC_InterfaceMeshConnectivity_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_HistoryType object.
  SUBROUTINE OC_History_Finalise(OC_History,err)
    !DLLEXPORT(OC_History_Finalise)

    !Argument variables
    TYPE(OC_HistoryType), INTENT(OUT) :: OC_History !<The OC_HistoryType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_History_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_History%history))  &
      & CALL History_Destroy(OC_History%history,err,error,*999)

    EXITS("OC_History_Finalise")
    RETURN
999 ERRORSEXITS("OC_History_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_History_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_HistoryType object.
  SUBROUTINE OC_History_Initialise(OC_History,err)
    !DLLEXPORT(OC_History_Initialise)

    !Argument variables
    TYPE(OC_HistoryType), INTENT(OUT) :: OC_History !<The OC_HistoryType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_History_Initialise",err,error,*999)

    NULLIFY(OC_History%history)

    EXITS("OC_History_Initialise")
    RETURN
999 ERRORSEXITS("OC_History_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_History_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_MeshType object.
  SUBROUTINE OC_Mesh_Finalise(OC_Mesh,err)
    !DLLEXPORT(OC_Mesh_Finalise)

    !Argument variables
    TYPE(OC_MeshType), INTENT(OUT) :: OC_Mesh !<The OC_MeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Mesh%mesh))  &
      & CALL Mesh_Destroy(OC_Mesh%mesh,err,error,*999)

    EXITS("OC_Mesh_Finalise")
    RETURN
999 ERRORSEXITS("OC_Mesh_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_MeshType object.
  SUBROUTINE OC_Mesh_Initialise(OC_Mesh,err)
    !DLLEXPORT(OC_Mesh_Initialise)

    !Argument variables
    TYPE(OC_MeshType), INTENT(OUT) :: OC_Mesh !<The OC_MeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_Initialise",err,error,*999)

    NULLIFY(OC_Mesh%mesh)

    EXITS("OC_Mesh_Initialise")
    RETURN
999 ERRORSEXITS("OC_Mesh_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_Initialise

  !
  !================================================================================================================================
  !7

  !>Finalises a OC_MeshElementsType object.
  SUBROUTINE OC_MeshElements_Finalise(OC_MeshElements,err)
    !DLLEXPORT(OC_MeshElements_Finalise)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(OUT) :: OC_MeshElements !<The OC_MeshElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_MeshElements%meshElements)) CALL MeshElements_Destroy(OC_MeshElements%meshElements,err,error,*999)

    EXITS("OC_MeshElements_Finalise")
    RETURN
999 ERRORSEXITS("OC_MeshElements_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_MeshElementsType object.
  SUBROUTINE OC_MeshElements_Initialise(OC_MeshElements,err)
    !DLLEXPORT(OC_MeshElements_Initialise)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(OUT) :: OC_MeshElements !<The OC_MeshElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_Initialise",err,error,*999)

    NULLIFY(OC_MeshElements%meshElements)

    EXITS("OC_MeshElements_Initialise")
    RETURN
999 ERRORSEXITS("OC_MeshElements_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_MeshNodesType object.
  SUBROUTINE OC_MeshNodes_Finalise(OC_MeshNodes,err)
    !DLLEXPORT(OC_MeshNodes_Finalise)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(OUT) :: OC_MeshNodes !<The OC_MeshNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_MeshNodes%meshNodes))  &
      & CALL MeshTopology_NodesDestroy(OC_MeshNodes%meshNodes,err,error,*999)

    EXITS("OC_MeshNodes_Finalise")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_MeshNodesType object.
  SUBROUTINE OC_MeshNodes_Initialise(OC_MeshNodes,err)
    !DLLEXPORT(OC_MeshNodes_Initialise)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(OUT) :: OC_MeshNodes !<The OC_MeshNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_Initialise",err,error,*999)

    NULLIFY(OC_MeshNodes%meshNodes)

    EXITS("OC_MeshNodes_Initialise")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_NodesType object.
  SUBROUTINE OC_Nodes_Finalise(OC_Nodes,err)
    !DLLEXPORT(OC_Nodes_Finalise)

    !Argument variables
    TYPE(OC_NodesType), INTENT(OUT) :: OC_Nodes !<The OC_NodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Nodes%nodes)) CALL Nodes_Destroy(OC_Nodes%nodes,err,error,*999)

    EXITS("OC_Nodes_Finalise")
    RETURN
999 ERRORSEXITS("OC_Nodes_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_NodesType object.
  SUBROUTINE OC_Nodes_Initialise(OC_Nodes,err)
    !DLLEXPORT(OC_Nodes_Initialise)

    !Argument variables
    TYPE(OC_NodesType), INTENT(OUT) :: OC_Nodes !<The OC_NodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_Initialise",err,error,*999)

    NULLIFY(OC_Nodes%nodes)

    EXITS("OC_Nodes_Initialise")
    RETURN
999 ERRORSEXITS("OC_Nodes_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_ProblemType object.
  SUBROUTINE OC_Problem_Finalise(OC_Problem,err)
    !DLLEXPORT(OC_Problem_Finalise)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(OUT) :: OC_Problem !<The OC_ProblemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Problem%problem)) CALL Problem_Destroy(OC_Problem%problem,err,error,*999)

    EXITS("OC_Problem_Finalise")
    RETURN
999 ERRORSEXITS("OC_Problem_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_ProblemType object.
  SUBROUTINE OC_Problem_Initialise(OC_Problem,err)
    !DLLEXPORT(OC_Problem_Initialise)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(OUT) :: OC_Problem !<The OC_ProblemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_Initialise",err,error,*999)

    NULLIFY(OC_Problem%problem)

    EXITS("OC_Problem_Initialise")
    RETURN
999 ERRORSEXITS("OC_Problem_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_QuadratureType object.
  SUBROUTINE OC_Quadrature_Finalise(OC_Quadrature,err)
    !DLLEXPORT(OC_Quadrature_Finalise)

    !Argument variables
    TYPE(OC_QuadratureType), INTENT(OUT) :: OC_Quadrature !<The OC_QuadratureType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Quadrature_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Quadrature%quadrature))  &
      & CALL Basis_QuadratureDestroy(OC_Quadrature%quadrature,err,error,*999)

    EXITS("OC_Quadrature_Finalise")
    RETURN
999 ERRORSEXITS("OC_Quadrature_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Quadrature_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_QuadratureType object.
  SUBROUTINE OC_Quadrature_Initialise(OC_Quadrature,err)
    !DLLEXPORT(OC_Quadrature_Initialise)

    !Argument variables
    TYPE(OC_QuadratureType), INTENT(OUT) :: OC_Quadrature !<The OC_QuadratureType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Quadrature_Initialise",err,error,*999)

    NULLIFY(OC_Quadrature%quadrature)

    EXITS("OC_Quadrature_Initialise")
    RETURN
999 ERRORSEXITS("OC_Quadrature_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Quadrature_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_RegionType object.
  SUBROUTINE OC_Region_Finalise(OC_Region,err)
    !DLLEXPORT(OC_Region_Finalise)

    !Argument variables
    TYPE(OC_RegionType), INTENT(OUT) :: OC_Region !<The OC_RegionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Region%region))  &
      & CALL Region_Destroy(OC_Region%region,err,error,*999)

    EXITS("OC_Region_Finalise")
    RETURN
999 ERRORSEXITS("OC_Region_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_RegionType object.
  SUBROUTINE OC_Region_Initialise(OC_Region,err)
    !DLLEXPORT(OC_Region_Initialise)

    !Argument variables
    TYPE(OC_RegionType), INTENT(OUT) :: OC_Region !<The OC_RegionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_Initialise",err,error,*999)

    NULLIFY(OC_Region%region)

    EXITS("OC_Region_Initialise")
    RETURN
999 ERRORSEXITS("OC_Region_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_SolverType object.
  SUBROUTINE OC_Solver_Finalise(OC_Solver,err)
    !DLLEXPORT(OC_Solver_Finalise)

    !Argument variables
    TYPE(OC_SolverType), INTENT(OUT) :: OC_Solver !<The OC_SolverType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_Solver%solver)) CALL Solver_Destroy(OC_Solver%solver,err,error,*999)

    EXITS("OC_Solver_Finalise")
    RETURN
999 ERRORSEXITS("OC_Solver_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_SolverType object.
  SUBROUTINE OC_Solver_Initialise(OC_Solver,err)
    !DLLEXPORT(OC_Solver_Initialise)

    !Argument variables
    TYPE(OC_SolverType), INTENT(OUT) :: OC_Solver !<The OC_SolverType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_Initialise",err,error,*999)

    NULLIFY(OC_Solver%solver)

    EXITS("OC_Solver_Initialise")
    RETURN
999 ERRORSEXITS("OC_Solver_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_SolverEquationsType object.
  SUBROUTINE OC_SolverEquations_Finalise(OC_SolverEquations,err)
    !DLLEXPORT(OC_SolverEquations_Finalise)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(OUT) :: OC_SolverEquations !<The OC_SolverEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_SolverEquations%solverEquations))  &
      & CALL SolverEquations_Destroy(OC_SolverEquations%solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_Finalise")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_SolverEquationsType object.
  SUBROUTINE OC_SolverEquations_Initialise(OC_SolverEquations,err)
    !DLLEXPORT(OC_SolverEquations_Initialise)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(OUT) :: OC_SolverEquations !<The OC_SolverEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_Initialise",err,error,*999)

    NULLIFY(OC_SolverEquations%solverEquations)

    EXITS("OC_SolverEquations_Initialise")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a OC_WorkGroupType object.
  SUBROUTINE OC_WorkGroup_Finalise(OC_WorkGroup,err)
    !DLLEXPORT(OC_WorkGroup_Finalise)

    !Argument variables
    TYPE(OC_WorkGroupType), INTENT(OUT) :: OC_WorkGroup !<The OC_WorkGroupType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_WorkGroup_Finalise",err,error,*999)

    IF(ASSOCIATED(OC_WorkGroup%workGroup)) CALL WorkGroup_Destroy(OC_WorkGroup%workGroup,err,error,*999)

    EXITS("OC_WorkGroup_Finalise")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_Finalise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a OC_WorkGroupType object.
  SUBROUTINE OC_WorkGroup_Initialise(OC_WorkGroup,err)
    !DLLEXPORT(OC_WorkGroup_Initialise)

    !Argument variables
    TYPE(OC_WorkGroupType), INTENT(OUT) :: OC_WorkGroup !<The OC_WorkGroupType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_WorkGroup_Initialise",err,error,*999)

    NULLIFY(OC_WorkGroup%workGroup)

    EXITS("OC_WorkGroup_Initialise")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_Initialise

!!==================================================================================================================================
!!
!! AnalyticAnalysisRoutines
!!
!!==================================================================================================================================

  !>Output the analytic error analysis for a field specified by a user number compared to the analytic values parameter set.
  SUBROUTINE OC_AnalyticAnalysis_OutputNumber(contextUserNumber,regionUserNumber,fieldUserNumber,fileName,err)
    !DLLEXPORT(OC_AnalyticAnalysis_OutputNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_OutputNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_Output(field,fileName,err,error,*999)

    EXITS("OC_AnalyticAnalysis_OutputNumber")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_OutputNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_OutputNumber

  !
  !================================================================================================================================
  !

  !>Output the analytic error analysis for a field identified by an object compared to the analytic values parameter set.
  SUBROUTINE OC_AnalyticAnalysis_OutputObj(field,fileName,err)
    !DLLEXPORT(OC_AnalyticAnalysis_OutputObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_OutputObj",err,error,*999)

    CALL AnalyticAnalysis_Output(field%field,fileName,err,error,*999)

    EXITS("OC_AnalyticAnalysis_OutputObj")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_OutputObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_OutputObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_AbsoluteErrorGetNode(field,variableType,versionNumber,derivativeNumber,nodeNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber",err,error)
    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj",err,error)
    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_PercentageErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_PercentageErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_PercentageErrorGetNode(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_PercentageErrorGetNodeNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_PercentageErrorGetNodeNumber",err,error)
    EXITS("OC_AnalyticAnalysis_PercentageErrorGetNodeNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_PercentageErrorGetNodeObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_PercentageErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_PercentageErrorGetNodeObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_PercentageErrorGetNodeObj",err,error)
    EXITS("OC_AnalyticAnalysis_PercentageErrorGetNodeObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetNodeObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RelativeErrorGetNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_RelativeErrorGetNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RelativeErrorGetNode(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RelativeErrorGetNodeNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RelativeErrorGetNodeNumber",err,error)
    EXITS("OC_AnalyticAnalysis_RelativeErrorGetNodeNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RelativeErrorGetNodeObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_RelativeErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RelativeErrorGetNodeObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RelativeErrorGetNodeObj",err,error)
    EXITS("OC_AnalyticAnalysis_RelativeErrorGetNodeObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & elementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_AbsoluteErrorGetElement(field,variableType,elementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber",err,error)
    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_AnalyticAnalysis_AbsoluteErrorGetElementObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_AbsoluteErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetElementObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_AbsoluteErrorGetElementObj",err,error)
    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetElementObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,elementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_PercentageErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_PercentageErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_PercentageErrorGetElement(field,variableType,elementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_PercentageErrorGetElementNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_PercentageErrorGetElementNumber",err,error)
    EXITS("OC_AnalyticAnalysis_PercentageErrorGetElementNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_AnalyticAnalysis_PercentageErrorGetElementObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_PercentageErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_PercentageErrorGetElementObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_PercentageErrorGetElementObj",err,error)
    EXITS("OC_AnalyticAnalysis_PercentageErrorGetElementObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetElementObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & elementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RelativeErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_RelativeErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RelativeErrorGetElement(field,variableType,elementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RelativeErrorGetElementNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RelativeErrorGetElementNumber",err,error)
    EXITS("OC_AnalyticAnalysis_RelativeErrorGetElementNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RelativeErrorGetElementObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: value !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_RelativeErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RelativeErrorGetElementObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RelativeErrorGetElementObj",err,error)
    EXITS("OC_AnalyticAnalysis_RelativeErrorGetElementObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_AbsoluteErrorGetConstant(field,variableType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber",err,error)
    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)
    !DLLEXPORT(OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj",err,error)
    EXITS("OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_AbsoluteErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetConstantNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_PercentageErrorGetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_PercentageErrorGetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_PercentageErrorGetConstant(field,variableType,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_PercentageErrorGetConstantNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_PercentageErrorGetConstantNumber",err,error)
    EXITS("OC_AnalyticAnalysis_PercentageErrorGetConstantNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)
    !DLLEXPORT(OC_AnalyticAnalysis_PercentageErrorGetConstantObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_PercentageErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_PercentageErrorGetConstantObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_PercentageErrorGetConstantObj",err,error)
    EXITS("OC_AnalyticAnalysis_PercentageErrorGetConstantObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_PercentageErrorGetConstantObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetConstantNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,value,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RelativeErrorGetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_RelativeErrorGetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RelativeErrorGetConstant(field,variableType,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RelativeErrorGetConstantNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RelativeErrorGetConstantNumber",err,error)
    EXITS("OC_AnalyticAnalysis_RelativeErrorGetConstantNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RelativeErrorGetConstantObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: value !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_RelativeErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RelativeErrorGetConstantObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RelativeErrorGetConstantObj",err,error)
    EXITS("OC_AnalyticAnalysis_RelativeErrorGetConstantObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RelativeErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get RMS error value for nodes in a field compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeNumber0(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,errorType,localValue,localGhostValue,globalValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RMSErrorGetNodeNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: errorType !<The analytic analysis error type to return \see OpenCMISS_AnalyticErrorTypes
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    REAL(DP) ::  localValues(1),localGhostValues(1),globalValues(1)
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_RMSErrorGetNodeNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RMSErrorGetNode(field,variableType,componentNumber,errorType,localValues,localGhostValues, &
      & globalValues,err,error,*999)
    localValue=localValues(1)
    localGhostValue=localGhostValues(1)
    globalValue=globalValues(1)

    EXITS("OC_AnalyticAnalysis_RMSErrorGetNodeNumber0")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_RMSErrorGetNodeNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeNumber0

  !
  !================================================================================================================================
  !

  !>Get RMS error value for nodes in a field compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeNumber1(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,errorType,localValues,localGhostValues,globalValues,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RMSErrorGetNodeNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: errorType !<The analytic analysis error type to return \see OpenCMISS_AnalyticErrorTypes
    REAL(DP), INTENT(OUT) :: localValues(:) !<localValues(derivativeIdx). On return, the local error for the derivativeIdx'th derivative. The array size must be greater than the maximum number of derivatives for the nodes.
    REAL(DP), INTENT(OUT) :: localGhostValues(:) !<localGhostValues(derivativeIdx). On return, the local ghost error for the derivativeIdx'th derivative. The array size must be greater than the maximum number of derivatives for the nodes.
    REAL(DP), INTENT(OUT) :: globalValues(:) !<globalValues(derivativeIdx). On return, the global error for the derivativeIdx'th derivative. The array size must be greater than the maximum number of derivatives for the nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_RMSErrorGetNodeNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RMSErrorGetNode(field,variableType,componentNumber,errorType,localValues,localGhostValues, &
      & globalValues,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RMSErrorGetNodeNumber1")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_RMSErrorGetNodeNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeNumber1

  !
  !================================================================================================================================
  !

  !>Get RMS error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeObj0(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RMSErrorGetNodeObj0)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: errorType !<The analytic analysis error type to return \see OpenCMISS_AnalyticErrorTypes
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    REAL(DP) :: localValues(1),localGhostValues(1),globalValues(1)

    ENTERS("OC_AnalyticAnalysis_RMSErrorGetNodeObj0",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetNode(field%field,variableType,componentNumber,errorType,localValues,localGhostValues, &
      & globalValues,err,error,*999)
    localValue=localValues(1)
    localGhostValue=localGhostValues(1)
    globalValue=globalValues(1)

    EXITS("OC_AnalyticAnalysis_RMSErrorGetNodeObj0")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_RMSErrorGetNodeObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeObj0

  !
  !================================================================================================================================
  !

  !>Get RMS error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeObj1(field,variableType,componentNumber,errorType,localValues,localGhostValues, &
    & globalValues,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RMSErrorGetNodeObj1)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: errorType !<The analytic analysis error type to return \see OpenCMISS_AnalyticErrorTypes
    REAL(DP), INTENT(OUT) :: localValues(:) !<localValues(derivativeIdx). On return, the local error for the derivativeIdx'th derivative. The array size must be greater than the maximum number of derivatives for the nodes.
    REAL(DP), INTENT(OUT) :: localGhostValues(:) !<On return, the local ghost error for the derivativeIdx'th derivative. The array size must be greater than the maximum number of derivatives for the nodes.
    REAL(DP), INTENT(OUT) :: globalValues(:) !<On return, the global error for the derivativeIdx'th derivative. The array size must be greater than the maximum number of derivatives for the nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_RMSErrorGetNodeObj1",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetNode(field%field,variableType,componentNumber,errorType,localValues,localGhostValues, &
      & globalValues,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RMSErrorGetNodeObj1")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_RMSErrorGetNodeObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetNodeObj1

  !
  !================================================================================================================================
  !

  !>Get RMS error value for elements in a field identified by user numbers compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetElementNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,errorType,localValue,localGhostValue,globalValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RMSErrorGetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: errorType !<The analytic analysis error type to return \see OpenCMISS_AnalyticErrorTypes
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_RMSErrorGetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_RMSErrorGetElement(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RMSErrorGetElementNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_RMSErrorGetElementNumber",err,error)
    EXITS("OC_AnalyticAnalysis_RMSErrorGetElementNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get RMS error value for elements in a field identified by an object compared to the analytic value.
  SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetElementObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_RMSErrorGetElementObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: errorType !<The analytic analysis error type to return \see OpenCMISS_AnalyticErrorTypes
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_RMSErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetElement(field%field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("OC_AnalyticAnalysis_RMSErrorGetElementObj")
    RETURN
999 ERRORSEXITS("OC_AnalyticAnalysis_RMSErrorGetElementObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_RMSErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE OC_AnalyticAnalysis_IntegralNumericalValueGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralNumericalValueGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralNumericalValueGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralNumericalValueGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralNumericalValueGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralNumericalValueGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralNumericalValueGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE OC_AnalyticAnalysis_IntegralNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralNumericalValueGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralNumericalValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNumericalValueGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralNumericalValueGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralNumericalValueGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralNumericalValueGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralAnalyticValueGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralAnalyticValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE OC_AnalyticAnalysis_IntegralAnalyticValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralAnalyticValueGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralAnalyticValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralAnalyticValueGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralAnalyticValueGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralAnalyticValueGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralAnalyticValueGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralAnalyticValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralPercentageErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralPercentageErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE OC_AnalyticAnalysis_IntegralPercentageErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralPercentageErrorGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralPercentageErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralPercentageErrorGet(field%field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralPercentageErrorGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralPercentageErrorGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralPercentageErrorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralPercentageErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralAbsoluteErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralAbsoluteErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralAbsoluteErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralRelativeErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralRelativeErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE OC_AnalyticAnalysis_IntegralRelativeErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralRelativeErrorGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralRelativeErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralRelativeErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralRelativeErrorGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralRelativeErrorGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralRelativeErrorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralRelativeErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralNIDNumericalValueGet(field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNIDNumericalValueGet(field%field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralNIDNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE OC_AnalyticAnalysis_IntegralNIDErrorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralNIDErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_AnalyticAnalysis_IntegralNIDErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL AnalyticAnalysis_IntegralNIDErrorGet(field,variableType,componentNumber,integralValue,ghostIntegralValue,err, &
      & error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralNIDErrorGetNumber")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralNIDErrorGetNumber",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralNIDErrorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralNIDErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE OC_AnalyticAnalysis_IntegralNIDErrorGetObj(field,variableType,componentNumber,integralValue,ghostIntegralValue,err)
    !DLLEXPORT(OC_AnalyticAnalysis_IntegralNIDErrorGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to calculate the analytic analytic error analysis for \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to calculate the analytic error analysis for.
    REAL(DP), INTENT(OUT) :: integralValue(:) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(:) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_AnalyticAnalysis_IntegralNIDErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNIDErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue,err, &
      & error,*999)

    EXITS("OC_AnalyticAnalysis_IntegralNIDErrorGetObj")
    RETURN
999 ERRORS("OC_AnalyticAnalysis_IntegralNIDErrorGetObj",err,error)
    EXITS("OC_AnalyticAnalysis_IntegralNIDErrorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_AnalyticAnalysis_IntegralNIDErrorGetObj


!!==================================================================================================================================
!!
!! BaseRoutines
!!
!!==================================================================================================================================

  !>Sets diagnostics off. \see OpenCMISS::OC_DiagnosticsSetOn
  SUBROUTINE OC_DiagnosticsSetOff(err)
    !DLLEXPORT(OC_DiagnosticsSetOff)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_DiagnosticsSetOff",err,error,*999)

    CALL DiagnosticsSetOff(err,error,*999)

    EXITS("OC_DiagnosticsSetOff")
    RETURN
999 ERRORSEXITS("OC_DiagnosticsSetOff",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DiagnosticsSetOff

  !
  !================================================================================================================================
  !

  !>Sets diagnostics on \see OpenCMISS::OC_DiagnosticsSetOff
  SUBROUTINE OC_DiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err)
    !DLLEXPORT(OC_DiagnosticsSetOn)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: diagType !<The type of diagnostics to set on \see OpenCMISS_DiagnosticTypes.
    INTEGER(INTG), INTENT(IN) :: levelList(:) !<The list of diagnostic levels to set on.
    CHARACTER(LEN=*), INTENT(IN) :: diagFilename !<If present the name of the file to output diagnostic information to. If omitted the diagnostic output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set diagnostics on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_DiagnosticsSetOn",err,error,*999)

    CALL DiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err,error,*999)

    EXITS("OC_DiagnosticsSetOn")
    RETURN
999 ERRORSEXITS("OC_DiagnosticsSetOn",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DiagnosticsSetOn

  !
  !================================================================================================================================
  !

  !>Sets output off \see OpenCMISS::OC_OutputSetOff
  SUBROUTINE OC_OutputSetOff(err)
    !DLLEXPORT(OC_OutputSetOff)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_OutputSetOff",err,error,*999)

    CALL OutputSetOff(err,error,*999)

    EXITS("OC_OutputSetOff")
    RETURN
999 ERRORSEXITS("OC_OutputSetOff",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_OutputSetOff

  !
  !================================================================================================================================
  !

  !>Sets output on \see OpenCMISS::OC_OutputSetOff
  SUBROUTINE OC_OutputSetOn(echoFilename,err)
    !DLLEXPORT(OC_OutputSetOn)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: echoFilename !<The filename of the file to echo output to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_OutputSetOn",err,error,*999)

    CALL OutputSetOn(echoFilename,err,error,*999)

    EXITS("OC_OutputSetOn")
    RETURN
999 ERRORSEXITS("OC_OutputSetOn",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_OutputSetOn

  !
  !================================================================================================================================
  !

  !>Sets timing off \see OpenCMISS::OC_TimingSetOn
  SUBROUTINE OC_TimingSetOff(err)
    !DLLEXPORT(OC_TimingSetOff)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_TimingSetOff",err,error,*999)

    CALL TimingSetOff(err,error,*999)

    EXITS("OC_TimingSetOff")
    RETURN
999 ERRORSEXITS("OC_TimingSetOff",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_TimingSetOff

  !
  !================================================================================================================================
  !

  !>Sets timing on \see OpenCMISS::OC_TimingSetOff
  SUBROUTINE OC_TimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err)
    !DLLEXPORT(OC_TimingSetOn)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: timingType !<The type of timing to set on \see OpenCMISS_TimingTypes.
    LOGICAL, INTENT(IN) :: timingSummaryFlag !<.TRUE. if the timing information will be output with subsequent OpenCMISS::OC_TimingSummaryOutput calls, .FALSE. if the timing information will be output every time the routine exits.
    CHARACTER(LEN=*), INTENT(IN) :: timingFilename !<If present the name of the file to output timing information to. If omitted the timing output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set timing on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_TimingSetOn",err,error,*999)

    CALL TimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err,error,*999)

    EXITS("OC_TimingSetOn")
    RETURN
999 ERRORSEXITS("OC_TimingSetOn",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_TimingSetOn

  !
  !================================================================================================================================
  !

  !>Outputs the timing summary.
  SUBROUTINE OC_TimingSummaryOutput(err)
    !DLLEXPORT(OC_TimingSummaryOutput)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    !Local variables

    ENTERS("OC_TimingSummaryOutput",err,error,*999)

    CALL TimingSummaryOutput(err,error,*999)

    EXITS("OC_TimingSummaryOutput")
    RETURN
999 ERRORSEXITS("OC_TimingSummaryOutput",err,error)
    RETURN

  END SUBROUTINE OC_TimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !> \addtogroup OpenCMISS_Basis OpenCMISS::Basis
  !>@{
  
  !>Returns the collapsed Xi flags of a basis identified by user number.
  SUBROUTINE OC_Basis_CollapsedXiGetNumber(contextUserNumber,basisUserNumber,collapsedXi,err)
    !DLLEXPORT(OC_Basis_CollapsedXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(xiIdx). On return, the collapsed Xi parameter for the xiIdx'th Xi direction. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_CollapsedXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_CollapsedXiGet(basis,collapsedXi,err,error,*999)

    EXITS("OC_Basis_CollapsedXiGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_CollapsedXiGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CollapsedXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE OC_Basis_CollapsedXiGetObj(basis,collapsedXi,err)
    !DLLEXPORT(OC_Basis_CollapsedXiGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(xiIdx). On return, the collapsed Xi parameter for the xiIdx'th Xi direction. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_CollapsedXiGetObj",err,error,*999)

    CALL Basis_CollapsedXiGet(basis%basis,collapsedXi,err,error,*999)

    EXITS("OC_Basis_CollapsedXiGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_CollapsedXiGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CollapsedXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE OC_Basis_CollapsedXiSetNumber(contextUserNumber,basisUserNumber,collapsedXi,err)
    !DLLEXPORT(OC_Basis_CollapsedXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(xiIdx). The collapsed Xi parameter for the xiIdx'th Xi direction to set. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_CollapsedXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_CollapsedXiSet(basis,collapsedXi,err,error,*999)

    EXITS("OC_Basis_CollapsedXiSetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_CollapsedXiSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CollapsedXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE OC_Basis_CollapsedXiSetObj(basis,collapsedXi,err)
    !DLLEXPORT(OC_Basis_CollapsedXiSetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(xiIdx). The collapsed Xi parameter for the xiIdx'th Xi direction to set. \see OpenCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_CollapsedXiSetObj",err,error,*999)

    CALL Basis_CollapsedXiSet(basis%basis,collapsedXi,err,error,*999)

    EXITS("OC_Basis_CollapsedXiSetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_CollapsedXiSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CollapsedXiSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new basis identified by a user number.
  SUBROUTINE OC_Basis_CreateFinishNumber(contextUserNumber,basisUserNumber,err)
    !DLLEXPORT(OC_Basis_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_CreateFinish(basis,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    EXITS("OC_Basis_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new basis identified by an object.
  SUBROUTINE OC_Basis_CreateFinishObj(basis,err)
    !DLLEXPORT(OC_Basis_CreateFinishObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_Basis_CreateFinishObj",err,error,*999)

    CALL Basis_CreateFinish(basis%basis,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('basis Create')
#endif

    EXITS("OC_Basis_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Basis_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by a user number.
  SUBROUTINE OC_Basis_CreateStartNumber(basisUserNumber,contextUserNumber,err)
    !DLLEXPORT(OC_Basis_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_CreateStart(basisUserNumber,basisFunctions,basis,err,error,*999)

    EXITS("OC_Basis_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by an object.
  SUBROUTINE OC_Basis_CreateStartObj(userNumber,context,basis,err)
    !DLLEXPORT(OC_Basis_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to create the basis function for.
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<On exit, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('basis Create')
#endif

    NULLIFY(basisFunctions)
    CALL Context_BasisFunctionsGet(context%context,basisFunctions,err,error,*999)
    CALL Basis_CreateStart(userNumber,basisFunctions,basis%basis,err,error,*999)

    EXITS("OC_Basis_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Basis_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by its basis user number.
  SUBROUTINE OC_Basis_DestroyNumber(contextUserNumber,basisUserNumber,err)
    !DLLEXPORT(OC_Basis_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_Destroy(basis,err,error,*999)

    EXITS("OC_Basis_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by an object.
  SUBROUTINE OC_Basis_DestroyObj(basis,err)
    !DLLEXPORT(OC_Basis_DestroyObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_DestroyObj",err,error,*999)

    CALL Basis_Destroy(basis%basis,err,error,*999)

    EXITS("OC_Basis_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Basis_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_DestroyObj

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE OC_Basis_InterpolationXiGetNumber(contextUserNumber,basisUserNumber,interpolationXi,err)
    !DLLEXPORT(OC_Basis_InterpolationXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<interpolationXi(xiIdx). On return, the interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_InterpolationXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_InterpolationXiGet(basis,interpolationXi,err,error,*999)

    EXITS("OC_Basis_InterpolationXiGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_InterpolationXiGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_InterpolationXiGetNumber

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE OC_Basis_InterpolationXiGetObj(basis,interpolationXi,err)
    !DLLEXPORT(OC_Basis_InterpolationXiGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<interpolationXi(xiIdx). On return, the interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_InterpolationXiGetObj",err,error,*999)

    CALL Basis_InterpolationXiGet(basis%basis,interpolationXi,err,error,*999)

    EXITS("OC_Basis_InterpolationXiGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_InterpolationXiGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_InterpolationXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE OC_Basis_InterpolationXiSetNumber0(contextUserNumber,basisUserNumber,interpolationXi,err)
    !DLLEXPORT(OC_Basis_InterpolationXiSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi !<The interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("OC_Basis_InterpolationXiSetNumber0",err,error,*999)

    CALL OC_Basis_InterpolationXiSetNumber1(contextUserNumber,basisUserNumber,[interpolationXi],err)

    EXITS("OC_Basis_InterpolationXiSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Basis_InterpolationXiSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_InterpolationXiSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE OC_Basis_InterpolationXiSetNumber1(contextUserNumber,basisUserNumber,interpolationXi,err)
    !DLLEXPORT(OC_Basis_InterpolationXiSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<interpolationXi(xiIdx). The interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_InterpolationXiSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_InterpolationXiSet(basis,interpolationXi,err,error,*999)

    EXITS("OC_Basis_InterpolationXiSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Basis_InterpolationXiSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_InterpolationXiSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE OC_Basis_InterpolationXiSetObj0(basis,interpolationXi,err)
    !DLLEXPORT(OC_Basis_InterpolationXiSetObj0)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi !<The interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_InterpolationXiSetObj0",err,error,*999)

    CALL Basis_InterpolationXiSet(basis%basis,[interpolationXi],err,error,*999)

    EXITS("OC_Basis_InterpolationXiSetObj0")
    RETURN
999 ERRORSEXITS("OC_Basis_InterpolationXiSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_InterpolationXiSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE OC_Basis_InterpolationXiSetObj1(basis,interpolationXi,err)
    !DLLEXPORT(OC_Basis_InterpolationXiSetObj1)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<interpolationXi(xiIdx). The interpolation xi parameters for each Xi direction \see OpenCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_InterpolationXiSetObj1",err,error,*999)

    CALL Basis_InterpolationXiSet(basis%basis,interpolationXi,err,error,*999)

    EXITS("OC_Basis_InterpolationXiSetObj1")
    RETURN
999 ERRORSEXITS("OC_Basis_InterpolationXiSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_InterpolationXiSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by a user number.
  SUBROUTINE OC_Basis_NumberOfLocalNodesGetNumber(contextUserNumber,basisUserNumber,numberOfLocalNodes,err)
    !DLLEXPORT(OC_Basis_NumberOfLocalNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_NumberOfLocalNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_NumberOfLocalNodesGet(basis,numberOfLocalNodes,err,error,*999)

    EXITS("OC_Basis_NumberOfLocalNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_NumberOfLocalNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_NumberOfLocalNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by an object.
  SUBROUTINE OC_Basis_NumberOfLocalNodesGetObj(basis,numberOfLocalNodes,err)
    !DLLEXPORT(OC_Basis_NumberOfLocalNodesGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_NumberOfLocalNodesGetObj",err,error,*999)

    CALL Basis_NumberOfLocalNodesGet(basis%basis,numberOfLocalNodes,err,error,*999)

    EXITS("OC_Basis_NumberOfLocalNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_NumberOfLocalNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_NumberOfLocalNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by a user number.
  SUBROUTINE OC_Basis_NumberOfXiGetNumber(contextUserNumber,basisUserNumber,numberOfXi,err)
    !DLLEXPORT(OC_Basis_NumberOfXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the number xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_NumberOfXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_NumberOfXiGet(basis,numberOfXi,err,error,*999)

    EXITS("OC_Basis_NumberOfXiGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_NumberOfXiGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_NumberOfXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by an object.
  SUBROUTINE OC_Basis_NumberOfXiGetObj(basis,numberOfXi,err)
    !DLLEXPORT(OC_Basis_NumberOfXiGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the number of xi directions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_NumberOfXiGetObj",err,error,*999)

    CALL Basis_NumberOfXiGet(basis%basis,numberOfXi,err,error,*999)

    EXITS("OC_Basis_NumberOfXiGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_NumberOfXiGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_NumberOfXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by a user number.
  SUBROUTINE OC_Basis_NumberOfXiSetNumber(contextUserNumber,basisUserNumber,numberOfXi,err)
    !DLLEXPORT(OC_Basis_NumberOfXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the number xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_NumberOfXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_NumberOfXiSet(basis,numberOfXi,err,error,*999)

    EXITS("OC_Basis_NumberOfXiSetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_NumberOfXiSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_NumberOfXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by an object.
  SUBROUTINE OC_Basis_NumberOfXiSetObj(basis,numberOfXi,err)
    !DLLEXPORT(OC_Basis_NumberOfXiSetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to set the number of xi directions for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_NumberOfXiSetObj",err,error,*999)

    CALL Basis_NumberOfXiSet(basis%basis,numberOfXi,err,error,*999)

    EXITS("OC_Basis_NumberOfXiSetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_NumberOfXiSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_NumberOfXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiGetNumber(contextUserNumber,basisUserNumber,numberOfGaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureNumberOfGaussXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<numberOfGauss(xiIdx). On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureNumberOfGaussXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureNumberOfGaussXiGet(basis,numberOfGaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureNumberOfGaussXiGetNumber")
    RETURN
999 ERRORS("OC_Basis_QuadratureNumberOfGaussXiGetNumber",err,error)
    EXITS("OC_Basis_QuadratureNumberOfGaussXiGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiGetObj(basis,numberOfGaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureNumberOfGaussXiGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<numberOfGaussXi(xiIdx). On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureNumberOfGaussXiGetObj",err,error,*999)

    CALL Basis_QuadratureNumberOfGaussXiGet(basis%basis,numberOfGaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureNumberOfGaussXiGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureNumberOfGaussXiGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetNumber0(contextUserNumber,basisUserNumber,numberOfGaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureNumberOfGaussXiSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureNumberOfGaussXiSetNumber0",err,error,*999)

    CALL OC_Basis_QuadratureNumberOfGaussXiSetNumber1(contextUserNumber,basisUserNumber,[numberofGaussXi],err)


    EXITS("OC_Basis_QuadratureNumberOfGaussXiSetNumber0")
    RETURN
999 ERRORS("OC_Basis_QuadratureNumberOfGaussXiSetNumber0",err,error)
    EXITS("OC_Basis_QuadratureNumberOfGaussXiSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetNumber1(contextUserNumber,basisUserNumber,numberOfGaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureNumberOfGaussXiSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<numberOfGaussXi(xiIdx). The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureNumberOfGaussXiSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureNumberOfGaussXiSet(basis,numberOfGaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureNumberOfGaussXiSetNumber1")
    RETURN
999 ERRORS("OC_Basis_QuadratureNumberOfGaussXiSetNumber1",err,error)
    EXITS("OC_Basis_QuadratureNumberOfGaussXiSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetObj0(basis,numberOfGaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureNumberOfGaussXiSetObj0)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureNumberOfGaussXiSetObj0",err,error,*999)

    CALL Basis_QuadratureNumberOfGaussXiSet(basis%basis,[numberOfGaussXi],err,error,*999)

    EXITS("OC_Basis_QuadratureNumberOfGaussXiSetObj0")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureNumberOfGaussXiSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetObj1(basis,numberOfGaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureNumberOfGaussXiSetObj1)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<numberOfGaussXi(xiIdx). The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureNumberOfGaussXiSetObj1",err,error,*999)

    CALL Basis_QuadratureNumberOfGaussXiSet(basis%basis,numberOfGaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureNumberOfGaussXiSetObj1")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureNumberOfGaussXiSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureNumberOfGaussXiSetObj1

  !
  !================================================================================================================================
  !
  
  !>Returns the xi position of a Gauss point on a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureGaussXiGetNumber0(contextUserNumber,basisUserNumber,quadratureScheme,gaussPoint,gaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureGaussXiGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:) !<On return, gaussXi(xiIdx) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureGaussXiGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureGaussXiGet(basis,quadratureScheme,gaussPoint,gaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureGaussXiGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureGaussXiGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureGaussXiGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the xi position of a Gauss point on a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureGaussXiGetObj0(basis,quadratureScheme,gaussPoint,gaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureGaussXiGetObj0)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:) !<On return, gaussXi(xiIdx) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureGaussXiGetObj0",err,error,*999)

    CALL Basis_QuadratureGaussXiGet(basis%basis,quadratureScheme,gaussPoint,gaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureGaussXiGetObj0")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureGaussXiGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureGaussXiGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureGaussXiGetNumber1(contextUserNumber,basisUserNumber,quadratureScheme,gaussPoints,gaussXi, &
    & err)
    !DLLEXPORT(OC_Basis_QuadratureGaussXiGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:,:) !<gaussXi(gaussPointIdx,xiIdx). On return, the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureGaussXiGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureGaussXiGet(basis,quadratureScheme,gaussPoints,gaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureGaussXiGetNumber1")
    RETURN
999 ERRORS("OC_Basis_QuadratureGaussXiGetNumber1",err,error)
    EXITS("OC_Basis_QuadratureGaussXiGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureGaussXiGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureGaussXiGetObj1(basis,quadratureScheme,gaussPoints,gaussXi,err)
    !DLLEXPORT(OC_Basis_QuadratureGaussXiGetObj1)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: gaussXi(:,:) !<gaussXi(gaussPointIdx,xiIdx). On return, the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureGaussXiGetObj1",err,error,*999)

    CALL Basis_QuadratureGaussXiGet(basis%basis,quadratureScheme,gaussPoints,gaussXi,err,error,*999)

    EXITS("OC_Basis_QuadratureGaussXiGetObj1")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureGaussXiGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureGaussXiGetObj1

  !
  !================================================================================================================================
  !

  !>Returns the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureOrderGetNumber(contextUserNumber,basisUserNumber,quadratureOrder,err)
    !DLLEXPORT(OC_Basis_QuadratureOrderGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureOrderGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureOrderGet(basis,quadratureOrder,err,error,*999)

    EXITS("OC_Basis_QuadratureOrderGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureOrderGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureOrderGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureOrderGetObj(basis,quadratureOrder,err)
    !DLLEXPORT(OC_Basis_QuadratureOrderGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureOrderGetObj",err,error,*999)

    CALL Basis_QuadratureOrderGet(basis%basis,quadratureOrder,err,error,*999)

    EXITS("OC_Basis_QuadratureOrderGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureOrderGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureOrderGetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureOrderSetNumber(contextUserNumber,basisUserNumber,quadratureOrder,err)
    !DLLEXPORT(OC_Basis_QuadratureOrderSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureOrderSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureOrderSet(basis,quadratureOrder,err,error,*999)

    EXITS("OC_Basis_QuadratureOrderSetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureOrderSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureOrderSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureOrderSetObj(basis,quadratureOrder,err)
    !DLLEXPORT(OC_Basis_QuadratureOrderSetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureOrderSetObj",err,error,*999)

    CALL Basis_QuadratureOrderSet(basis%basis,quadratureOrder,err,error,*999)

    EXITS("OC_Basis_QuadratureOrderSetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureOrderSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureOrderSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureTypeGetNumber(contextUserNumber,basisUserNumber,quadratureType,err)
    !DLLEXPORT(OC_Basis_QuadratureTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureTypeGet(basis,quadratureType,err,error,*999)

    EXITS("OC_Basis_QuadratureTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureTypeGetObj(basis,quadratureType,err)
    !DLLEXPORT(OC_Basis_QuadratureTypeGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureTypeGetObj",err,error,*999)

    CALL Basis_QuadratureTypeGet(basis%basis,quadratureType,err,error,*999)

    EXITS("OC_Basis_QuadratureTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE OC_Basis_QuadratureTypeSetNumber(contextUserNumber,basisUserNumber,quadratureType,err)
    !DLLEXPORT(OC_Basis_QuadratureTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureTypeSet(basis,quadratureType,err,error,*999)

    EXITS("OC_Basis_QuadratureTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE OC_Basis_QuadratureTypeSetObj(basis,quadratureType,err)
    !DLLEXPORT(OC_Basis_QuadratureTypeSetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OpenCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_QuadratureTypeSetObj",err,error,*999)

    CALL Basis_QuadratureTypeSet(basis%basis,quadratureType,err,error,*999)

    EXITS("OC_Basis_QuadratureTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_QuadratureTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by a user number.
  SUBROUTINE OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber(contextUserNumber,basisUserNumber,faceGaussEvaluate,err)
    !DLLEXPORT(OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The value to set face Gauss evaluation flag to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_QuadratureLocalFaceGaussEvaluateSet(basis,faceGaussEvaluate,err,error,*999)

    EXITS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber")
    RETURN
999 ERRORS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error)
    EXITS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureLocalFaceGaussEvaluateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by an object.
  SUBROUTINE OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj(basis,faceGaussEvaluate,err)
    !DLLEXPORT(OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The type of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj",err,error,*999)

    CALL Basis_QuadratureLocalFaceGaussEvaluateSet(basis%basis,faceGaussEvaluate,err,error,*999)

    EXITS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj")
    RETURN
999 ERRORS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj",err,error)
    EXITS("OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_QuadratureLocalFaceGaussEvaluateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by a user number.
  SUBROUTINE OC_Basis_TypeGetNumber(contextUserNumber,basisUserNumber,basisType_,err)
    !DLLEXPORT(OC_Basis_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType_ !<On return, the type of the specified basis. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_TypeGet(basis,basisType_,err,error,*999)

    EXITS("OC_Basis_TypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_TypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by an object.
  SUBROUTINE OC_Basis_TypeGetObj(basis,basisType_,err)
    !DLLEXPORT(OC_Basis_TypeGetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType_ !<On return, the type of the specified basis. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_TypeGetObj",err,error,*999)

    CALL Basis_TypeGet(basis%basis,basisType_,err,error,*999)

    EXITS("OC_Basis_TypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_TypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by a user number.
  SUBROUTINE OC_Basis_TypeSetNumber(contextUserNumber,basisUserNumber,basisType_,err)
    !DLLEXPORT(OC_Basis_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the basis function.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType_ !<The type of the specified basis to set. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_Basis_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL Basis_TypeSet(basis,basisType_,err,error,*999)

    EXITS("OC_Basis_TypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Basis_TypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by an object.
  SUBROUTINE OC_Basis_TypeSetObj(basis,basisType_,err)
    !DLLEXPORT(OC_Basis_TypeSetObj)

    !Argument variables
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<The basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType_ !<The type of the specified basis to set. \see OpenCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Basis_TypeSetObj",err,error,*999)

    CALL Basis_TypeSet(basis%basis,basisType_,err,error,*999)

    EXITS("OC_Basis_TypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Basis_TypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_TypeSetObj

  !>@}

!!==================================================================================================================================
!!
!! BoundaryConditionsRoutines
!!
!!==================================================================================================================================

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE OC_BoundaryConditions_DestroyNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,err)
    !DLLEXPORT(OC_BoundaryConditions_DestroyNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_BoundaryConditions_DestroyNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_Destroy(boundaryConditions,err,error,*999)

    EXITS("OC_BoundaryConditions_DestroyNumber0")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_DestroyNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE OC_BoundaryConditions_DestroyNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,err)
    !DLLEXPORT(OC_BoundaryConditions_DestroyNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_BoundaryConditions_DestroyNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_Destroy(boundaryConditions,err,error,*999)

    EXITS("OC_BoundaryConditions_DestroyNumber1")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_DestroyNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_DestroyObj(boundaryConditions,err)
    !DLLEXPORT(OC_BoundaryConditions_DestroyObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_DestroyObj",err,error,*999)

    CALL BoundaryConditions_Destroy(boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("OC_BoundaryConditions_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_DestroyObj

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_AddConstantNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_AddConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the dependent field to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_AddConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_AddConstant(boundaryConditions,dependentField,variableType,componentNumber, &
      & condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_AddConstantNumber")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_AddConstantNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_AddConstantNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_AddConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_AddConstantObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the constant to.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_AddConstantObj",err,error,*999)

    CALL BoundaryConditions_AddConstant(boundaryConditions%boundaryConditions,field%field,variableType,componentNumber, &
      & condition,value,err,error,*999)

    EXITS("OC_BoundaryConditions_AddConstantObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_AddConstantObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_AddConstantObj

  !
  !================================================================================================================================
  !


  !>Sets the value of the specified constant as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_SetConstantNumber(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,regionUserNumber,fieldUserNumber,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetConstantNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_SetConstantNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetConstant(boundaryConditions,dependentField,variableType,componentNumber, &
      & condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_SetConstantNumber")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetConstantNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetConstantNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_SetConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetConstantObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the constant to.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_SetConstantObj",err,error,*999)

    CALL BoundaryConditions_SetConstant(boundaryConditions%boundaryConditions,field%field,variableType,componentNumber, &
      & condition,value,err,error,*999)

    EXITS("OC_BoundaryConditions_SetConstantObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetConstantObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetConstantObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_AddElementNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_AddElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_AddElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_AddElement(boundaryConditions,dependentField,variableType,elementUserNumber, &
      & componentNumber,condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_AddElementNumber")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_AddElementNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_AddElementNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_AddElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_AddElementObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the element to.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_AddElementObj",err,error,*999)

    CALL BoundaryConditions_AddElement(boundaryConditions%boundaryConditions,field%field,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    EXITS("OC_BoundaryConditions_AddElementObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_AddElementObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_AddElementObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_SetElementNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetElementNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_SetElementNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetElement(boundaryConditions,dependentField,variableType,elementUserNumber, &
      & componentNumber,condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_SetElementNumber")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetElementNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetElementNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element and sets this as a boundary condition on the specified elements for boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_SetElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetElementObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the element to.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_SetElementObj",err,error,*999)

    CALL BoundaryConditions_SetElement(boundaryConditions%boundaryConditions,field%field,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    EXITS("OC_BoundaryConditions_SetElementObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetElementObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetElementObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_AddNodeNumber(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition, &
    & value,err)
    !DLLEXPORT(OC_BoundaryConditions_AddNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_AddNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_AddNode(boundaryConditions,dependentField,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_AddNodeNumber")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_AddNodeNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_AddNodeNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_AddNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
    & nodeUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_AddNodeObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the node to.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_AddNodeObj",err,error,*999)

    CALL BoundaryConditions_AddNode(boundaryConditions%boundaryConditions,field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    EXITS("OC_BoundaryConditions_AddNodeObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_AddNodeObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_AddNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_SetNodeNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition, &
    & value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetNodeNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_SetNodeNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_SetNodeNumber0")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetNodeNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetNodeNumber0

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE OC_BoundaryConditions_SetNodeNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition, &
    & value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetNodeNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: dependentField
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_BoundaryConditions_SetNodeNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,dependentField,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_SetNode(boundaryConditions,dependentField,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,VALUE,err,error,*999)

    EXITS("OC_BoundaryConditions_SetNodeNumber1")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetNodeNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetNodeNumber1

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE OC_BoundaryConditions_SetNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
    & nodeUserNumber,componentNumber,condition,value,err)
    !DLLEXPORT(OC_BoundaryConditions_SetNodeObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the node to.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OpenCMISS_BoundaryConditionsTypes,OpenCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_SetNodeObj",err,error,*999)

    CALL BoundaryConditions_SetNode(boundaryConditions%boundaryConditions,field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    EXITS("OC_BoundaryConditions_SetNodeObj")
    RETURN
999 ERRORSEXITS("OC_BoundaryConditions_SetNodeObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_SetNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE OC_BoundaryConditions_NeumannSparsityTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,sparsityType,err)
    !DLLEXPORT(OC_BoundaryConditions_NeumannSparsityTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier of the solver equations containing the boundary conditions.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OpenCMISS_BoundaryConditionSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)

    EXITS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber0")
    RETURN
999 ERRORS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber0",err,error)
    EXITS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_NeumannSparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE OC_BoundaryConditions_NeumannSparsityTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,sparsityType,err)    
    !DLLEXPORT(OC_BoundaryConditions_NeumannSparsityTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OpenCMISS_BoundaryConditionSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)

    EXITS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber1")
    RETURN
999 ERRORS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber1",err,error)
    EXITS("OC_BoundaryConditions_NeumannSparsityTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_NeumannSparsityTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity type for the boundary conditions
  SUBROUTINE OC_BoundaryConditions_NeumannSparsityTypeSetObj(boundaryConditions,sparsityType,err)
    !DLLEXPORT(OC_BoundaryConditions_NeumannSparsityTypeSetObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OpenCMISS_BoundaryConditionSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_BoundaryConditions_NeumannSparsityTypeSetObj",err,error,*999)

    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions%boundaryConditions,sparsityType,err,error,*999)

    EXITS("OC_BoundaryConditions_NeumannSparsityTypeSetObj")
    RETURN
999 ERRORS("OC_BoundaryConditions_NeumannSparsityTypeSetObj",err,error)
    EXITS("OC_BoundaryConditions_NeumannSparsityTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_NeumannSparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE OC_BoundaryConditions_ConstrainNodeDofsEqualNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,regionUserNumber,fieldUserNumber,fieldVarType,versionNumber,derivativeNumber,component,nodes, &
    & coefficient,err)
    !DLLEXPORT(OC_BoundaryConditions_ConstrainNodeDofsEqualNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem/region.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index of the solver equations.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field DOFs to constrain.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field containing the DOFs to contrain.
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The variable type of the dependent field containing the DOFs to constrain. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    REAL(DP), INTENT(IN) :: coefficient !<The coefficient of constraint, applied to all but the first node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_BoundaryConditions_ConstrainNodeDofsEqualNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(field)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions,err,error,*999)
    CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions,field, &
      & fieldVarType,versionNumber,derivativeNumber,component,nodes,coefficient,err,error,*999)

    EXITS("OC_BoundaryConditions_ConstrainNodeDofsEqualNumber")
    RETURN
999 ERRORS("OC_BoundaryConditions_ConstrainNodeDofsEqualNumber",err,error)
    EXITS("OC_BoundaryConditions_ConstrainNodeDofsEqualNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_ConstrainNodeDofsEqualNumber

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE OC_BoundaryConditions_ConstrainNodeDofsEqualObj(boundaryConditions,field,fieldVarType,versionNumber, &
    & derivativeNumber,component,nodes,coefficient,err)
    !DLLEXPORT(OC_BoundaryConditions_ConstrainNodeDofsEqualObj)

    !Argument variables
    TYPE(OC_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to constrain the DOFs in.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The equations dependent field containing the field DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type of the DOFs to be constrained. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    REAL(DP), INTENT(IN) :: coefficient !<The coefficient of constraint, applied to all but the first node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_BoundaryConditions_ConstrainNodeDofsEqualObj",err,error,*999)

    CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions%boundaryConditions,field%field, &
      & fieldVarType,versionNumber,derivativeNumber,component,nodes,coefficient,err,error,*999)

    EXITS("OC_BoundaryConditions_ConstrainNodeDofsEqualObj")
    RETURN
999 ERRORS("OC_BoundaryConditions_ConstrainNodeDofsEqualObj",err,error)
    EXITS("OC_BoundaryConditions_ConstrainNodeDofsEqualObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BoundaryConditions_ConstrainNodeDofsEqualObj

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !>Returns the error handling mode for OpenCMISS
  SUBROUTINE OC_ErrorHandlingModeGet(errorHandlingMode,err)
    !DLLEXPORT(OC_ErrorHandlingModeGet)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: errorHandlingMode !<On return, the error handling mode. \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ErrorHandlingModeGet",err,error,*999)

    CALL OC_ErrorHandlingModeGet_(errorHandlingMode,err,error,*999)

    EXITS("OC_ErrorHandlingModeGet")
    RETURN
999 ERRORSEXITS("OC_ErrorHandlingModeGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ErrorHandlingModeGet

  !
  !================================================================================================================================
  !

  !>Sets the error handling mode for OpenCMISS
  SUBROUTINE OC_ErrorHandlingModeSet(errorHandlingMode,err)
    !DLLEXPORT(OC_ErrorHandlingModeSet)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: errorHandlingMode !<The error handling mode to set. \see OpenCMISS_CMISSErrorHandlingModes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ErrorHandlingModeSet",err,error,*999)

    CALL OC_ErrorHandlingModeSet_(errorHandlingMode,err,error,*999)

    EXITS("OC_ErrorHandlingModeSet")
    RETURN
999 ERRORSEXITS("OC_ErrorHandlingModeSet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ErrorHandlingModeSet

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE OC_ExtractErrorMessageC(errorMessage,err)
    !DLLEXPORT(OC_ExtractErrorMessageC)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorMessage(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE OC_ExtractErrorMessageC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE OC_ExtractErrorMessageVS(errorMessage,err)
    !DLLEXPORT(OC_ExtractErrorMessageVS)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorMessage(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE OC_ExtractErrorMessageVS

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE OC_ExtractErrorStackC(errorStack,err)
    !DLLEXPORT(OC_ExtractErrorStackC)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorStack !<On return, the extracted error stack.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorStack(errorStack,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE OC_ExtractErrorStackC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error stack for OpenCMISS
  SUBROUTINE OC_ExtractErrorStackVS(errorStack,err)
    !DLLEXPORT(OC_ExtractErrorStackVS)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorStack !<On return, the extracted error stack.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorStack(errorStack,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE OC_ExtractErrorStackVS


!!==================================================================================================================================
!!
!! CmissCellML
!!
!!==================================================================================================================================

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE OC_CellML_VariableSetAsKnownNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsKnownNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_VariableSetAsKnownNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)    
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsKnown(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsKnownNumberC")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsKnownNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsKnownNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE OC_CellML_VariableSetAsKnownObjC(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsKnownObjC)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_VariableSetAsKnownObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_VariableSetAsKnown(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsKnownObjC")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsKnownObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsKnownObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE OC_CellML_VariableSetAsKnownNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsKnownNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_VariableSetAsKnownNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsKnown(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsKnownNumberVS")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsKnownNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsKnownNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE OC_CellML_VariableSetAsKnownObjVS(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsKnownObjVS)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_VariableSetAsKnownObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_VariableSetAsKnown(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsKnownObjVS")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsKnownObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsKnownObjVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE OC_CellML_VariableSetAsWantedNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsWantedNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_VariableSetAsWantedNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsWanted(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsWantedNumberC")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsWantedNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsWantedNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE OC_CellML_VariableSetAsWantedObjC(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsWantedObjC)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_VariableSetAsWantedObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_VariableSetAsWanted(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsWantedObjC")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsWantedObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsWantedObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE OC_CellML_VariableSetAsWantedNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsWantedNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_VariableSetAsWantedNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_VariableSetAsWanted(cellml,cellMLModelUserNumber,variableID,err,error,*999)

#endif    

    EXITS("OC_CellML_VariableSetAsWantedNumberVS")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsWantedNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsWantedNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE OC_CellML_VariableSetAsWantedObjVS(CellML,cellMLModelUserNumber,variableID,err)
    !DLLEXPORT(OC_CellML_VariableSetAsWantedObjVS)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_VariableSetAsWantedObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_VariableSetAsWanted(CellML%cellML,cellMLModelUserNumber,variableID,err,error,*999)

#endif

    EXITS("OC_CellML_VariableSetAsWantedObjVS")
    RETURN
999 ERRORSEXITS("OC_CellML_VariableSetAsWantedObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_VariableSetAsWantedObjVS

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE OC_CellML_CreateCellMLToFieldMapNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,cellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateCellMLToFieldMapNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_CreateCellMLToFieldMapNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateCellMLToFieldMap(cellml,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateCellMLToFieldMapNumberC")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateCellMLToFieldMapNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateCellMLToFieldMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by object.
  SUBROUTINE OC_CellML_CreateCellMLToFieldMapObjC(cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateCellMLToFieldMapObjC)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_CreateCellMLToFieldMapObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateCellMLToFieldMap(cellML%cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & field%field,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateCellMLToFieldMapObjC")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateCellMLToFieldMapObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateCellMLToFieldMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE OC_CellML_CreateCellMLToFieldMapNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & variableID,cellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateCellMLToFieldMapNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_CreateCellMLToFieldMapNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateCellMLToFieldMap(cellml,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateCellMLToFieldMapNumberVS")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateCellMLToFieldMapNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateCellMLToFieldMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map, by object.
  SUBROUTINE OC_CellML_CreateCellMLToFieldMapObjVS(cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateCellMLToFieldMapObjVS)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_CreateCellMLToFieldMapObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateCellMLToFieldMap(cellML%cellML,cellMLModelUserNumber,variableID,cellMLParameterSet, &
      & field%field,variableType,componentNumber,fieldParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateCellMLToFieldMapObjVS")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateCellMLToFieldMapObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateCellMLToFieldMapObjVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number.
  SUBROUTINE OC_CellML_CreateFieldToCellMLMapNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,fieldUserNumber, &
    & variableType,componentNumber,fieldParameterSet,cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateFieldToCellMLMapNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_CreateFieldToCellMLMapNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateFieldToCellMLMap(cellml,field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateFieldToCellMLMapNumberC")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateFieldToCellMLMapNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateFieldToCellMLMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by object.
  SUBROUTINE OC_CellML_CreateFieldToCellMLMapObjC(cellML,field,variableType,componentNumber,fieldParameterSet, &
    & cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateFieldToCellMLMapObjC)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to map from the given field variable.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_CreateFieldToCellMLMapObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateFieldToCellMLMap(cellML%cellML,field%field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateFieldToCellMLMapObjC")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateFieldToCellMLMapObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateFieldToCellMLMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number
  SUBROUTINE OC_CellML_CreateFieldToCellMLMapNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,fieldUserNumber, &
    & variableType,fieldParameterSet,componentNumber,cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateFieldToCellMLMapNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_CreateFieldToCellMLMapNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL CellML_CreateFieldToCellMLMap(cellml,field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateFieldToCellMLMapNumberVS")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateFieldToCellMLMapNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateFieldToCellMLMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by by object.
  SUBROUTINE OC_CellML_CreateFieldToCellMLMapObjVS(cellML,field,variableType,componentNumber,fieldParameterSet, &
    & cellMLModelUserNumber,variableID,cellMLParameterSet,err)
    !DLLEXPORT(OC_CellML_CreateFieldToCellMLMapObjVS)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(IN) :: cellML !<The CellML enviroment.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: cellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_CreateFieldToCellMLMapObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateFieldToCellMLMap(cellML%cellML,field%field,variableType,componentNumber,fieldParameterSet, &
      & cellMLModelUserNumber,variableID,cellMLParameterSet,err,error,*999)

#endif

    EXITS("OC_CellML_CreateFieldToCellMLMapObjVS")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateFieldToCellMLMapObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateFieldToCellMLMapObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_CreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_CreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_CreateFinish(cellml,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

#endif

    EXITS("OC_CellML_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a CellML environment identified by an object.
  SUBROUTINE OC_CellML_CreateFinishObj(cellML,err)
    !DLLEXPORT(OC_CellML_CreateFinishObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_CreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_CreateFinish(cellML%cellML,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

#endif

    EXITS("OC_CellML_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_CreateStartNumber(cellMLUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_CellML_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to start creating.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_CreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL CellML_CreateStart(cellMLUserNumber,region,cellml,err,error,*999)

#endif

    EXITS("OC_CellML_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a CellML environment identified by an object.
  SUBROUTINE OC_CellML_CreateStartObj(cellMLUserNumber,region,cellML,err)
    !DLLEXPORT(OC_CellML_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to start creating.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region containing the field to start the CellML enviroment creation on.
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<On return, the created CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_CreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL CellML_CreateStart(cellMLUserNumber,region%region,cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CellML_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_DestroyNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_DestroyNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CELLML_DESTROY(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a CellML environment identified by an object.
  SUBROUTINE OC_CellML_DestroyObj(cellML,err)
    !DLLEXPORT(OC_CellML_DestroyObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_DestroyObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CELLML_DESTROY(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_CellML_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_FieldMapsCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_FieldMapsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_FieldMapsCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldMapsCreateFinish(cellml,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

#endif

    EXITS("OC_CellML_FieldMapsCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldMapsCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldMapsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_FieldMapsCreateFinishObj(cellML,err)
    !DLLEXPORT(OC_CellML_FieldMapsCreateFinishObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_FieldMapsCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldMapsCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_FieldMapsCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldMapsCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldMapsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_FieldMapsCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_FieldMapsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to start creating the maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_FieldMapsCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldMapsCreateStart(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_FieldMapsCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldMapsCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldMapsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_FieldMapsCreateStartObj(cellML,err)
    !DLLEXPORT(OC_CellML_FieldMapsCreateStartObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment object to start the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_FieldMapsCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldMapsCreateStart(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_FieldMapsCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldMapsCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldMapsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ModelImportNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,URI,modelIndex,err)
    !DLLEXPORT(OC_CellML_ModelImportNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ModelImportNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelImport(cellml,URI,modelIndex,err,error,*999)

#else

    modelIndex = -1

#endif

    EXITS("OC_CellML_ModelImportNumberC")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelImportNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelImportNumberC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ModelImportObjC(cellML,URI,modelIndex,err)
    !DLLEXPORT(OC_CellML_ModelImportObjC)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ModelImportObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelImport(cellML%cellML,URI,modelIndex,err,error,*999)

#else

    modelIndex = -1

#endif

    EXITS("OC_CellML_ModelImportObjC")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelImportObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelImportObjC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ModelImportNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,URI,modelIndex,err)
    !DLLEXPORT(OC_CellML_ModelImportNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ModelImportNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML    

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelImport(cellml,URI,modelIndex,err,error,*999)

#else

    modelIndex = -1

#endif

    EXITS("OC_CellML_ModelImportNumberVS")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelImportNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelImportNumberVS

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ModelImportObjVS(cellML,URI,modelIndex,err)
    !DLLEXPORT(OC_CellML_ModelImportObjVS)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ModelImportObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelImport(cellML%cellML,URI,modelIndex,err,error,*999)

#else

    modelIndex = -1
    
#endif

    EXITS("OC_CellML_ModelImportObjVS")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelImportObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelImportObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ModelsFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_ModelsFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ModelsFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelsFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_ModelsFieldCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelsFieldCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelsFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ModelsFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(OC_CellML_ModelsFieldCreateFinishObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ModelsFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelsFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_ModelsFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelsFieldCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelsFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ModelsFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLModelsFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_ModelsFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the models field for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ModelsFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelsFieldCreateStart(cellMLModelsFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("OC_CellML_ModelsFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelsFieldCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelsFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ModelsFieldCreateStartObj(cellML,cellMLModelsFieldUserNumber,field,err)
    !DLLEXPORT(OC_CellML_ModelsFieldCreateStartObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of models field for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the created CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ModelsFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelsFieldCreateStart(cellMLModelsFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_ModelsFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelsFieldCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelsFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ModelsFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelsFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_ModelsFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLModelsFieldUserNumber !<On return, the user number of the CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ModelsFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)   
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ModelsFieldGet(cellml,field,err,error,*999)
    cellMLModelsFieldUserNumber = FIELD%userNumber

#else

    cellMLModelsFieldUserNumber = 0

#endif

    EXITS("OC_CellML_ModelsFieldGetNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelsFieldGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelsFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ModelsFieldGetObj(cellML,field,err)
    !DLLEXPORT(OC_CellML_ModelsFieldGetObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the models field for.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the CellML models field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ModelsFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ModelsFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_ModelsFieldGetObj")
    RETURN
999 ERRORSEXITS("OC_CellML_ModelsFieldGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ModelsFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_StateFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_StateFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_StateFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_StateFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_StateFieldCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_StateFieldCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_StateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_StateFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(OC_CellML_StateFieldCreateFinishObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_StateFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_StateFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_StateFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_CellML_StateFieldCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_StateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_StateFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLStateFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_StateFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the state field for.
    INTEGER(INTG), INTENT(IN) :: cellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_StateFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_StateFieldCreateStart(cellMLStateFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("OC_CellML_StateFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_StateFieldCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_StateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_StateFieldCreateStartObj(cellML,cellMLStateFieldUserNumber,field,err)
    !DLLEXPORT(OC_CellML_StateFieldCreateStartObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of state field for.
    INTEGER(INTG), INTENT(IN) :: cellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the created CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_StateFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_StateFieldCreateStart(cellMLStateFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_StateFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CellML_StateFieldCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_StateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_StateFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLStateFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_StateFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML state field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLStateFieldUserNumber !<On return, the user number of the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_StateFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_StateFieldGet(cellml,field,err,error,*999)
    cellMLStateFieldUserNumber = field%userNumber

#else

    cellMLStateFieldUserNumber = 0

#endif

    EXITS("OC_CellML_StateFieldGetNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_StateFieldGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_StateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_StateFieldGetObj(cellML,field,err)
    !DLLEXPORT(OC_CellML_StateFieldGetObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the state field for.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_StateFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_StateFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_StateFieldGetObj")
    RETURN
999 ERRORSEXITS("OC_CellML_StateFieldGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_StateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string VariableID for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_FieldComponentGetNumberC(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(OC_CellML_FieldComponentGetNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The variable ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_FieldComponentGetNumberC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldComponentGet(cellml,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0

#endif

    EXITS("OC_CellML_FieldComponentGetNumberC")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldComponentGetNumberC",err,error)
    CALL OC_HandleError(err,error)

    RETURN

  END SUBROUTINE OC_CellML_FieldComponentGetNumberC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string variable ID for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_FieldComponentGetObjC(cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(OC_CellML_FieldComponentGetObjC)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_FieldComponentGetObjC",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldComponentGet(cellML%cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0

#endif

    EXITS("OC_CellML_FieldComponentGetObjC")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldComponentGetObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldComponentGetObjC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_FieldComponentGetNumberVS(contextUserNumber,regionUserNumber,cellMLUserNumber,cellMLModelUserNumber, &
    & cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(OC_CellML_FieldComponentGetNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_FieldComponentGetNumberVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_FieldComponentGet(cellml,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0

#endif

    EXITS("OC_CellML_FieldComponentGetNumberVS")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldComponentGetNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldComponentGetNumberVS

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_FieldComponentGetObjVS(cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err)
    !DLLEXPORT(OC_CellML_FieldComponentGetObjVS)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: cellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: cellMLFieldType !<The type of CellML field to get the component for. \see OpenCMISS_CellMLFieldTypes,OpenCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_FieldComponentGetObjVS",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_FieldComponentGet(cellML%cellML,cellMLModelUserNumber,cellMLFieldType,variableID,fieldComponent,err,error,*999)

#else

    fieldComponent=0

#endif

    EXITS("OC_CellML_FieldComponentGetObjVS")
    RETURN
999 ERRORSEXITS("OC_CellML_FieldComponentGetObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_FieldComponentGetObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_IntermediateFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_IntermediateFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_IntermediateFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_IntermediateFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_IntermediateFieldCreateFinishNumber")
    RETURN
999 ERRORS("OC_CellML_IntermediateFieldCreateFinishNumber",err,error)
    EXITS("OC_CellML_IntermediateFieldCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_IntermediateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_IntermediateFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(OC_CellML_IntermediateFieldCreateFinishObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_IntermediateFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_IntermediateFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_IntermediateFieldCreateFinishObj")
    RETURN
999 ERRORS("OC_CellML_IntermediateFieldCreateFinishObj",err,error)
    EXITS("OC_CellML_IntermediateFieldCreateFinishObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_IntermediateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_IntermediateFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLIntermediateFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_IntermediateFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: cellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_IntermediateFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_IntermediateFieldCreateStart(cellMLIntermediateFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("OC_CellML_IntermediateFieldCreateStartNumber")
    RETURN
999 ERRORS("OC_CellML_IntermediateFieldCreateStartNumber",err,error)
    EXITS("OC_CellML_IntermediateFieldCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_IntermediateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_IntermediateFieldCreateStartObj(cellML,cellMLIntermediateFieldUserNumber,field,err)
    !DLLEXPORT(OC_CellML_IntermediateFieldCreateStartObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of intermediate field for.
    INTEGER(INTG), INTENT(IN) :: cellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the created CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_IntermediateFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_IntermediateFieldCreateStart(cellMLIntermediateFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_IntermediateFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CellML_IntermediateFieldCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_IntermediateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_IntermediateFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLIntermediateFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_IntermediateFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLIntermediateFieldUserNumber !<On return, the user number of the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_IntermediateFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_IntermediateFieldGet(cellml,field,err,error,*999)
    cellMLIntermediateFieldUserNumber = field%userNumber

#else

    cellMLIntermediateFieldUserNumber=0

#endif

    EXITS("OC_CellML_IntermediateFieldGetNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_IntermediateFieldGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_IntermediateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_IntermediateFieldGetObj(cellML,field,err)
    !DLLEXPORT(OC_CellML_IntermediateFieldGetObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the intermediate field for.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_IntermediateFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_IntermediateFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_IntermediateFieldGetObj")
    RETURN
999 ERRORSEXITS("OC_CellML_IntermediateFieldGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_IntermediateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ParametersFieldCreateFinishNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_ParametersFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ParametersFieldCreateFinishNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ParametersFieldCreateFinish(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_ParametersFieldCreateFinishNumber")
    RETURN
999 ERRORS("OC_CellML_ParametersFieldCreateFinishNumber",err,error)
    EXITS("OC_CellML_ParametersFieldCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ParametersFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ParametersFieldCreateFinishObj(cellML,err)
    !DLLEXPORT(OC_CellML_ParametersFieldCreateFinishObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to finish the creation of the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ParametersFieldCreateFinishObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ParametersFieldCreateFinish(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_ParametersFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_CellML_ParametersFieldCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ParametersFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ParametersFieldCreateStartNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLParametersFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_ParametersFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to start creating the parameters field for.
    INTEGER(INTG), INTENT(IN) :: cellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ParametersFieldCreateStartNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ParametersFieldCreateStart(cellMLParametersFieldUserNumber,cellml,field,err,error,*999)

#endif

    EXITS("OC_CellML_ParametersFieldCreateStartNumber")
    RETURN
999 ERRORS("OC_CellML_ParametersFieldCreateStartNumber",err,error)
    EXITS("OC_CellML_ParametersFieldCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ParametersFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ParametersFieldCreateStartObj(cellML,cellMLParametersFieldUserNumber,field,err)
    !DLLEXPORT(OC_CellML_ParametersFieldCreateStartObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to start the creation of parameters field for.
    INTEGER(INTG), INTENT(IN) :: cellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the created CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ParametersFieldCreateStartObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ParametersFieldCreateStart(cellMLParametersFieldUserNumber,cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_ParametersFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CellML_ParametersFieldCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ParametersFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_ParametersFieldGetNumber(contextUserNumber,regionUserNumber,cellMLUserNumber, &
    & cellMLParametersFieldUserNumber,err)
    !DLLEXPORT(OC_CellML_ParametersFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to get the CellML parameters field for.
    INTEGER(INTG), INTENT(OUT) :: cellMLParametersFieldUserNumber !<On return, the user number of the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_ParametersFieldGetNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellML_ParametersFieldGet(cellml,field,err,error,*999)
    cellMLParametersFieldUserNumber = field%userNumber

#else

    cellMLParametersFieldUserNumber=0

#endif

    EXITS("OC_CellML_ParametersFieldGetNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_ParametersFieldGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ParametersFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE OC_CellML_ParametersFieldGetObj(cellML,field,err)
    !DLLEXPORT(OC_CellML_ParametersFieldGetObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to get the parameters field for.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_ParametersFieldGetObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CellML_ParametersFieldGet(cellML%cellML,field%field,err,error,*999)

#endif

    EXITS("OC_CellML_ParametersFieldGetObj")
    RETURN
999 ERRORSEXITS("OC_CellML_ParametersFieldGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_ParametersFieldGetObj

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by a user number.
  SUBROUTINE OC_CellML_GenerateNumber(contextUserNumber,regionUserNumber,cellMLUserNumber,err)
    !DLLEXPORT(OC_CellML_GenerateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML enviroment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CellMLType), POINTER :: cellml
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_CellML_GenerateNumber",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CELLML_GENERATE(cellml,err,error,*999)

#endif

    EXITS("OC_CellML_GenerateNumber")
    RETURN
999 ERRORSEXITS("OC_CellML_GenerateNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_GenerateNumber

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by an object.
  SUBROUTINE OC_CellML_GenerateObj(cellML,err)
    !DLLEXPORT(OC_CellML_GenerateObj)

    !Argument variables
    TYPE(OC_CellMLType), INTENT(INOUT) :: cellML !<The CellML environment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellML_GenerateObj",err,error,*999)

    ASSERT_WITH_CELLML()

#ifdef WITH_CELLML

    CALL CELLML_GENERATE(cellML%cellML,err,error,*999)

#endif

    EXITS("OC_CellML_GenerateObj")
    RETURN
999 ERRORSEXITS("OC_CellML_GenerateObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellML_GenerateObj


!!==================================================================================================================================
!!
!! Computation
!!
!!==================================================================================================================================


  !>Returns the number of computation nodes in the world communicator identified by user number.
  SUBROUTINE OC_ComputationEnvironment_NumberOfWorldNodesGetNumber(contextUserNumber,numberOfWorldNodes,err)
    !DLLEXPORT(OC_ComputationEnvironment_NumberOfWorldNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: numberOfWorldNodes !<On return, the number of computation nodes in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_ComputationEnvironment_NumberOfWorldNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_NumberOfWorldNodesGet(computationEnvironment,numberOfWorldNodes,err,error,*999)

    EXITS("OC_ComputationEnvironment_NumberOfWorldNodesGetNumber")
    RETURN
999 ERRORS("OC_ComputationEnvironment_NumberOfWorldNodesGetNumber",err,error)
    EXITS("OC_ComputationEnvironment_NumberOfWorldNodesGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_NumberOfWorldNodesGetNumber

  !  
  !================================================================================================================================
  !

  !>Returns the number of computation nodes in the world communicator identified by object.
  SUBROUTINE OC_ComputationEnvironment_NumberOfWorldNodesGetObj(computationEnvironment,numberOfWorldNodes,err)
    !DLLEXPORT(OC_ComputationEnvironment_NumberOfWorldNodesGetObj)

    !Argument variables
    TYPE(OC_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the number of nodes in the world communicator for.
    INTEGER(INTG), INTENT(OUT) :: numberOfWorldNodes !<On return, the number of computation nodes in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ComputationEnvironment_NumberOfWorldNodesGetObj",err,error,*999)

    CALL ComputationEnvironment_NumberOfWorldNodesGet(computationEnvironment%computationEnvironment,numberOfWorldNodes, &
      & err,error,*999)

    EXITS("OC_ComputationEnvironment_NumberOfWorldNodesGetObj")
    RETURN
999 ERRORS("OC_ComputationEnvironment_NumberOfWorldNodesGetObj",err,error)
    EXITS("OC_ComputationEnvironment_NumberOfWorldNodesGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_NumberOfWorldNodesGetObj

  !  
  !================================================================================================================================
  !

  !>Returns the current world communicator for the computation environment identified by user number.
  SUBROUTINE OC_ComputationEnvironment_WorldCommunicatorGetNumber(contextUserNumber,worldCommunicator,err)
    !DLLEXPORT(OC_ComputationEnvironment_WorldCommunicatorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: worldCommunicator !<On return, the current world communicator.    
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
#ifdef WITH_F08_MPI
    TYPE(MPI_Comm) :: dummyCommunicator
#endif    

    ENTERS("OC_ComputationEnvironment_WorldCommunicatorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
#ifdef WITH_F08_MPI
    CALL ComputationEnvironment_WorldCommunicatorGet(computationEnvironment,dummyCommunicator,err,error,*999)
    worldCommunicator = dummyCommunicator%MPI_VAL
#else    
    CALL ComputationEnvironment_WorldCommunicatorGet(computationEnvironment,worldCommunicator,err,error,*999)
#endif    

    EXITS("OC_ComputationEnvironment_WorldCommunicatorGetNumber")
    RETURN
999 ERRORS("OC_ComputationEnvironment_WorldCommunicatorGetNumber",err,error)
    EXITS("OC_ComputationEnvironment_WorldCommunicatorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_WorldCommunicatorGetNumber

  !  
  !================================================================================================================================
  !

  !>Returns the current world communicator for the computation environment indentified by object.
  SUBROUTINE OC_ComputationEnvironment_WorldCommunicatorGetObj(computationEnvironment,worldCommunicator,err)
    !DLLEXPORT(OC_ComputationEnvironment_WorldCommunicatorGetObj)

    !Argument variables
    TYPE(OC_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the world communicator for.
    INTEGER(INTG), INTENT(OUT) :: worldCommunicator !<On return, the current world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
#ifdef WITH_F08_MPI
    TYPE(MPI_Comm) :: dummyCommunicator
#endif    

    ENTERS("OC_ComputationEnvironment_WorldCommunicatorGetObj",err,error,*999)

#ifdef WITH_F08_MPI
    CALL ComputationEnvironment_WorldCommunicatorGet(computationEnvironment%computationEnvironment,dummyCommunicator, &
      & err,error,*999)
    worldCommunicator = dummyCommunicator%MPI_VAL
#else    
    CALL ComputationEnvironment_WorldCommunicatorGet(computationEnvironment%computationEnvironment,worldCommunicator, &
      & err,error,*999)
#endif    

    EXITS("OC_ComputationEnvironment_WorldCommunicatorGetObj")
    RETURN
999 ERRORS("OC_ComputationEnvironment_WorldCommunicatorGetObj",err,error)
    EXITS("OC_ComputationEnvironment_WorldCommunicatorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_WorldCommunicatorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the computation node number in the world communicator identified by user number.
  SUBROUTINE OC_ComputationEnvironment_WorldNodeNumberGetNumber(contextUserNumber,worldNodeNumber,err)
    !DLLEXPORT(OC_ComputationEnvironment_WorldNodeNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: worldNodeNumber !<On return, the computation node number in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_ComputationEnvironment_WorldNodeNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_WorldNodeNumberGet(computationEnvironment,worldNodeNumber,err,error,*999)

    EXITS("OC_ComputationEnvironment_WorldNodeNumberGetNumber")
    RETURN
999 ERRORS("OC_ComputationEnvironment_WorldNodeNumberGetNumber",err,error)
    EXITS("OC_ComputationEnvironment_WorldNodeNumberGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_WorldNodeNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the computation node number in the world communicator.
  SUBROUTINE OC_ComputationEnvironment_WorldNodeNumberGetObj(computationEnvironment,worldNodeNumber,err)
    !DLLEXPORT(OC_ComputationEnvironment_WorldNodeNumberGetObj)

    !Argument variables
    TYPE(OC_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the node number in the world communicator for.
    INTEGER(INTG), INTENT(OUT) :: worldNodeNumber !<On return, the computation node number in the world communicator.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ComputationEnvironment_WorldNodeNumberGetObj",err,error,*999)

    CALL ComputationEnvironment_WorldNodeNumberGet(computationEnvironment%computationEnvironment,worldNodeNumber, &
      & err,error,*999)

    EXITS("OC_ComputationEnvironment_WorldNodeNumberGetObj")
    RETURN
999 ERRORS("OC_ComputationEnvironment_WorldNodeNumberGetObj",err,error)
    EXITS("OC_ComputationEnvironment_WorldNodeNumberGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_WorldNodeNumberGetObj

  !  
  !================================================================================================================================
  !

  !>Returns the world work group for the computation environment indentified by user number.
  SUBROUTINE OC_ComputationEnvironment_WorldWorkGroupGetNumber(contextUserNumber,worldWorkGroupUserNumber,err)
    !DLLEXPORT(OC_ComputationEnvironment_WorldWorkGroupGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(OUT) :: worldWorkGroupUserNumber !<On return, the world work group user number for the computation environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: worldWorkGroup

    ENTERS("OC_ComputationEnvironment_WorldWorkGroupGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(worldWorkGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL ComputationEnvironment_WorldWorkGroupGet(computationEnvironment,worldWorkGroup,err,error,*999)
    worldWorkGroupUserNumber=worldWorkGroup%userNumber

    EXITS("OC_ComputationEnvironment_WorldWorkGroupGetNumber")
    RETURN
999 ERRORS("OC_ComputationEnvironment_WorldWorkGroupGetNumber",err,error)
    EXITS("OC_ComputationEnvironment_WorldWorkGroupGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_WorldWorkGroupGetNumber

  !  
  !================================================================================================================================
  !

  !>Returns the world work group for the computation environment.
  SUBROUTINE OC_ComputationEnvironment_WorldWorkGroupGetObj(computationEnvironment,worldWorkGroup,err)
    !DLLEXPORT(OC_ComputationEnvironment_WorldWorkGroupGetObj)

    !Argument variables
    TYPE(OC_ComputationEnvironmentType), INTENT(IN) :: computationEnvironment !<The computation environment to get the world work group for.
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: worldWorkGroup !<On return, the world work group for the computation environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ComputationEnvironment_WorldWorkGroupGetObj",err,error,*999)

    CALL ComputationEnvironment_WorldWorkGroupGet(computationEnvironment%computationEnvironment,worldWorkGroup%workGroup, &
      & err,error,*999)

    EXITS("OC_ComputationEnvironment_WorldWorkGroupGetObj")
    RETURN
999 ERRORS("OC_ComputationEnvironment_WorldWorkGroupGetObj",err,error)
    EXITS("OC_ComputationEnvironment_WorldWorkGroupGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ComputationEnvironment_WorldWorkGroupGetObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a computation work group specified by number.
  SUBROUTINE OC_WorkGroup_CreateStartNumber(workGroupUserNumber,contextUserNumber,parentWorkGroupUserNumber,err)
    !DLLEXPORT(OC_WorkGroup_CreateStartNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: parentWorkGroupUserNumber !<The user number of the parent work group to start the creation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: parentWorkGroup,workGroup 

    ENTERS("OC_WorkGroup_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(parentWorkGroup)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,parentWorkGroupUserNumber,parentWorkGroup,err,error,*999)
    CALL WorkGroup_CreateStart(workGroupUserNumber,parentWorkGroup,workGroup,err,error,*999)

    EXITS("OC_WorkGroup_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_CreateStartNumber

  !  
  !================================================================================================================================
  !

  !>Start the creation of a computation work group specified by object under a parent work group
  SUBROUTINE OC_WorkGroup_CreateStartObj(userNumber,parentWorkGroup,workGroup,err)
    !DLLEXPORT(OC_WorkGroup_CreateStartObj)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of computation nodes to create
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: parentWorkGroup !<The parent work group to create the work group under
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<On exit, the created work group. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_CreateStartObj",err,error,*999)

    CALL WorkGroup_CreateStart(userNumber,parentWorkGroup%workGroup,workGroup%workGroup,err,error,*999)

    EXITS("OC_WorkGroup_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a computation work group specified by number.
  SUBROUTINE OC_WorkGroup_CreateFinishNumber(contextUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(OC_WorkGroup_CreateFinishNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_CreateFinish(workGroup,err,error,*999)

    EXITS("OC_WorkGroup_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a computation work group specified by object.
  SUBROUTINE OC_WorkGroup_CreateFinishObj(workGroup,err)
    !DLLEXPORT(OC_WorkGroup_CreateFinishObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_CreateFinishObj",err,error,*999)

    CALL WorkGroup_CreateFinish(workGroup%workGroup,err,error,*999)

    EXITS("OC_WorkGroup_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Destroy a work group specified by number.
  SUBROUTINE OC_WorkGroup_DestroyNumber(contextUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(OC_WorkGroup_DestroyNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_Destroy(workGroup,err,error,*999)

    EXITS("OC_WorkGroup_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a work group specified by object.
  SUBROUTINE OC_WorkGroup_DestroyObj(workGroup,err)
    !DLLEXPORT(OC_WorkGroup_DestroyObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_DestroyObj",err,error,*999)

    CALL WorkGroup_Destroy(workGroup%workGroup,err,error,*999)

    EXITS("OC_WorkGroup_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the group communicator for a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_GroupCommunicatorGetNumber(contextUserNumber,workGroupUserNumber,groupCommunicator,err)
    !DLLEXPORT(OC_WorkGroup_GroupCommunicatorGetNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the group communicator for.
    INTEGER(INTG), INTENT(OUT) :: groupCommunicator !<On return, the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup
#ifdef WITH_F08_MPI
    TYPE(MPI_Comm) :: dummyCommunicator
#endif    

    ENTERS("OC_WorkGroup_GroupCommunicatorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
#ifdef WITH_F08_MPI
    CALL WorkGroup_GroupCommunicatorGet(workGroup,dummyCommunicator,err,error,*999)
    groupCommunicator = dummyCommunicator%MPI_VAL
#else    
    CALL WorkGroup_GroupCommunicatorGet(workGroup,groupCommunicator,err,error,*999)
#endif    

    EXITS("OC_WorkGroup_GroupCommunicatorGetNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_GroupCommunicatorGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_GroupCommunicatorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the group communicator for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_GroupCommunicatorGetObj(workGroup,groupCommunicator,err)
    !DLLEXPORT(OC_WorkGroup_GroupCommunicatorGetObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the group communicator for
    INTEGER(INTG), INTENT(OUT) :: groupCommunicator !<On return, the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
#ifdef WITH_F08_MPI
    TYPE(MPI_Comm) :: dummyCommunicator
#endif    

    ENTERS("OC_WorkGroup_GroupCommunicatorGetObj",err,error,*999)

#ifdef WITH_F08_MPI
    CALL WorkGroup_GroupCommunicatorGet(workGroup%workGroup,dummyCommunicator,err,error,*999)
    groupCommunicator = dummyCommunicator%MPI_VAL
#else    
    CALL WorkGroup_GroupCommunicatorGet(workGroup%workGroup,groupCommunicator,err,error,*999)
#endif    

    EXITS("OC_WorkGroup_GroupCommunicatorGetObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_GroupCommunicatorGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_GroupCommunicatorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the group node number a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_GroupNodeNumberGetNumber(contextUserNumber,workGroupUserNumber,groupNodeNumber,err)
    !DLLEXPORT(OC_WorkGroup_GroupNodeNumberGetNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the group node number for.
    INTEGER(INTG), INTENT(OUT) :: groupNodeNumber !<On return, the node number in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_GroupNodeNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_GroupNodeNumberGet(workGroup,groupNodeNumber,err,error,*999)

    EXITS("OC_WorkGroup_GroupNodeNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_GroupNodeNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_GroupNodeNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the group node number for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_GroupNodeNumberGetObj(workGroup,groupNodeNumber,err)
    !DLLEXPORT(OC_WorkGroup_GroupNodeNumberGetObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the group node number for
    INTEGER(INTG), INTENT(OUT) :: groupNodeNumber !<On return, the node number in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_GroupNodeNumberGetObj",err,error,*999)

    CALL WorkGroup_GroupNodeNumberGet(workGroup%workGroup,groupNodeNumber,err,error,*999)

    EXITS("OC_WorkGroup_GroupNodeNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_GroupNodeNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_GroupNodeNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_LabelGetCNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelGetCNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelGet(workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_LabelGetCObj(workGroup,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelGetCObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the label for
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_LabelGetCObj",err,error,*999)

    CALL WorkGroup_LabelGet(workGroup%workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_LabelGetVSNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelGetVSNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelGet(workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_LabelGetVSObj(workGroup,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelGetVSObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the label for
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_LabelGetVSObj",err,error,*999)

    CALL WorkGroup_LabelGet(workGroup%workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_LabelSetCNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelSetCNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelSet(workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_LabelSetCObj(workGroup,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelSetCObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to set the label for
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_LabelSetCObj",err,error,*999)

    CALL WorkGroup_LabelSet(workGroup%workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_LabelSetVSNumber(contextUserNumber,workGroupUserNumber,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelSetVSNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_LabelSet(workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_LabelSetVSObj(workGroup,label,err)
    !DLLEXPORT(OC_WorkGroup_LabelSetVSObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to set the label for
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_LabelSetVSObj",err,error,*999)

    CALL WorkGroup_LabelSet(workGroup%workGroup,label,err,error,*999)

    EXITS("OC_WorkGroup_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the group number of nodes in a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_NumberOfGroupNodesGetNumber(contextUserNumber,workGroupUserNumber,numberOfGroupNodes,err)
    !DLLEXPORT(OC_WorkGroup_NumberOfGroupNodesGetNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to get the group number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGroupNodes !<On return, the number of nodes in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_NumberOfGroupNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_NumberOfGroupNodesGet(workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("OC_WorkGroup_NumberOfGroupNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_NumberOfGroupNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_NumberOfGroupNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the group number of nodes for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_NumberOfGroupNodesGetObj(workGroup,numberOfGroupNodes,err)
    !DLLEXPORT(OC_WorkGroup_NumberOfGroupNodesGetObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to get the group number of nodes for
    INTEGER(INTG), INTENT(OUT) :: numberOfGroupNodes !<On return, the number of nodes in the group communicator for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_NumberOfGroupNodesGetObj",err,error,*999)

    CALL WorkGroup_NumberOfGroupNodesGet(workGroup%workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("OC_WorkGroup_NumberOfGroupNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_NumberOfGroupNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_NumberOfGroupNodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/Changes the group number of nodes for a work group specified by a user number.
  SUBROUTINE OC_WorkGroup_NumberOfGroupNodesSetNumber(contextUserNumber,workGroupUserNumber,numberOfGroupNodes,err)
    !DLLEXPORT(OC_WorkGroup_NumberOfGroupNodesSetNumber)

    !Argument Variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the computation environment.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set the group number of nodes for.
    INTEGER(INTG), INTENT(IN) :: numberOfGroupNodes !<The number of nodes in the group communicator to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local Variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(WorkGroupType), POINTER :: workGroup 

    ENTERS("OC_WorkGroup_NumberOfGroupNodesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL WorkGroup_NumberOfGroupNodesSet(workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("OC_WorkGroup_NumberOfGroupNodesSetNumber")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_NumberOfGroupNodesSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_NumberOfGroupNodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/Changes the group number of nodes for a work group specified by an object.
  SUBROUTINE OC_WorkGroup_NumberOfGroupNodesSetObj(workGroup,numberOfGroupNodes,err)
    !DLLEXPORT(OC_WorkGroup_NumberOfGroupNodesSetObj)

    !Argument Variables
    TYPE(OC_WorkGroupType), INTENT(INOUT) :: workGroup !<The work group to set the group number of nodes for
    INTEGER(INTG), INTENT(IN) :: numberOfGroupNodes !<The number of nodes in the group communicator to set for the work group.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("OC_WorkGroup_NumberOfGroupNodesSetObj",err,error,*999)

    CALL WorkGroup_NumberOfGroupNodesSet(workGroup%workGroup,numberOfGroupNodes,err,error,*999)

    EXITS("OC_WorkGroup_NumberOfGroupNodesSetObj")
    RETURN
999 ERRORSEXITS("OC_WorkGroup_NumberOfGroupNodesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_WorkGroup_NumberOfGroupNodesSetObj

!!==================================================================================================================================
!!
!! ContextRoutines
!!
!!==================================================================================================================================


  !>Creates a new context object specified by user numbr
  SUBROUTINE OC_Context_CreateNumber(newContextUserNumber,err)
    !DLLEXPORT(OC_Context_CreateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: newContextUserNumber !<The context user number to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: newContext

    ENTERS("OC_Context_CreateNumber",err,error,*999)

    NULLIFY(newContext)
    CALL Context_Create(newContextUserNumber,newContext,err,error,*999)

    EXITS("OC_Context_CreateNumber")
    RETURN
999 ERRORSEXITS("OC_Context_CreateNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_CreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a new context object.
  SUBROUTINE OC_Context_CreateObj(newContextUserNumber,newContext,err)
    !DLLEXPORT(OC_Context_CreateObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: newContextUserNumber !<The context user number to create.
    TYPE(OC_ContextType), INTENT(INOUT) :: newContext !<The context object to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_CreateObj",err,error,*999)

    CALL Context_Create(newContextUserNumber,newContext%context,err,error,*999)

    EXITS("OC_Context_CreateObj")
    RETURN
999 ERRORSEXITS("OC_Context_CreateObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_CreateObj

  !
  !================================================================================================================================
  !

  !>Destroys a context specified by user number
  SUBROUTINE OC_Context_DestroyNumber(contextUserNumber,err)
    !DLLEXPORT(OC_Context_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_DestroyNumber",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_Destroy(context,err,error,*999)

    EXITS("OC_Context_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Context_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a context specfied by a pointer to an object
  SUBROUTINE OC_Context_DestroyObj(context,err)
    !DLLEXPORT(OC_Context_DestroyObj)

    !Argument variables
    TYPE(OC_ContextType), INTENT(INOUT) :: context !<The context object to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_DestroyObj",err,error,*999)

    IF(ASSOCIATED(context%context)) CALL Context_Destroy(context%context,err,error,*999)

    EXITS("OC_Context_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Context_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the computation environment for an OpenCMISS context given by user number.
  SUBROUTINE OC_Context_ComputationEnvironmentGetNumber(contextUserNumber,computationEnvironment,err)
    !DLLEXPORT(OC_Context_ComputationEnvironmentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The OpenCMISS context user number to get the computation environment for.
    TYPE(OC_ComputationEnvironmentType), INTENT(INOUT) :: computationEnvironment !<On return, the computation environment for the OpenCMISS context.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_ComputationEnvironmentGetNumber",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment%computationEnvironment,err,error,*999)

    EXITS("OC_Context_ComputationEnvironmentGetNumber")
    RETURN
999 ERRORS("OC_Context_ComputationEnvironmentGetNumber",err,error)
    EXITS("OC_Context_ComputationEnvironmentGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_ComputationEnvironmentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a computation environment object for an OpenCMISS context object.
  SUBROUTINE OC_Context_ComputationEnvironmentGetObj(context,computationEnvironment,err)
    !DLLEXPORT(OC_Context_ComputationEnvironmentGetObj)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The OpenCMISS context to get the computation environment for
    TYPE(OC_ComputationEnvironmentType), INTENT(INOUT) :: computationEnvironment !<On return, the computation environment for the context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_ComputationEnvironmentGetObj",err,error,*999)

    CALL Context_ComputationEnvironmentGet(context%context,computationEnvironment%computationEnvironment,err,error,*999)

    EXITS("OC_Context_ComputationEnvironmentGetObj")
    RETURN
999 ERRORSEXITS("OC_Context_ComputationEnvironmentGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_ComputationEnvironmentGetObj

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by user number.
  SUBROUTINE OC_Context_RandomSeedsGetNumber0(contextUserNumber,randomSeed,err)
    !DLLEXPORT(OC_Context_RandomSeedsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: randomSeeds(1)
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_RandomSeedsGetNumber0",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RandomSeedsGet(context,randomSeeds,err,error,*999)
    randomSeed=randomSeeds(1)

    EXITS("OC_Context_RandomSeedsGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by user number.
  SUBROUTINE OC_Context_RandomSeedsGetNumber1(contextUserNumber,randomSeeds,err)
    !DLLEXPORT(OC_Context_RandomSeedsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_RandomSeedsGetNumber1",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RandomSeedsGet(context,randomSeeds,err,error,*999)

    EXITS("OC_Context_RandomSeedsGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE OC_Context_RandomSeedsGetObj0(context,randomSeed,err)
    !DLLEXPORT(OC_Context_RandomSeedsGetObj0)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: randomSeeds(1)

    ENTERS("OC_Context_RandomSeedsGetObj0",err,error,*999)

    CALL Context_RandomSeedsGet(context%context,randomSeeds,err,error,*999)
    randomSeed=randomSeeds(1)

    EXITS("OC_Context_RandomSeedsGetObj0")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE OC_Context_RandomSeedsGetObj1(context,randomSeeds,err)
    !DLLEXPORT(OC_Context_RandomSeedsGetObj1)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to get the random seeds for.
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_RandomSeedsGetObj1",err,error,*999)

    CALL Context_RandomSeedsGet(context%context,randomSeeds,err,error,*999)

    EXITS("OC_Context_RandomSeedsGetObj1")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsGetObj1

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for an OpenCMISS context specified by user number
  SUBROUTINE OC_Context_RandomSeedsSizeGetNumber(contextUserNumber,randomSeedsSize,err)
    !DLLEXPORT(OC_Context_RandomSeedsSizeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to get the random seeds size for.
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_RandomSeedsSizeGetNumber",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)     
    CALL Context_RandomSeedsSizeGet(context,randomSeedsSize,err,error,*999)

    EXITS("OC_Context_RandomSeedsSizeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsSizeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for an OpenCMISS context specified by object
  SUBROUTINE OC_Context_RandomSeedsSizeGetObj(context,randomSeedsSize,err)
    !DLLEXPORT(OC_Context_RandomSeedsSizeGetObj)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to get the random seeds size for.
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_RandomSeedsSizeGetObj",err,error,*999)

    CALL Context_RandomSeedsSizeGet(context%context,randomSeedsSize,err,error,*999)

    EXITS("OC_Context_RandomSeedsSizeGetObj")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsSizeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsSizeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by user number.
  SUBROUTINE OC_Context_RandomSeedsSetNumber0(contextUserNumber,randomSeed,err)
    !DLLEXPORT(OC_Context_RandomSeedsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_RandomSeedsSetNumber0",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)     
    CALL Context_RandomSeedsSet(context,[randomSeed],err,error,*999)

    EXITS("OC_Context_RandomSeedsSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by user number
  SUBROUTINE OC_Context_RandomSeedsSetNumber1(contextUserNumber,randomSeeds,err)
    !DLLEXPORT(OC_Context_RandomSeedsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_Context_RandomSeedsSetNumber1",err,error,*999)

    NULLIFY(context)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)     
    CALL Context_RandomSeedsSet(context,randomSeeds,err,error,*999)

    EXITS("OC_Context_RandomSeedsSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE OC_Context_RandomSeedsSetObj0(context,randomSeed,err)
    !DLLEXPORT(OC_Context_RandomSeedsSetObj0)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_RandomSeedsSetObj0",err,error,*999)

    CALL Context_RandomSeedsSet(context%context,[randomSeed],err,error,*999)

    EXITS("OC_Context_RandomSeedsSetObj0")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for an OpenCMISS context specified by object.
  SUBROUTINE OC_Context_RandomSeedsSetObj1(context,randomSeeds,err)
    !DLLEXPORT(OC_Context_RandomSeedsSetObj1)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to set the random seeds for.
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_RandomSeedsSetObj1",err,error,*999)

    CALL Context_RandomSeedsSet(context%context,randomSeeds,err,error,*999)

    EXITS("OC_Context_RandomSeedsSetObj1")
    RETURN
999 ERRORSEXITS("OC_Context_RandomSeedsSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_RandomSeedsSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the world region user number for an OpenCMISS context given by user number.
  SUBROUTINE OC_Context_WorldRegionGetNumber(contextUserNumber,worldRegionUserNumber,err)
    !DLLEXPORT(OC_Context_WorldRegionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The OpenCMISS context user number to get the world region for.
    INTEGER(INTG), INTENT(OUT) :: worldRegionUserNumber !<On return, the world region user number for the OpenCMISS context.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: worldRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Context_WorldRegionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(worldRegion)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Regions_WorldRegionGet(regions,worldRegion,err,error,*999)
    CALL Region_UserNumberGet(worldRegion,worldRegionUserNumber,err,error,*999)

    EXITS("OC_Context_WorldRegionGetNumber")
    RETURN
999 ERRORSEXITS("OC_Context_WorldRegionGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_WorldRegionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a world region object for an OpenCMISS context object.
  SUBROUTINE OC_Context_WorldRegionGetObj(context,worldRegion,err)
    !DLLEXPORT(OC_Context_WorldRegionGetObj)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The OpenCMISS context to get the world region for
    TYPE(OC_RegionType), INTENT(INOUT) :: worldRegion !<On return, the world region for the context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Context_WorldRegionGetObj",err,error,*999)

    NULLIFY(regions)
    CALL Context_RegionsGet(context%context,regions,err,error,*999)
    CALL Regions_WorldRegionGet(regions,worldRegion%region,err,error,*999)

    EXITS("OC_Context_WorldRegionGetObj")
    RETURN
999 ERRORSEXITS("OC_Context_WorldRegionGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_WorldRegionGetObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for an OpenCMISS context object.
  SUBROUTINE OC_Context_UserNumberGet(context,contextUserNumber,err)
    !DLLEXPORT(OC_Context_UserNumberGet)

    !Argument variables
    TYPE(OC_ContextType), INTENT(IN) :: context !<The OpenCMISS context to get the user number for
    INTEGER(INTG), INTENT(OUT) :: contextUserNumber !<On return, the user number for the context
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Context_UserNumberGet",err,error,*999)

    CALL Context_UserNumberGet(context%context,contextUserNumber,err,error,*999)

    EXITS("OC_Context_UserNumberGet")
    RETURN
999 ERRORSEXITS("OC_Context_UserNumberGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Context_UserNumberGet


!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !>Gets the continue loop status for a while control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_ContinueLoopGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,continueLoop,err)
    !DLLEXPORT(OC_ControlLoop_ContinueLoopGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    LOGICAL, INTENT(OUT) :: continueLoop !<On return, the continue loop status of the while control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_ContinueLoopGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_ContinueLoopGet(controlLoop,continueLoop,err,error,*999)

    EXITS("OC_ControlLoop_ContinueLoopGetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ContinueLoopGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ContinueLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the continue loop status for a while control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_ContinueLoopGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,continueLoop,err)
    !DLLEXPORT(OC_ControlLoop_ContinueLoopGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    LOGICAL, INTENT(OUT) :: continueLoop !<On return, the continue loop status of the while control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_ContinueLoopGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_ContinueLoopGet(controlLoop,continueLoop,err,error,*999)

    EXITS("OC_ControlLoop_ContinueLoopGetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ContinueLoopGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ContinueLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the continue loop status for a while control loop identified by an object.
  SUBROUTINE OC_ControlLoop_ContinueLoopGetObj(controlLoop,continueLoop,err)
    !DLLEXPORT(OC_ControlLoop_ContinueLoopGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the continue loop status for
    LOGICAL, INTENT(OUT) :: continueLoop !<On return, the continue loop status of the while control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_ContinueLoopGetObj",err,error,*999)

    CALL ControlLoop_ContinueLoopGet(controlLoop%controlLoop,continueLoop,err,error,*999)

    EXITS("OC_ControlLoop_ContinueLoopGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ContinueLoopGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ContinueLoopGetObj

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_CurrentTimesGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,currentTime, &
    & timeIncrement,err)
    !DLLEXPORT(OC_ControlLoop_CurrentTimesGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_CurrentTimesGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("OC_ControlLoop_CurrentTimesGetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_CurrentTimesGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_CurrentTimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_CurrentTimesGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,currentTime, &
    & timeIncrement,err)
    !DLLEXPORT(OC_ControlLoop_CurrentTimesGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_CurrentTimesGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimesGet(controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("OC_ControlLoop_CurrentTimesGetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_CurrentTimesGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_CurrentTimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_CurrentTimesGetObj(controlLoop,currentTime,timeIncrement,err)
    !DLLEXPORT(OC_ControlLoop_CurrentTimesGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the current times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_CurrentTimesGetObj",err,error,*999)

    CALL ControlLoop_CurrentTimesGet(controlLoop%controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("OC_ControlLoop_CurrentTimesGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_CurrentTimesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_CurrentTimesGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_DestroyNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,err)
    !DLLEXPORT(OC_ControlLoop_DestroyNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_DestroyNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_Destroy(controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_DestroyNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_DestroyNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_DestroyNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,err)
    !DLLEXPORT(OC_ControlLoop_DestroyNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_DestroyNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_Destroy(controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_DestroyNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_DestroyNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_DestroyObj(controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_DestroyObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_DestroyObj",err,error,*999)

    CALL ControlLoop_Destroy(controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE OC_ControlLoop_ControlLoopGetNumber00(contextUserNumber,problemUserNumber,controlLoopRootIdentifier, &
    & controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_ControlLoopGetNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_ControlLoopGetNumber00",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifier,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_ControlLoopGetNumber00")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ControlLoopGetNumber00",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ControlLoopGetNumber00

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE OC_ControlLoop_ControlLoopGetNumber10(contextUserNumber,problemUserNumber,controlLoopRootIdentifiers, &
    & controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_ControlLoopGetNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_ControlLoopGetNumber10",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifiers,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_ControlLoopGetNumber10")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ControlLoopGetNumber10",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ControlLoopGetNumber10

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE OC_ControlLoop_ControlLoopGetNumber01(contextUserNumber,problemUserNumber,controlLoopRootIdentifier, &
    & controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_ControlLoopGetNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_ControlLoopGetNumber01",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifier,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_ControlLoopGetNumber01")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ControlLoopGetNumber01",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ControlLoopGetNumber01

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE OC_ControlLoop_ControlLoopGetNumber11(contextUserNumber,problemUserNumber,controlLoopRootIdentifiers, &
    & controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_ControlLoopGetNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: rootControlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_ControlLoopGetNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(rootControlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopRootIdentifiers,rootControlLoop,err,error,*999)
    CALL ControlLoop_Get(rootControlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_ControlLoopGetNumber11")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ControlLoopGetNumber11",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ControlLoopGetNumber11

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  SUBROUTINE OC_ControlLoop_ControlLoopGetObj0(controlLoopRoot,controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_ControlLoopGetObj0)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_ControlLoopGetObj0",err,error,*999)

    CALL ControlLoop_Get(controlLoopRoot%controlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_ControlLoopGetObj0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ControlLoopGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifiers from the control loop root.
  SUBROUTINE OC_ControlLoop_ControlLoopGetObj1(controlLoopRoot,controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(OC_ControlLoop_ControlLoopGetObj1)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(INOUT) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_ControlLoopGetObj1",err,error,*999)

    CALL ControlLoop_Get(controlLoopRoot%controlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_ControlLoop_ControlLoopGetObj1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_ControlLoopGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a fixed control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_FixedInputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,inputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_FixedInputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_FixedInputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_FixedOutputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_FixedInputSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_FixedInputSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_FixedInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a fixed control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_FixedInputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,inputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_FixedInputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_FixedInputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_FixedInputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_FixedInputSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_FixedInputSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_FixedInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a fixed control loop identified by an object.
  SUBROUTINE OC_ControlLoop_FixedInputSetObj(controlLoop,inputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_FixedInputSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the input frequency for.
    INTEGER(INTG), INTENT(IN) ::  inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_FixedInputSetObj",err,error,*999)

    CALL ControlLoop_FixedInputSet(controlLoop%controlLoop,inputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_FixedInputSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_FixedInputSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_FixedInputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a fixed control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_FixedOutputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_FixedOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_FixedOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_FixedOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_FixedOutputSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_FixedOutputSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_FixedOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a fixed control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_FixedOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_FixedOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_FixedOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_FixedOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_FixedOutputSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_FixedOutputSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_FixedOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a fixed control loop identified by an object.
  SUBROUTINE OC_ControlLoop_FixedOutputSetObj(controlLoop,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_FixedOutputSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_FixedOutputSetObj",err,error,*999)

    CALL ControlLoop_FixedOutputSet(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_FixedOutputSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_FixedOutputSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_FixedOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_IterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,startIteration, &
    & stopIteration,iterationIncrement,err)
    !DLLEXPORT(OC_ControlLoop_IterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_IterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_IterationsSet(controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("OC_ControlLoop_IterationsSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_IterationsSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_IterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_IterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,startIteration, &
    & stopIteration,iterationIncrement,err)
    !DLLEXPORT(OC_ControlLoop_IterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_IterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_IterationsSet(controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("OC_ControlLoop_IterationsSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_IterationsSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_IterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by an object.
  SUBROUTINE OC_ControlLoop_IterationsSetObj(controlLoop,startIteration,stopIteration,iterationIncrement,err)
    !DLLEXPORT(OC_ControlLoop_IterationsSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_IterationsSetObj",err,error,*999)

    CALL ControlLoop_IterationsSet(controlLoop%controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("OC_ControlLoop_IterationsSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_IterationsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_IterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the iteration number for control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_IterationNumberGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & iterationNumber,err)
    !DLLEXPORT(OC_ControlLoop_IterationNumberGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the iteration number for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: iterationNumber !<On exit, the iteration number of the control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_IterationNumberGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_IterationNumberGet(controlLoop,iterationNumber,err,error,*999)

    EXITS("OC_ControlLoop_IterationNumberGetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_IterationNumberGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_IterationNumberGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the iteration number for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_IterationNumberGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & iterationNumber,err)
    !DLLEXPORT(OC_ControlLoop_IterationNumberGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the iteration number for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: iterationNumber !<On return, the iteration number of the control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_IterationNumberGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_IterationNumberGet(controlLoop,iterationNumber,err,error,*999)

    EXITS("OC_ControlLoop_IterationNumberGetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_IterationNumberGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_IterationNumberGetNumber1

  !================================================================================================================================
  !

  !>Returns the iteration number for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_IterationNumberGetObj(controlLoop,iterationNumber,err)
    !DLLEXPORT(OC_ControlLoop_IterationNumberGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to get the iteration number for.
    INTEGER(INTG), INTENT(OUT) :: iterationNumber !<On return, the iteration number for the control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_IterationNumberGetObj",err,error,*999)

    CALL ControlLoop_IterationNumberGet(controlLoop%controlLoop,iterationNumber,err,error,*999)

    EXITS("OC_ControlLoop_IterationNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_IterationNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_IterationNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelGetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelGetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelGetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelGetCNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelGetCNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelGetCNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelGetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelGetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelGetCNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelGetCNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_LabelGetCObj(controlLoop,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelGetCObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_LabelGetCObj",err,error,*999)

    CALL ControlLoop_LabelGet(controlLoop%controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelGetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelGetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelGetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelGetVSNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelGetVSNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelGetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelGetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelGetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelGet(controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelGetVSNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelGetVSNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_LabelGetVSObj(controlLoop,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelGetVSObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_LabelGetVSObj",err,error,*999)

    CALL ControlLoop_LabelGet(controlLoop%controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelSetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelSetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelSetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelSetCNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelSetCNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelSetCNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelSetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelSetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelSetCNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelSetCNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_LabelSetCObj(controlLoop,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelSetCObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_LabelSetCObj",err,error,*999)

    CALL ControlLoop_LabelSet(controlLoop%controlLoop,label,err,error,*999)

    EXITS("OC_ControlLoop_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelSetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelSetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelSetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,CHAR(label),err,error,*999)

    EXITS("OC_ControlLoop_LabelSetVSNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelSetVSNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE OC_ControlLoop_LabelSetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelSetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_LabelSetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_LabelSet(controlLoop,CHAR(label),err,error,*999)

    EXITS("OC_ControlLoop_LabelSetVSNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelSetVSNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_LabelSetVSObj(controlLoop,label,err)
    !DLLEXPORT(OC_ControlLoop_LabelSetVSObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_LabelSetVSObj",err,error,*999)

    CALL ControlLoop_LabelSet(controlLoop%controlLoop,CHAR(label),err,error,*999)

    EXITS("OC_ControlLoop_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_MaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & maximumIterations,err)
    !DLLEXPORT(OC_ControlLoop_MaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_MaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_MaximumIterationsSet(controlLoop,maximumIterations,err,error,*999)

    EXITS("OC_ControlLoop_MaximumIterationsSetNumber0")
    RETURN
999 ERRORS("OC_ControlLoop_MaximumIterationsSetNumber0",err,error)
    EXITS("OC_ControlLoop_MaximumIterationsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_MaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_MaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & maximumIterations,err)
    !DLLEXPORT(OC_ControlLoop_MaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_MaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_MaximumIterationsSet(controlLoop,maximumIterations,err,error,*999)

    EXITS("OC_ControlLoop_MaximumIterationsSetNumber1")
    RETURN
999 ERRORS("OC_ControlLoop_MaximumIterationsSetNumber1",err,error)
    EXITS("OC_ControlLoop_MaximumIterationsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_MaximumIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE OC_ControlLoop_MaximumIterationsSetObj(controlLoop,maximumIterations,err)
    !DLLEXPORT(OC_ControlLoop_MaximumIterationsSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_MaximumIterationsSetObj",err,error,*999)

    CALL ControlLoop_MaximumIterationsSet(controlLoop%controlLoop,maximumIterations,err,error,*999)

    EXITS("OC_ControlLoop_MaximumIterationsSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_MaximumIterationsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_MaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a load control loop identified by an object.
  SUBROUTINE OC_ControlLoop_LoadOutputSet(controlLoop,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_LoadOutputSet)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_LoadOutputSet",err,error,*999)

    CALL ControlLoop_LoadOutputSet(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_LoadOutputSet")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_LoadOutputSet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_LoadOutputSet

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_AbsoluteToleranceGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & absoluteTolerance,err)
    !DLLEXPORT(OC_ControlLoop_AbsoluteToleranceGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On return, the absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_AbsoluteToleranceGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceGet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("OC_ControlLoop_AbsoluteToleranceGetNumber0")
    RETURN
999 ERRORS("OC_ControlLoop_AbsoluteToleranceGetNumber0",err,error)
    EXITS("OC_ControlLoop_AbsoluteToleranceGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_AbsoluteToleranceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_AbsoluteToleranceGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & absoluteTolerance,err)
    !DLLEXPORT(OC_ControlLoop_AbsoluteToleranceGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On return, the absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_AbsoluteToleranceGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceGet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("OC_ControlLoop_AbsoluteToleranceGetNumber1")
    RETURN
999 ERRORS("OC_ControlLoop_AbsoluteToleranceGetNumber1",err,error)
    EXITS("OC_ControlLoop_AbsoluteToleranceGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_AbsoluteToleranceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_AbsoluteToleranceGetObj(controlLoop,absoluteTolerance,err)
    !DLLEXPORT(OC_ControlLoop_AbsoluteToleranceGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to get the absolute tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On return, the absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_AbsoluteToleranceGetObj",err,error,*999)

    CALL ControlLoop_AbsoluteToleranceGet(controlLoop%controlLoop,absoluteTolerance,err,error,*999)

    EXITS("OC_ControlLoop_AbsoluteToleranceGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_AbsoluteToleranceGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_AbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_AbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & absoluteTolerance,err)
    !DLLEXPORT(OC_ControlLoop_AbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_AbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceSet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("OC_ControlLoop_AbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("OC_ControlLoop_AbsoluteToleranceSetNumber0",err,error)
    EXITS("OC_ControlLoop_AbsoluteToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_AbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_AbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & absoluteTolerance,err)
    !DLLEXPORT(OC_ControlLoop_AbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_AbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_AbsoluteToleranceSet(controlLoop,absoluteTolerance,err,error,*999)

    EXITS("OC_ControlLoop_AbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("OC_ControlLoop_AbsoluteToleranceSetNumber1",err,error)
    EXITS("OC_ControlLoop_AbsoluteToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_AbsoluteToleranceSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_AbsoluteToleranceSetObj(controlLoop,absoluteTolerance,err)
    !DLLEXPORT(OC_ControlLoop_AbsoluteToleranceSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_AbsoluteToleranceSetObj",err,error,*999)

    CALL ControlLoop_AbsoluteToleranceSet(controlLoop%controlLoop,absoluteTolerance,err,error,*999)

    EXITS("OC_ControlLoop_AbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_AbsoluteToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Gets the number of iterations for a time control loop identified by user number.
  SUBROUTINE OC_ControlLoop_NumberOfIterationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfIterations,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfIterationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfIterations !<The number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfIterationsGetNumber0",err,error,*999) 

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsGet(controlLoop,numberOfIterations,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfIterationsGetNumber0")
    RETURN
999 ERRORS("OC_ControlLoop_NumberOfIterationsGetNumber0",err,error)
    EXITS("OC_ControlLoop_NumberOfIterationsGetNumber0") 
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfIterationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the number of iterations for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_NumberOfIterationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfIterations,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfIterationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: numberOfIterations !<The number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfIterationsGetNumber1",err,error,*999) 

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsGet(controlLoop,numberOfIterations,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfIterationsGetNumber1")  
    RETURN
999 ERRORS("OC_ControlLoop_NumberOfIterationsGetNumber1",err,error)   
    EXITS("OC_ControlLoop_NumberOfIterationsGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfIterationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the number of iterations for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_NumberOfIterationsGetObj(controlLoop,numberOfIterations,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfIterationsGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: numberOfIterations !<The number of iterations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_NumberOfIterationsGetObj",err,error,*999)

    CALL ControlLoop_NumberOfIterationsGet(controlLoop%controlLoop,numberOfIterations,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfIterationsGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfIterationsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfIterationsGetObj

  !
  !================================================================================================================================
  !

  !>Sets the number of iterations for a time control loop identified by user number.
  SUBROUTINE OC_ControlLoop_NumberOfIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfIterations,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfIterations !<The number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsSet(controlLoop,numberOfIterations,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfIterationsSetNumber0") 
    RETURN
999 ERRORS("OC_ControlLoop_NumberOfIterationsSetNumber0",err,error) 
    EXITS("OC_ControlLoop_NumberOfIterationsSetNumber0")  
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the number of iterations for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_NumberOfIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfIterations,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: numberOfIterations !<The number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfIterationsSetNumber1",err,error,*999) 

    NULLIFY(context)
    NULLIFY(problems)    
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfIterationsSet(controlLoop,numberOfIterations,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfIterationsSetNumber1") 
    RETURN
999 ERRORS("OC_ControlLoop_NumberOfIterationsSetNumber1",err,error)
    EXITS("OC_ControlLoop_NumberOfIterationsSetNumber1")   
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the number of iterations for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_NumberOfIterationsSetObj(controlLoop,numberOfIterations,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfIterationsSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the number of iterations for.
    INTEGER(INTG), INTENT(IN) :: numberOfIterations !<The number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_NumberOfIterationsSetObj",err,error,*999)

    CALL ControlLoop_NumberOfIterationsSet(controlLoop%controlLoop,numberOfIterations,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfIterationsSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfIterationsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_NumberOfSubLoopsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfSubLoops,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfSubLoopsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfSubLoopsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsGet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfSubLoopsGetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfSubLoopsGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfSubLoopsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_NumberOfSubLoopsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfSubLoops,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfSubLoopsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfSubLoopsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsGet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfSubLoopsGetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfSubLoopsGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfSubLoopsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_NumberOfSubLoopsGetObj(controlLoop,numberOfSubLoops,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfSubLoopsGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of sub loops for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_NumberOfSubLoopsGetObj",err,error,*999)

    CALL ControlLoop_NumberOfSubLoopsGet(controlLoop%controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfSubLoopsGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfSubLoopsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfSubLoopsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE OC_ControlLoop_NumberOfSubLoopsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & numberOfSubLoops,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfSubLoopsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfSubLoopsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsSet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfSubLoopsSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfSubLoopsSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfSubLoopsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE OC_ControlLoop_NumberOfSubLoopsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & numberOfSubLoops,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfSubLoopsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_NumberOfSubLoopsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_NumberOfSubLoopsSet(controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfSubLoopsSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfSubLoopsSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfSubLoopsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by an object. \todo is this really public???
  SUBROUTINE OC_ControlLoop_NumberOfSubLoopsSetObj(controlLoop,numberOfSubLoops,err)
    !DLLEXPORT(OC_ControlLoop_NumberOfSubLoopsSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_NumberOfSubLoopsSetObj",err,error,*999)

    CALL ControlLoop_NumberOfSubLoopsSet(controlLoop%controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("OC_ControlLoop_NumberOfSubLoopsSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_NumberOfSubLoopsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_NumberOfSubLoopsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_OutputTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputType,err)
    !DLLEXPORT(OC_ControlLoop_OutputTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_OutputTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeGet(controlLoop,outputType,err,error,*999)

    EXITS("OC_ControlLoop_OutputTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_OutputTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_OutputTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_OutputTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputType,err)
    !DLLEXPORT(OC_ControlLoop_OutputTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_OutputTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeGet(controlLoop,outputType,err,error,*999)

    EXITS("OC_ControlLoop_OutputTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_OutputTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_OutputTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_OutputTypeGetObj(controlLoop,outputType,err)
    !DLLEXPORT(OC_ControlLoop_OutputTypeGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_OutputTypeGetObj",err,error,*999)

    CALL ControlLoop_OutputTypeGet(controlLoop%controlLoop,outputType,err,error,*999)

    EXITS("OC_ControlLoop_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_OutputTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_OutputTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputType,err)
    !DLLEXPORT(OC_ControlLoop_OutputTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeSet(controlLoop,outputType,err,error,*999)

    EXITS("OC_ControlLoop_OutputTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_OutputTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_OutputTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputType,err)
    !DLLEXPORT(OC_ControlLoop_OutputTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_OutputTypeSet(controlLoop,outputType,err,error,*999)

    EXITS("OC_ControlLoop_OutputTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_OutputTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_OutputTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_OutputTypeSetObj(controlLoop,outputType,err)
    !DLLEXPORT(OC_ControlLoop_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OpenCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_OutputTypeSetObj",err,error,*999)

    CALL ControlLoop_OutputTypeSet(controlLoop%controlLoop,outputType,err,error,*999)

    EXITS("OC_ControlLoop_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_RelativeToleranceGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & relativeTolerance,err)
    !DLLEXPORT(OC_ControlLoop_RelativeToleranceGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On return, the relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_RelativeToleranceGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceGet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("OC_ControlLoop_RelativeToleranceGetNumber0")
    RETURN
999 ERRORS("OC_ControlLoop_RelativeToleranceGetNumber0",err,error)
    EXITS("OC_ControlLoop_RelativeToleranceGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_RelativeToleranceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_RelativeToleranceGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & relativeTolerance,err)
    !DLLEXPORT(OC_ControlLoop_RelativeToleranceGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On return, the relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_RelativeToleranceGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceGet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("OC_ControlLoop_RelativeToleranceGetNumber1")
    RETURN
999 ERRORS("OC_ControlLoop_RelativeToleranceGetNumber1",err,error)
    EXITS("OC_ControlLoop_RelativeToleranceGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_RelativeToleranceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_RelativeToleranceGetObj(controlLoop,relativeTolerance,err)
    !DLLEXPORT(OC_ControlLoop_RelativeToleranceGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to get the relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On return, the relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_RelativeToleranceGetObj",err,error,*999)

    CALL ControlLoop_RelativeToleranceGet(controlLoop%controlLoop,relativeTolerance,err,error,*999)

    EXITS("OC_ControlLoop_RelativeToleranceGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_RelativeToleranceGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_RelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_RelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & relativeTolerance,err)
    !DLLEXPORT(OC_ControlLoop_RelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_RelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceSet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("OC_ControlLoop_RelativeToleranceSetNumber0")
    RETURN
999 ERRORS("OC_ControlLoop_RelativeToleranceSetNumber0",err,error)
    EXITS("OC_ControlLoop_RelativeToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_RelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_RelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & relativeTolerance,err)
    !DLLEXPORT(OC_ControlLoop_RelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_RelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_RelativeToleranceSet(controlLoop,relativeTolerance,err,error,*999)

    EXITS("OC_ControlLoop_RelativeToleranceSetNumber1")
    RETURN
999 ERRORS("OC_ControlLoop_RelativeToleranceSetNumber1",err,error)
    EXITS("OC_ControlLoop_RelativeToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_RelativeToleranceSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a control loop identified by an object.
  SUBROUTINE OC_ControlLoop_RelativeToleranceSetObj(controlLoop,relativeTolerance,err)
    !DLLEXPORT(OC_ControlLoop_RelativeToleranceSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_RelativeToleranceSetObj",err,error,*999)

    CALL ControlLoop_RelativeToleranceSet(controlLoop%controlLoop,relativeTolerance,err,error,*999)

    EXITS("OC_ControlLoop_RelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_RelativeToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_RelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimeOutputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_TimeOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimeOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TimeOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_TimeOutputSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimeOutputSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimeOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimeOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_TimeOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimeOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TimeOutputSet(controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_TimeOutputSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimeOutputSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimeOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_TimeOutputSetObj(controlLoop,outputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_TimeOutputSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_TimeOutputSetObj",err,error,*999)

    CALL ControlLoop_TimeOutputSet(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_TimeOutputSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimeOutputSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimeOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimeInputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,inputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_TimeInputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimeInputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TimeInputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_TimeInputSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimeInputSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimeInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimeInputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,inputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_TimeInputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the input frequency for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimeInputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TimeInputSet(controlLoop,inputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_TimeInputSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimeInputSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimeInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input frequency for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_TimeInputSetObj(controlLoop,inputFrequency,err)
    !DLLEXPORT(OC_ControlLoop_TimeInputSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the input frequency for.
    INTEGER(INTG), INTENT(IN) ::  inputFrequency !<The input frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_TimeInputSetObj",err,error,*999)

    CALL ControlLoop_TimeInputSet(controlLoop%controlLoop,inputFrequency,err,error,*999)

    EXITS("OC_ControlLoop_TimeInputSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimeInputSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimeInputSetObj

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimesGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,startTime,stopTime, &
    & timeIncrement,currentTime,currentLoopIteration,outputIterationNumber,inputIterationNumber,err)
    !DLLEXPORT(OC_ControlLoop_TimesGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the output iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: inputIterationNumber !<On return, the inputer iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimesGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimeInformationGet(controlLoop,startTime,stopTime,currentTime,timeIncrement, &
      & currentLoopIteration,outputIterationNumber,inputIterationNumber,err,error,*999)

    EXITS("OC_ControlLoop_TimesGetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimesGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimesGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,startTime,stopTime, &
    & timeIncrement,currentTime,currentLoopIteration,outputIterationNumber,inputIterationNumber,err)
    !DLLEXPORT(OC_ControlLoop_TimesGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the output iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: inputIterationNumber !<On return, the inputer iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimesGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_CurrentTimeInformationGet(controlLoop,startTime,stopTime,currentTime,timeIncrement, &
      & currentLoopIteration,outputIterationNumber,inputIterationNumber,err,error,*999)

    EXITS("OC_ControlLoop_TimesGetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimesGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_TimesGetObj(controlLoop,startTime,stopTime,timeIncrement,currentTime, &
    & currentLoopIteration,outputIterationNumber,inputIterationNumber,err)
    !DLLEXPORT(OC_ControlLoop_TimesGetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the times for.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the output iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: inputIterationNumber !<On return, the inputer iteration frequency for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_TimesGetObj",err,error,*999)

    CALL ControlLoop_CurrentTimeInformationGet(controlLoop%controlLoop,startTime,stopTime,currentTime,timeIncrement, &
      & currentLoopIteration,outputIterationNumber,inputIterationNumber,err,error,*999)

    EXITS("OC_ControlLoop_TimesGetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimesSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,startTime,stopTime, &
    & timeIncrement,err)
    !DLLEXPORT(OC_ControlLoop_TimesSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimesSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TimesSet(controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("OC_ControlLoop_TimesSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimesSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE OC_ControlLoop_TimesSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,startTime,stopTime, &
    & timeIncrement,err)
    !DLLEXPORT(OC_ControlLoop_TimesSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TimesSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TimesSet(controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("OC_ControlLoop_TimesSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimesSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by an object.
  SUBROUTINE OC_ControlLoop_TimesSetObj(controlLoop,startTime,stopTime,timeIncrement,err)
    !DLLEXPORT(OC_ControlLoop_TimesSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_TimesSetObj",err,error,*999)

    CALL ControlLoop_TimesSet(controlLoop%controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("OC_ControlLoop_TimesSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TimesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE OC_ControlLoop_TypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,loopType,err)
    !DLLEXPORT(OC_ControlLoop_TypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OpenCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop,err,error,*999)
    CALL ControlLoop_TypeSet(controlLoop,loopType,err,error,*999)

    EXITS("OC_ControlLoop_TypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE OC_ControlLoop_TypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,loopType,err)
    !DLLEXPORT(OC_ControlLoop_TypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OpenCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ControlLoopType), POINTER :: controlLoop
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_ControlLoop_TypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(controlLoop)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop,err,error,*999)
    CALL ControlLoop_TypeSet(controlLoop,loopType,err,error,*999)

    EXITS("OC_ControlLoop_TypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by an object. \todo is this really public???
  SUBROUTINE OC_ControlLoop_TypeSetObj(controlLoop,loopType,err)
    !DLLEXPORT(OC_ControlLoop_TypeSetObj)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OpenCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_ControlLoop_TypeSetObj",err,error,*999)

    CALL ControlLoop_TypeSet(controlLoop%controlLoop,loopType,err,error,*999)

    EXITS("OC_ControlLoop_TypeSetObj")
    RETURN
999 ERRORSEXITS("OC_ControlLoop_TypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_ControlLoop_TypeSetObj

!!==================================================================================================================================
!!
!! CoordinateRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_CreateFinishNumber(contextUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(OC_CoordinateSystem_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_CreateFinish(coordinateSystem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    EXITS("OC_CoordinateSystem_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_CreateFinishObj(coordinateSystem,err)
    !DLLEXPORT(OC_CoordinateSystem_CreateFinishObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_CreateFinishObj",err,error,*999)

    CALL CoordinateSystem_CreateFinish(coordinateSystem%coordinateSystem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    EXITS("OC_CoordinateSystem_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_CreateStartNumber(coordinateSystemUserNumber,contextUserNumber,err)
    !DLLEXPORT(OC_CoordinateSystem_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_CreateStart(coordinateSystemUserNumber,coordinateSystems,coordinateSystem,err,error,*999)

    EXITS("OC_CoordinateSystem_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_CreateStartObj(coordinateSystemUserNumber,context,coordinateSystem,err)
    !DLLEXPORT(OC_CoordinateSystem_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context to create the coordinate system for. 
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the coordinate system that has been created.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(coordinateSystems)
    CALL Context_CoordinateSystemsGet(context%context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_CreateStart(coordinateSystemUserNumber,coordinateSystems,coordinateSystem%coordinateSystem, &
      & err,error,*999)

    EXITS("OC_CoordinateSystem_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_DestroyNumber(contextUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(OC_CoordinateSystem_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_Destroy(coordinateSystem,err,error,*999)

    EXITS("OC_CoordinateSystem_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_DestroyObj(coordinateSystem,err)
    !DLLEXPORT(OC_CoordinateSystem_DestroyObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_DestroyObj",err,error,*999)

    CALL CoordinateSystem_Destroy(coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("OC_CoordinateSystem_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_DimensionGetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemDimension,err)
    !DLLEXPORT(OC_CoordinateSystem_DimensionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_DimensionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionGet(coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("OC_CoordinateSystem_DimensionGetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_DimensionGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_DimensionGetObj(coordinateSystem,coordinateSystemDimension,err)
    !DLLEXPORT(OC_CoordinateSystem_DimensionGetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_DimensionGetObj",err,error,*999)

    CALL CoordinateSystem_DimensionGet(coordinateSystem%coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("OC_CoordinateSystem_DimensionGetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_DimensionGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_DimensionSetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemDimension,err)
    !DLLEXPORT(OC_CoordinateSystem_DimensionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_DimensionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_DimensionSet(coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("OC_CoordinateSystem_DimensionSetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_DimensionSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_DimensionSetObj(coordinateSystem,coordinateSystemDimension,err)
    !DLLEXPORT(OC_CoordinateSystem_DimensionSetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_DimensionSetObj",err,error,*999)

    CALL CoordinateSystem_DimensionSet(coordinateSystem%coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("OC_CoordinateSystem_DimensionSetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_DimensionSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_FocusGetNumber(contextUserNumber,coordinateSystemUserNumber,focus,err)
    !DLLEXPORT(OC_CoordinateSystem_FocusGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_FocusGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_FocusGet(coordinateSystem,focus,err,error,*999)

    EXITS("OC_CoordinateSystem_FocusGetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_FocusGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_FocusGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_FocusGetObj(coordinateSystem,focus,err)
    !DLLEXPORT(OC_CoordinateSystem_FocusGetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_FocusGetObj",err,error,*999)

    CALL CoordinateSystem_FocusGet(coordinateSystem%coordinateSystem,focus,err,error,*999)

    EXITS("OC_CoordinateSystem_FocusGetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_FocusGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_FocusGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_FocusSetNumber(contextUserNumber,coordinateSystemUserNumber,focus,err)
    !DLLEXPORT(OC_CoordinateSystem_FocusSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_FocusSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_FocusSet(coordinateSystem,focus,err,error,*999)

    EXITS("OC_CoordinateSystem_FocusSetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_FocusSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_FocusSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_FocusSetObj(coordinateSystem,focus,err)
    !DLLEXPORT(OC_CoordinateSystem_FocusSetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_FocusSetObj",err,error,*999)

    CALL CoordinateSystem_FocusSet(coordinateSystem%coordinateSystem,focus,err,error,*999)

    EXITS("OC_CoordinateSystem_FocusSetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_FocusSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_FocusSetObj

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_RadialInterpolationGetNumber(contextUserNumber,coordinateSystemUserNumber, &
    & radialInterpolationType,err)
    !DLLEXPORT(OC_CoordinateSystem_RadialInterpolationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the radial interpolation for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system \see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_RadialInterpolationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_RadialInterpolationTypeGet(coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("OC_CoordinateSystem_RadialInterpolationGetNumber")
    RETURN
999 ERRORS("OC_CoordinateSystem_RadialInterpolationGetNumber",err,error)
    EXITS("OC_CoordinateSystem_RadialInterpolationGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_RadialInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_RadialInterpolationGetObj(coordinateSystem,radialInterpolationType,err)
    !DLLEXPORT(OC_CoordinateSystem_RadialInterpolationGetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to get the radial interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system. \see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_RadialInterpolationGetObj",err,error,*999)

    CALL CoordinateSystem_RadialInterpolationTypeGet(coordinateSystem%coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("OC_CoordinateSystem_RadialInterpolationGetObj")
    RETURN
999 ERRORS("OC_CoordinateSystem_RadialInterpolationGetObj",err,error)
    EXITS("OC_CoordinateSystem_RadialInterpolationGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_RadialInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_RadialInterpolationSetNumber(contextUserNumber,coordinateSystemUserNumber, &
    & radialInterpolationType,err)
    !DLLEXPORT(OC_CoordinateSystem_RadialInterpolationSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the radial interpolation for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set.\see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_RadialInterpolationSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_RadialInterpolationTypeSet(coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("OC_CoordinateSystem_RadialInterpolationSetNumber")
    RETURN
999 ERRORS("OC_CoordinateSystem_RadialInterpolationSetNumber",err,error)
    EXITS("OC_CoordinateSystem_RadialInterpolationSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_RadialInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_RadialInterpolationSetObj(coordinateSystem,radialInterpolationType,err)
    !DLLEXPORT(OC_CoordinateSystem_RadialInterpolationSetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the radial interpolation type for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set. \see OpenCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_RadialInterpolationSetObj",err,error,*999)

    CALL CoordinateSystem_RadialInterpolationTypeSet(coordinateSystem%coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("OC_CoordinateSystem_RadialInterpolationSetObj")
    RETURN
999 ERRORS("OC_CoordinateSystem_RadialInterpolationSetObj",err,error)
    EXITS("OC_CoordinateSystem_RadialInterpolationSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_RadialInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_TypeGetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemType_,err)
    !DLLEXPORT(OC_CoordinateSystem_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType_ !<On return, the type of the coordinate system. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_TypeGet(coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("OC_CoordinateSystem_TypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_TypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_TypeGetObj(coordinateSystem,coordinateSystemType_,err)
    !DLLEXPORT(OC_CoordinateSystem_TypeGetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType_ !<On return, the type of the coordinate system. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_TypeGetObj",err,error,*999)

    CALL CoordinateSystem_TypeGet(coordinateSystem%coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("OC_CoordinateSystem_TypeGetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_TypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_TypeSetNumber(contextUserNumber,coordinateSystemUserNumber,coordinateSystemType_,err)
    !DLLEXPORT(OC_CoordinateSystem_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType_ !<The type of the coordinate system to set. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_TypeSet(coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("OC_CoordinateSystem_TypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_TypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_TypeSetObj(coordinateSystem,coordinateSystemType_,err)
    !DLLEXPORT(OC_CoordinateSystem_TypeSetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType_ !<The type of the coordinate system to set. \see OpenCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_TypeSetObj",err,error,*999)

    CALL CoordinateSystem_TypeSet(coordinateSystem%coordinateSystem,coordinateSystemType_,err,error,*999)

    EXITS("OC_CoordinateSystem_TypeSetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_TypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_OriginGetNumber(contextUserNumber,coordinateSystemUserNumber,origin,err)
    !DLLEXPORT(OC_CoordinateSystem_OriginGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(coordinateIdx). On return, the orign of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_OriginGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OriginGet(coordinateSystem,origin,err,error,*999)

    EXITS("OC_CoordinateSystem_OriginGetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OriginGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_OriginGetObj(coordinateSystem,origin,err)
    !DLLEXPORT(OC_CoordinateSystem_OriginGetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(coordinateIdx). On return, the origin of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_OriginGetObj",err,error,*999)

    CALL CoordinateSystem_OriginGet(coordinateSystem%coordinateSystem,origin,err,error,*999)

    EXITS("OC_CoordinateSystem_OriginGetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OriginGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_OriginSetNumber(contextUserNumber,coordinateSystemUserNumber,origin,err)
    !DLLEXPORT(OC_CoordinateSystem_OriginSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The orign of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_OriginSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OriginSet(coordinateSystem,origin,err,error,*999)

    EXITS("OC_CoordinateSystem_OriginSetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OriginSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_OriginSetObj(coordinateSystem,origin,err)
    !DLLEXPORT(OC_CoordinateSystem_OriginSetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The origin of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_OriginSetObj",err,error,*999)

    CALL CoordinateSystem_OriginSet(coordinateSystem%coordinateSystem,origin,err,error,*999)

    EXITS("OC_CoordinateSystem_OriginSetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OriginSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_OrientationGetNumber(contextUserNumber,coordinateSystemUserNumber,orientation,err)
    !DLLEXPORT(OC_CoordinateSystem_OrientationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_OrientationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OrientationGet(coordinateSystem,orientation,err,error,*999)

    EXITS("OC_CoordinateSystem_OrientationGetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OrientationGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OrientationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_OrientationGetObj(coordinateSystem,orientation,err)
    !DLLEXPORT(OC_CoordinateSystem_OrientationGetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_OrientationGetObj",err,error,*999)

    CALL CoordinateSystem_OrientationGet(coordinateSystem%coordinateSystem,orientation,err,error,*999)

    EXITS("OC_CoordinateSystem_OrientationGetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OrientationGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OrientationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by a user number.
  SUBROUTINE OC_CoordinateSystem_OrientationSetNumber(contextUserNumber,coordinateSystemUserNumber,orientation,err)
    !DLLEXPORT(OC_CoordinateSystem_OrientationSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the coordinate system.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_CoordinateSystem_OrientationSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL CoordinateSystem_OrientationSet(coordinateSystem,orientation,err,error,*999)

    EXITS("OC_CoordinateSystem_OrientationSetNumber")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OrientationSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OrientationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by an object.
  SUBROUTINE OC_CoordinateSystem_OrientationSetObj(coordinateSystem,orientation,err)
    !DLLEXPORT(OC_CoordinateSystem_OrientationSetObj)

    !Argument variables
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CoordinateSystem_OrientationSetObj",err,error,*999)

    CALL CoordinateSystem_OrientationSet(coordinateSystem%coordinateSystem,orientation,err,error,*999)

    EXITS("OC_CoordinateSystem_OrientationSetObj")
    RETURN
999 ERRORSEXITS("OC_CoordinateSystem_OrientationSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CoordinateSystem_OrientationSetObj

!!==================================================================================================================================
!!
!! DataPointsRoutines
!!
!!==================================================================================================================================

  !>Finishes the process of creating data points in a region for data points identified by user number.
  SUBROUTINE OC_DataPoints_CreateFinishNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,err)
    !DLLEXPORT(OC_DataPoints_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_CreateFinish(dataPoints,err,error,*999)

    EXITS("OC_DataPoints_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a data points in a region for data points identified by an object.
  SUBROUTINE OC_DataPoints_CreateFinishObj(dataPoints,err)
    !DLLEXPORT(OC_DataPoints_CreateFinishObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_CreateFinishObj",err,error,*999)

    CALL DataPoints_CreateFinish(dataPoints%dataPoints,err,error,*999)

    EXITS("OC_DataPoints_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating data points in a region for data points identified by user number.
  SUBROUTINE OC_DataPoints_CreateStartNumber(dataPointsUserNumber,contextUserNumber,regionUserNumber,numberOfDataPoints,err)
    !DLLEXPORT(OC_DataPoints_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to create in the region.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL DataPoints_CreateStart(dataPointsUserNumber,region,numberOfDataPoints,dataPoints,err,error,*999)

    EXITS("OC_DataPoints_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE OC_DataPoints_CreateStartObj(dataPointsUserNumber,region,numberOfDataPoints,dataPoints,err)
    !DLLEXPORT(OC_DataPoints_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to create in the region.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(OC_DataPointsType), INTENT(INOUT) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_CreateStartObj",err,error,*999)

    CALL DataPoints_CreateStart(dataPointsUserNumber,region%region,numberOfDataPoints,dataPoints%dataPoints,err,error,*999)

    EXITS("OC_DataPoints_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE OC_DataPoints_CreateStartInterfaceObj(dataPointsUserNumber,interface,numberOfDataPoints,dataPoints,err)
    !DLLEXPORT(OC_DataPoints_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to create in the interface.
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('dataPoints Create')
#endif

    CALL DataPoints_CreateStart(dataPointsUserNumber,interface%interface,numberOfDataPoints,dataPoints%dataPoints,err,error,*999)

    EXITS("OC_DataPoints_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_CreateStartInterfaceObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_CreateStartInterfaceObj


  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by user number.
  SUBROUTINE OC_DataPoints_DestroyNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,err)
    !DLLEXPORT(OC_DataPoints_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to destroy.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_Destroy(dataPoints,err,error,*999)

    EXITS("OC_DataPoints_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by an object.
  SUBROUTINE OC_DataPoints_DestroyObj(dataPoints,err)
    !DLLEXPORT(OC_DataPoints_DestroyObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_DestroyObj",err,error,*999)

    CALL DataPoints_Destroy(dataPoints%dataPoints,err,error,*999)

    EXITS("OC_DataPoints_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE OC_DataPoints_NumberOfDataPointsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & numberOfDataPoints,err)
    !DLLEXPORT(OC_DataPoints_NumberOfDataPointsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get data point count for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<On return, the number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_NumberOfDataPointsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_NumberOfDataPointsGet(dataPoints,numberOfDataPoints,err,error,*999)

    EXITS("OC_DataPoints_NumberOfDataPointsGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_NumberOfDataPointsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_NumberOfDataPointsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE OC_DataPoints_NumberOfDataPointsGetObj(dataPoints,numberOfDataPoints,err)
    !DLLEXPORT(OC_DataPoints_NumberOfDataPointsGetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_NumberOfDataPointsGetObj",err,error,*999)

    CALL DataPoints_NumberOfDataPointsGet(dataPoints%dataPoints,numberOfDataPoints,err,error,*999)

    EXITS("OC_DataPoints_NumberOfDataPointsGetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_NumberOfDataPointsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_NumberOfDataPointsGetObj


  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_LabelGetCNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE OC_DataPoints_LabelGetCObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelGetCObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_LabelGetCObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_LabelGetVSNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE OC_DataPoints_LabelGetVSObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelGetVSObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_LabelGetVSObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelGet(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_LabelSetCNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE OC_DataPoints_LabelSetCObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelSetCObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_LabelSetCObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints%dataPoints,dataPointUserNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_LabelSetVSNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by an object and user number.
  SUBROUTINE OC_DataPoints_LabelSetVSObj(dataPoints,dataPointUserNumber,label,err)
    !DLLEXPORT(OC_DataPoints_LabelSetVSObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_LabelSetVSObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataLabelSet(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("OC_DataPoints_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_UserNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointGlobalNumber, &
    & dataPointUserNumber,err)
    !DLLEXPORT(OC_DataPoints_UserNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_UserNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("OC_DataPoints_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_UserNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataPoints_UserNumberGetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)
    !DLLEXPORT(OC_DataPoints_UserNumberGetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_UserNumberGetObj",err,error,*999)

    CALL DataPoints_DataUserNumberGet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("OC_DataPoints_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_UserNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_UserNumberSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointGlobalNumber, &
    & dataPointUserNumber,err)
    !DLLEXPORT(OC_DataPoints_UserNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_UserNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataUserNumberSet(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("OC_DataPoints_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_UserNumberSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataPoints_UserNumberSetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)
    !DLLEXPORT(OC_DataPoints_UserNumberSetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataPoints_UserNumberSetObj",err,error,*999)

    CALL DataPoints_DataUserNumberSet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("OC_DataPoints_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_UserNumberSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the position for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_PositionGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointPosition,err)
    !DLLEXPORT(OC_DataPoints_PositionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the data point position for.
    REAL(DP), INTENT(OUT) :: dataPointPosition(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_PositionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionGet(dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("OC_DataPoints_PositionGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_PositionGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_PositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the position for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataPoints_PositionGetObj(dataPoints,dataPointUserNumber,dataPointPosition,err)
    !DLLEXPORT(OC_DataPoints_PositionGetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get the data point position for.
    REAL(DP), INTENT(OUT) :: dataPointPosition(:) !<On return, the position for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_PositionGetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionGet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("OC_DataPoints_PositionGetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_PositionGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_PositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the position for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_PositionSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointPosition,err)
    !DLLEXPORT(OC_DataPoints_PositionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the data point position for.
    REAL(DP), INTENT(IN) :: dataPointPosition(:) !<The position for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_PositionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionSet(dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("OC_DataPoints_PositionSetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_PositionSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_PositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the position for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataPoints_PositionSetObj(dataPoints,dataPointUserNumber,dataPointPosition,err)
    !DLLEXPORT(OC_DataPoints_PositionSetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to set the data point position for.
    REAL(DP), INTENT(IN) :: dataPointPosition(:) !<The position for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_PositionSetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataPositionSet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointPosition,err,error,*999)

    EXITS("OC_DataPoints_PositionSetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_PositionSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_PositionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_WeightsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointWeights,err)
    !DLLEXPORT(OC_DataPoints_WeightsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get the data point weights for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_WeightsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataWeightsGet(dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("OC_DataPoints_WeightsGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_WeightsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_WeightsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataPoints_WeightsGetObj(dataPoints,dataPointUserNumber,dataPointWeights,err)
    !DLLEXPORT(OC_DataPoints_WeightsGetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get the data point weights for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_WeightsGetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataWeightsGet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("OC_DataPoints_WeightsGetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_WeightsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_WeightsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataPoints_WeightsSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataPointUserNumber, &
    & dataPointWeights,err)
    !DLLEXPORT(OC_DataPoints_WeightsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points in the region.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set the data point weights for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataPoints_WeightsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_WeightsSet(dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("OC_DataPoints_WeightsSetNumber")
    RETURN
999 ERRORSEXITS("OC_DataPoints_WeightsSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_WeightsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataPoints_WeightsSetObj(dataPoints,dataPointUserNumber,dataPointWeights,err)
    !DLLEXPORT(OC_DataPoints_WeightsSetObj)

    !Argument variables
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set the data point weightsfor.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber

    ENTERS("OC_DataPoints_WeightsSetObj",err,error,*999)

    CALL DataPoints_GlobalNumberGet(dataPoints%dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_WeightsSet(dataPoints%dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("OC_DataPoints_WeightsSetObj")
    RETURN
999 ERRORSEXITS("OC_DataPoints_WeightsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataPoints_WeightsSetObj

!!==================================================================================================================================
!!
!! DataProjectionRoutines
!!
!!==================================================================================================================================

  !>Returns the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_AbsoluteToleranceGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,absoluteTolerance,err)
    !DLLEXPORT(OC_DataProjection_AbsoluteToleranceGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_AbsoluteToleranceGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_AbsoluteToleranceGet(dataProjection,absoluteTolerance,err,error,*999)

    EXITS("OC_DataProjection_AbsoluteToleranceGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_AbsoluteToleranceGetNumber",err,error)
    EXITS("OC_DataProjection_AbsoluteToleranceGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_AbsoluteToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance of data projection identified an object.
  SUBROUTINE OC_DataProjection_AbsoluteToleranceGetObj(dataProjection,absoluteTolerance,err)
    !DLLEXPORT(OC_DataProjection_AbsoluteToleranceGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_AbsoluteToleranceGetObj",err,error,*999)

    CALL DataProjection_AbsoluteToleranceGet(dataProjection%dataProjection,absoluteTolerance,err,error,*999)

    EXITS("OC_DataProjection_AbsoluteToleranceGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_AbsoluteToleranceGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_AbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_AbsoluteToleranceSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,absoluteTolerance,err)
    !DLLEXPORT(OC_DataProjection_AbsoluteToleranceSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_AbsoluteToleranceSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_AbsoluteToleranceSet(dataProjection,absoluteTolerance,err,error,*999)

    EXITS("OC_DataProjection_AbsoluteToleranceSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_AbsoluteToleranceSetNumber",err,error)
    EXITS("OC_DataProjection_AbsoluteToleranceSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_AbsoluteToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified an object.
  SUBROUTINE OC_DataProjection_AbsoluteToleranceSetObj(dataProjection,absoluteTolerance,err)
    !DLLEXPORT(OC_DataProjection_AbsoluteToleranceSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_AbsoluteToleranceSetObj",err,error,*999)

    CALL DataProjection_AbsoluteToleranceSet(dataProjection%dataProjection,absoluteTolerance,err,error,*999)

    EXITS("OC_DataProjection_AbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_AbsoluteToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_CreateFinishNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,err)
    !DLLEXPORT(OC_DataProjection_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points which associates to the data projection to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_CreateFinish(dataProjection,err,error,*999)

    EXITS("OC_DataProjection_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by an object.
  SUBROUTINE OC_DataProjection_CreateFinishObj(dataProjection,err)
    !DLLEXPORT(OC_DataProjection_CreateFinishObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_DataProjection_CreateFinishObj",err,error,*999)

    CALL DataProjection_CreateFinish(dataProjection%dataProjection,err,error,*999)

    EXITS("OC_DataProjection_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_CreateStartNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionFieldUserNumber,projectionFieldVariableType,err)
    !DLLEXPORT(OC_DataProjection_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data points to be projected.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    INTEGER(INTG), INTENT(IN) :: projectionFieldUserNumber !<The user number of the field for the data projection
    INTEGER(INTG), INTENT(IN) :: projectionFieldVariableType !<The variable type of the projection field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FieldType), POINTER :: projectionField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(projectionField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL Region_FieldGet(region,projectionFieldUserNumber,projectionField,err,error,*999)
    CALL DataProjection_CreateStart(dataProjectionUserNumber,dataPoints,projectionField,projectionFieldVariableType, &
      & dataProjection,err,error,*999)

    EXITS("OC_DataProjection_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by an object.
  SUBROUTINE OC_DataProjection_CreateStartObj(dataProjectionUserNumber,dataPoints,projectionField,projectionVariableType, &
    & dataProjection,err)
    !DLLEXPORT(OC_DataProjection_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints !<The data points to be projected
    TYPE(OC_FieldType), INTENT(IN) :: projectionField !<The field where the data points are projected.
    INTEGER(INTG), INTENT(IN) :: projectionVariableType !<The variable type of the field where the data points are projected.
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<On exit, the newly created data projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_CreateStartObj",err,error,*999)

    CALL DataProjection_CreateStart(dataProjectionUserNumber,dataPoints%dataPoints,projectionField%field,projectionVariableType, &
      & dataProjection%dataProjection,err,error,*999)

    EXITS("OC_DataProjection_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by region user number.
  SUBROUTINE OC_DataProjection_DestroyNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber,dataProjectionUserNumber,err)
    !DLLEXPORT(OC_DataProjection_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to destroy.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_Destroy(dataProjection,err,error,*999)

    EXITS("OC_DataProjection_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by an object.
  SUBROUTINE OC_DataProjection_DestroyObj(dataProjection,err)
    !DLLEXPORT(OC_DataProjection_DestroyObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_DestroyObj",err,error,*999)

    CALL DataProjection_Destroy(dataProjection%dataProjection,err,error,*999)

    EXITS("OC_DataProjection_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DestroyObj

  !
  !================================================================================================================================
  !

  !>Evaluate the data point in a field based on data projection in a region, identified by user number
  SUBROUTINE OC_DataProjection_DataPointFieldEvaluateRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,fieldUserNumber,fieldVarType,fieldParameterSetType,dataPointUserNumber,fieldResult,err)
    !DLLEXPORT(OC_DataProjection_DataPointFieldEvaluateRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to evaluate the field at
    REAL(DP), INTENT(OUT) :: fieldResult(:) !<On return, the values of the field evaluated at the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_DataPointFieldEvaluateRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(dataPoints)
    NULLIFY(fieldVariable)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL Field_VariableGet(field,fieldVarType,fieldVariable,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DataPointFieldVariableEvaluate(dataProjection,fieldVariable,fieldParameterSetType, &
      & dataPointGlobalNumber,fieldResult,err,error,*999)

    EXITS("OC_DataProjection_DataPointFieldEvaluateRegionNumber")
    RETURN
999 ERRORS("OC_DataProjection_DataPointFieldEvaluateRegionNumber",err,error)
    EXITS("OC_DataProjection_DataPointFieldEvaluateRegionNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointFieldEvaluateRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data point in a field based on data projection in an interface, identified by user number
  SUBROUTINE OC_DataProjection_DataPointFieldEvaluateInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,fieldUserNumber,fieldVarType,fieldParameterSetType, &
    & dataPointUserNumber,fieldResult,err)
    !DLLEXPORT(OC_DataProjection_DataPointFieldEvaluateInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the parent region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection    
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to evaluate the field at
    REAL(DP), INTENT(OUT) :: fieldResult(:) !<On return, the values of the field evaluated at the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_DataPointFieldEvaluateInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(field)
    NULLIFY(fieldVariable)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Interface_FieldGet(INTERFACE,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableGet(field,fieldVarType,fieldVariable,err,error,*999)
    CALL DataProjection_DataPointFieldVariableEvaluate(dataProjection,fieldVariable,fieldParameterSetType, &
      & dataPointGlobalNumber,fieldResult,err,error,*999)

    EXITS("OC_DataProjection_DataPointFieldEvaluateInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_DataPointFieldEvaluateInterfaceNumber",err,error)
    EXITS("OC_DataProjection_DataPointFieldEvaluateInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointFieldEvaluateInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data point in a field based on data projection, identified by object
  SUBROUTINE OC_DataProjection_DataPointFieldEvaluateObj(dataProjection,field,fieldVarType,fieldParameterSetType, &
    & dataPointUserNumber,fieldResult,err)
    !DLLEXPORT(OC_DataProjection_DataPointFieldEvaluateObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to interpolate
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to evaluate the field at
    REAL(DP), INTENT(OUT) :: fieldResult(:) !<On return, the values of the field evaluated at the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("OC_DataProjection_DataPointFieldEvaluateObj",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field%field,fieldVarType,fieldVariable,err,error,*999)
    CALL DataProjection_DataPointFieldVariableEvaluate(dataProjection%dataProjection,fieldVariable,fieldParameterSetType, &
      & dataPointUserNumber,fieldResult,err,error,*999)

    EXITS("OC_DataProjection_DataPointFieldEvaluateObj")
    RETURN
999 ERRORS("OC_DataProjection_DataPointFieldEvaluateObj",err,error)
    EXITS("OC_DataProjection_DataPointFieldEvaluateObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointFieldEvaluateObj

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in a region, identified by user number
  SUBROUTINE OC_DataProjection_DataPointsPositionEvaluateRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,fieldUserNumber,fieldVarType,fieldParameterSetType,err)
    !DLLEXPORT(OC_DataProjection_DataPointsPositionEvaluateRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_DataPointsPositionEvaluateRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVarType,fieldParameterSetType,err,error,*999)

    EXITS("OC_DataProjection_DataPointsPositionEvaluateRegionNumber")
    RETURN
999 ERRORS("OC_DataProjection_DataPointsPositionEvaluateRegionNumber",err,error)
    EXITS("OC_DataProjection_DataPointsPositionEvaluateRegionNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointsPositionEvaluateRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in an interface, identified by user number
  SUBROUTINE OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,fieldUserNumber,fieldVarType, &
    & fieldParameterSetType,err)
    !DLLEXPORT(OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVarType,fieldParameterSetType, &
      & err,error,*999)

    EXITS("OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error)
    EXITS("OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointsPositionEvaluateInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection, identified by object
  SUBROUTINE OC_DataProjection_DataPointsPositionEvaluateObj(dataProjection,field,fieldVarType,fieldParameterSetType,err)
    !DLLEXPORT(OC_DataProjection_DataPointsPositionEvaluateObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to interpolate
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldParameterSetType !<The field parameter set type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_DataPointsPositionEvaluateObj",err,error,*999)

    CALL DataProjection_DataPointsPositionEvaluate(dataProjection%dataProjection,field%field,fieldVarType, &
      & fieldParameterSetType,err,error,*999)

    EXITS("OC_DataProjection_DataPointsPositionEvaluateObj")
    RETURN
999 ERRORS("OC_DataProjection_DataPointsPositionEvaluateObj",err,error)
    EXITS("OC_DataProjection_DataPointsPositionEvaluateObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointsPositionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on a data point user number in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0",err,error,*999)

    CALL OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],err)

    EXITS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsRegionNumber0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDataPoints(dataProjection,dataPointGlobalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsRegionNumber1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsInterNum0(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDataPointsInterNum0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByDataPointsInterNum0",err,error,*999)

    CALL OC_DataProjection_ProjectionCancelByDataPointsInterNum1(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],err)

    EXITS("OC_DataProjection_ProjectionCancelByDataPointsInterNum0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDataPointsInterNum0",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDataPointsInterNum0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsInterNum0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsInterNum1(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDataPointsInterNum1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCancelByDataPointsInterNum1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDataPoints(dataProjection,dataPointGlobalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByDataPointsInterNum1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDataPointsInterNum1",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDataPointsInterNum1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsInterNum1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsObj0(dataProjection,dataPointUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDataPointsObj0)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByDataPointsObj0",err,error,*999)

    CALL OC_DataProjection_ProjectionCancelByDataPointsObj1(dataProjection,[dataPointUserNumber],err)

    EXITS("OC_DataProjection_ProjectionCancelByDataPointsObj0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDataPointsObj0",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDataPointsObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsObj0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsObj1(dataProjection,dataPointUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDataPointsObj1)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers to use to cancel projections.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ProjectionCancelByDataPointsObj1",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_ProjectionCancelByDataPoints(dataProjection%dataProjection,dataPointGlobalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByDataPointsObj1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDataPointsObj1",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDataPointsObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDataPointsObj1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection distance in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByDistanceRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,distanceRelation,distance,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDistanceRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: distanceRelation !<The distance relation to use to cancel projections \see OpenCMISS_DataProjectionDistanceRelations
    REAL(DP), INTENT(IN) :: distance !<The distance by which to select the data points to cancel.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCancelByDistanceRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDistance(dataProjection,distanceRelation,distance,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByDistanceRegionNumber")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDistanceRegionNumber",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDistanceRegionNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDistanceRegionNumber

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection distance in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,distanceRelation,distance,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: distanceRelation !<The distance relation to use to cancel projections \see OpenCMISS_DataProjectionDistanceRelations
    REAL(DP), INTENT(IN) :: distance !<The distance by which to select the data points to cancel.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByDistance(dataProjection,distanceRelation,distance,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDistanceInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection distance as specified by object
  SUBROUTINE OC_DataProjection_ProjectionCancelByDistanceObj(dataProjection,distanceRelation,distance,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByDistanceObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: distanceRelation !<The distance relation to use to cancel projections \see OpenCMISS_DataProjectionDistanceRelations
    REAL(DP), INTENT(IN) :: distance !<The distance by which to select the data points to cancel.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByDistanceObj",err,error,*999)

    CALL DataProjection_ProjectionCancelByDistance(dataProjection%dataProjection,distanceRelation,distance,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByDistanceObj")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByDistanceObj",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByDistanceObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByDistanceObj

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,exitTag,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTag !<The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0",err,error,*999)

    CALL OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,[exitTag],err)

    EXITS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsRegionNumber0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,exitTags,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTags(:) !<exitTags(tagIdx). The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByExitTags(dataProjection,exitTags,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsRegionNumber1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,exitTag,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTag !<The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0",err,error,*999)

    CALL OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[exitTag],err)

    EXITS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,exitTags,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: exitTags(:) !<exitTags(tagIdx). The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionCancelByExitTags(dataProjection,exitTags,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsInterfaceNumber1

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsObj0(dataProjection,exitTag,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByExitTagsObj0)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: exitTag !<The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByExitTagsObj0",err,error,*999)

    CALL OC_DataProjection_ProjectionCancelByExitTagsObj1(dataProjection,[exitTag],err)

    EXITS("OC_DataProjection_ProjectionCancelByExitTagsObj0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByExitTagsObj0",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByExitTagsObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsObj0

  !
  !================================================================================================================================
  !

  !>Cancel the data projection for data points based on the projection exit tag as specified by object
  SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsObj1(dataProjection,exitTags,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCancelByExitTagsObj1)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: exitTags(:) !<exitTags(tagIdx). The exit tags to use to cancel projections \see OpenCMISS_DataProjectionExitTags
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCancelByExitTagsObj1",err,error,*999)

    CALL DataProjection_ProjectionCancelByExitTags(dataProjection%dataProjection,exitTags,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCancelByExitTagsObj1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCancelByExitTagsObj1",err,error)
    EXITS("OC_DataProjection_ProjectionCancelByExitTagsObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCancelByExitTagsObj1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for an all elements projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetRegionNumber0

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for an all elements projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateElementsSet(dataProjection,candidateElementLocalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetRegionNumber1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for an all elements projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetIntNum0(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateElementsSetIntNum0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateElementsSetIntNum0",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateElementsSetIntNum1(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionCandidateElementsSetIntNum0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateElementsSetIntNum0",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateElementsSetIntNum0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetIntNum0

  !
  !================================================================================================================================
  !

  !>ESet the data projection candidate elements for an all elements projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetIntNum1(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateElementsSetIntNum1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCandidateElementsSetIntNum1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateElementsSet(dataProjection,candidateElementLocalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateElementsSetIntNum1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateElementsSetIntNum1",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateElementsSetIntNum1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetIntNum1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for an all elements projection type specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetObj0(dataProjection,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateElementsSetObj0)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateElementsSetObj0",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateElementsSetObj1(dataProjection,[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionCandidateElementsSetObj0")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateElementsSetObj0",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateElementsSetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetObj0

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for an all elements projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetObj1(dataProjection,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateElementsSetObj1)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ProjectionCandidateElementsSetObj1",err,error,*999)

    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateElementsSet(dataProjection%dataProjection,candidateElementLocalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateElementsSetObj1")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateElementsSetObj1",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateElementsSetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateElementsSetObj1

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for a data point for an all elements projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for a data point for an all elements projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate elements user numbers for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for data points for an all elements projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for data points for an all elements projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionElements)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateElementsSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetRegNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for a data point for an all elements projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number.
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for a data point for an all elements projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers.
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for data points for an all elements projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for data points for an all elements projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionElements)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateElementsSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetIntNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for a data point for an all elements projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj00(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetObj00)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetObj00",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,[dataPointUserNumber], &
      & [candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetObj00",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for a data point for an all elements projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj01(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetObj01)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetObj01",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,[dataPointUserNumber], &
      & candidateElementUserNumbers,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetObj01",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate element for data points for an all elements projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj10(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetObj10)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetObj10",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,dataPointUserNumbers, &
      & [candidateElementUserNumber],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetObj10",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate elements for data points for an all elements projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj11(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumbers,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateElementsSetObj11)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ProjectionDataCandidateElementsSetObj11",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionElements)
    NULLIFY(decompositionTopology)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateElementsSet(dataProjection%dataProjection,dataPointGlobalNumbers, &
      & candidateElementLocalNumbers,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateElementsSetObj11",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateElementsSetObj11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateElementsSetObj11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateFaceNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateFacesSet(dataProjection,candidateElementLocalNumbers,candidateFaceNormals, &
      & err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetRegionNumber11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateFaceNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateFacesSet(dataProjection,candidateElementLocalNumbers,candidateFaceNormals, &
      & err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetInterfaceNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj00(dataProjection,candidateElementUserNumber, &
    & candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetObj00)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetObj00",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,[candidateElementUserNumber], &
      & [candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetObj00",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj10(dataProjection,candidateElementUserNumbers, &
    & candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetObj10)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normals of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetObj10",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,candidateElementUserNumbers, &
      & [candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetObj10",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj01(dataProjection,candidateElementUserNumber, &
    & candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetObj01)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetObj01",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,[candidateElementUserNumber], &
      & candidateFaceNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetObj01",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj11(dataProjection,candidateElementUserNumbers, &
    & candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateFacesSetObj11)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ProjectionCandidateFacesSetObj11",err,error,*999)

    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateFacesSet(dataProjection%dataProjection,candidateElementLocalNumbers, &
      & candidateFaceNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateFacesSetObj11",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateFacesSetObj11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateFacesSetObj11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for a data point in a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a data point in a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers,candidateFaceNormals,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for data points in a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
      & dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for data points in a boundary faces projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateFacesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateFaceNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetRegNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for a data point for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber, &
    & candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber], &
      & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a data point for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers, &
    & candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber], &
      & candidateElementUserNumbers,candidateFaceNormals,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for data points for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber, &
    & candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers, &
      & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for data points for a boundary faces projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers, &
    & candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateFacesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateFaceNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetIntNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for a data point for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj000(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetObj000)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetObj000",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,[dataPointUserNumber], &
      & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj000")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetObj000",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj000")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for a data point for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj011(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetObj011)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetObj011",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,[dataPointUserNumber], &
      & candidateElementUserNumbers,candidateFaceNormals,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj011")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetObj011",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj011")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate face for data points for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj100(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumber,candidateFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetObj100)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormal !<The xi normal of the candidate face for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetObj100",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,dataPointUserNumbers, &
      & [candidateElementUserNumber],[candidateFaceNormal],err)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj100")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetObj100",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj100")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate faces for data points for a boundary faces projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj111(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumbers,candidateFaceNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateFacesSetObj111)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateFaceNormals(:) !<candidateFaceNormals(elementIdx). The xi normals of the candidate faces for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ProjectionDataCandidateFacesSetObj111",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateFacesSet(dataProjection%dataProjection,dataPointGlobalNumbers, &
      & candidateElementLocalNumbers,candidateFaceNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj111")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateFacesSetObj111",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateFacesSetObj111")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateFacesSetObj111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),1)

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00",err,error,*999)

    candidateLineNormals(1:SIZE(candidateLineNormal,1),1)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    CALL OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),SIZE(candidateElementUserNumbers,1)),elementIdx

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10",err,error,*999)

    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      candidateLineNormals(1:SIZE(candidateLineNormal,1),elementIdx)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    ENDDO !elementIdx
    CALL OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateLinesSet(dataProjection,candidateElementLocalNumbers,candidateLineNormals, &
      & err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetRegionNumber11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),1)

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00",err,error,*999)

    candidateLineNormals(1:SIZE(candidateLineNormal,1),1)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    CALL OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),SIZE(candidateElementUserNumbers,1)),elementIdx

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10",err,error,*999)

    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      candidateLineNormals(1:SIZE(candidateLineNormal,1),elementIdx)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    ENDDO !elementIdx
    CALL OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[candidateElementUserNumber],candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateLinesSet(dataProjection,candidateElementLocalNumbers,candidateLineNormals, &
      & err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetInterfaceNum11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj00(dataProjection,candidateElementUserNumber, &
    & candidateLineNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetObj00)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormal(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),1)

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetObj00",err,error,*999)

    candidateLineNormals(1:SIZE(candidateLineNormal,1),1)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    CALL OC_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,[candidateElementUserNumber], &
      & candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj00")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetObj00",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj00")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj00

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj10(dataProjection,candidateElementUserNumbers, &
    & candidateLineNormal,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetObj10)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormal(:) !<candidateLineNormal(normalIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateLineNormals(SIZE(candidateLineNormal,1),SIZE(candidateElementUserNumbers,1)),elementIdx

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetObj10",err,error,*999)

    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      candidateLineNormals(1:SIZE(candidateLineNormal,1),elementIdx)=candidateLineNormal(1:SIZE(candidateLineNormal,1))
    ENDDO !elementIdx
    CALL OC_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,candidateElementUserNumbers, &
      & candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj10")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetObj10",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj10")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj10

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj01(dataProjection,candidateElementUserNumber, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetObj01)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormal(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetObj01",err,error,*999)

    CALL OC_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,[candidateElementUserNumber], &
      & candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj01")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetObj01",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj01")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj01

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj11(dataProjection,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionCandidateLinesSetObj11)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)),elementIdx
    LOGICAL :: ghostElement
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ProjectionCandidateLinesSetObj11",err,error,*999)

    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionCandidateLinesSet(dataProjection%dataProjection,candidateElementLocalNumbers, &
      & candidateLineNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj11")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionCandidateLinesSetObj11",err,error)
    EXITS("OC_DataProjection_ProjectionCandidateLinesSetObj11")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionCandidateLinesSetObj11

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for a data point for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],[candidateElementUserNumber], &
      & RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a data point for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers, &
      & candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for data points for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
      & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,[candidateElementUserNumber], &
      & RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for data points for a boundary lines projection type in a region specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111(contextUserNumber,regionUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateLinesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateLineNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetRegNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for a data point for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumber, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber], &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a data point for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,[dataPointUserNumber],candidateElementUserNumbers, &
      & candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for data points for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumber, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<candidateLineNormals(normalIdx). The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
      & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers, &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for data points for a boundary lines projection type in an interface specified by user number
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumbers,candidateElementUserNumbers, &
    & candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateLinesSet(dataProjection,dataPointGlobalNumbers,candidateElementLocalNumbers, &
      & candidateLineNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetIntNum111

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for a data point for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj000(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetObj000)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetObj000",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,[dataPointUserNumber], &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj000")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetObj000",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj000")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj000

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for a data point for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj011(dataProjection,dataPointUserNumber, &
    & candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetObj011)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetObj011",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,[dataPointUserNumber], &
      & candidateElementUserNumbers,candidateLineNormals,err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj011")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetObj011",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj011")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj011

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate line for data points for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj100(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumber,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetObj100)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element number
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumber !<The candidate element user number for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:) !<The xi normals of the candidate line for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetObj100",err,error,*999)

    CALL OC_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,dataPointUserNumbers, &
      & [candidateElementUserNumber],RESHAPE(candidateLineNormals,[SIZE(candidateLineNormals,1),1]),err)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj100")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetObj100",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj100")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj100

  !
  !================================================================================================================================
  !

  !>Set the data projection candidate lines for data points for a boundary lines projection type in a region specified by object
  SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj111(dataProjection,dataPointUserNumbers, &
    & candidateElementUserNumbers,candidateLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ProjectionDataCandidateLinesSetObj111)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumbers(:) !<dataPointUserNumbers(dataPointIdx). The data point user numbers for the projection candidate user element numbers
    INTEGER(INTG), INTENT(IN) :: candidateElementUserNumbers(:) !<candidateElementUserNumbers(elementIdx). The candidate element user numbers for the projection.
    INTEGER(INTG), INTENT(IN) :: candidateLineNormals(:,:) !<candidateLineNormals(normalIdx,elementIdx). The xi normals of the candidate lines for the projection. \see OpenCMISS_ElementNormalXiDirections,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: candidateElementLocalNumbers(SIZE(candidateElementUserNumbers,1)), &
      & dataPointGlobalNumbers(SIZE(dataPointUserNumbers,1)),dataPointIdx,elementIdx
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ProjectionDataCandidateLinesSetObj111",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)    
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    DO dataPointIdx=1,SIZE(dataPointUserNumbers,1)
      CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumbers(dataPointIdx),dataPointGlobalNumbers(dataPointIdx), &
        & err,error,*999)
    ENDDO !dataPointIdx
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    DO elementIdx=1,SIZE(candidateElementUserNumbers,1)
      CALL DecompositionElements_LocalNumberGet(decompositionElements,candidateElementUserNumbers(elementIdx), &
        & candidateElementLocalNumbers(elementIdx),ghostElement,err,error,*999)
    ENDDO !elementIdx
    CALL DataProjection_ProjectionDataCandidateLinesSet(dataProjection%dataProjection,dataPointGlobalNumbers, &
      & candidateElementLocalNumbers,candidateLineNormals,err,error,*999)

    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj111")
    RETURN
999 ERRORS("OC_DataProjection_ProjectionDataCandidateLinesSetObj111",err,error)
    EXITS("OC_DataProjection_ProjectionDataCandidateLinesSetObj111")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionDataCandidateLinesSetObj111

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_DataPointsProjectionEvaluateNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionFieldSetType,err)
    !DLLEXPORT(OC_DataProjection_DataPointsProjectionEvaluateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to evaluate.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: projectionFieldSetType !<The parameter set type of the field data points are be projected on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_DataPointsProjectionEvaluateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DataPointsProjectionEvaluate(dataProjection,projectionFieldSetType,err,error,*999)

    EXITS("OC_DataProjection_DataPointsProjectionEvaluateNumber")
    RETURN
999 ERRORS("OC_DataProjection_DataPointsProjectionEvaluateNumber",err,error)
    EXITS("OC_DataProjection_DataPointsProjectionEvaluateNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointsProjectionEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by an object.
  SUBROUTINE OC_DataProjection_DataPointsProjectionEvaluateObj(dataProjection,projectionFieldSetType,err)
    !DLLEXPORT(OC_DataProjection_DataPointsProjectionEvaluateObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to evaluate.
    INTEGER(INTG), INTENT(IN) :: projectionFieldSetType !<The parameter set type of the field data points are be projected on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_DataPointsProjectionEvaluateObj",err,error,*999)

    CALL DataProjection_DataPointsProjectionEvaluate(dataProjection%dataProjection,projectionFieldSetType,err,error,*999)

    EXITS("OC_DataProjection_DataPointsProjectionEvaluateObj")
    RETURN
999 ERRORS("OC_DataProjection_DataPointsProjectionEvaluateObj",err,error)
    EXITS("OC_DataProjection_DataPointsProjectionEvaluateObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_DataPointsProjectionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_MaximumIterationUpdateGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumIterationUpdate,err)
    !DLLEXPORT(OC_DataProjection_MaximumIterationUpdateGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_MaximumIterationUpdateGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumInterationUpdateGet(dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("OC_DataProjection_MaximumIterationUpdateGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_MaximumIterationUpdateGetNumber",err,error)
    EXITS("OC_DataProjection_MaximumIterationUpdateGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumIterationUpdateGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE OC_DataProjection_MaximumIterationUpdateGetObj(dataProjection,maximumIterationUpdate,err)
    !DLLEXPORT(OC_DataProjection_MaximumIterationUpdateGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_MaximumIterationUpdateGetObj",err,error,*999)

    CALL DataProjection_MaximumInterationUpdateGet(dataProjection%dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("OC_DataProjection_MaximumIterationUpdateGetObj")
    RETURN
999 ERRORS("OC_DataProjection_MaximumIterationUpdateGetObj",err,error)
    EXITS("OC_DataProjection_MaximumIterationUpdateGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumIterationUpdateGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_MaximumIterationUpdateSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumIterationUpdate,err)
    !DLLEXPORT(OC_DataProjection_MaximumIterationUpdateSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_MaximumIterationUpdateSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumInterationUpdateSet(dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("OC_DataProjection_MaximumIterationUpdateSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_MaximumIterationUpdateSetNumber",err,error)
    EXITS("OC_DataProjection_MaximumIterationUpdateSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumIterationUpdateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE OC_DataProjection_MaximumIterationUpdateSetObj(dataProjection,maximumIterationUpdate,err)
    !DLLEXPORT(OC_DataProjection_MaximumIterationUpdateSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_MaximumIterationUpdateSetObj",err,error,*999)

    CALL DataProjection_MaximumInterationUpdateSet(dataProjection%dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("OC_DataProjection_MaximumIterationUpdateSetObj")
    RETURN
999 ERRORS("OC_DataProjection_MaximumIterationUpdateSetObj",err,error)
    EXITS("OC_DataProjection_MaximumIterationUpdateSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumIterationUpdateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumNumberOfIterations,err)
    !DLLEXPORT(OC_DataProjection_MaximumNumberOfIterationsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_MaximumNumberOfIterationsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumNumberOfIterationsGet(dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("OC_DataProjection_MaximumNumberOfIterationsGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_MaximumNumberOfIterationsGetNumber",err,error)
    EXITS("OC_DataProjection_MaximumNumberOfIterationsGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified an object.
  SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsGetObj(dataProjection,maximumNumberOfIterations,err)
    !DLLEXPORT(OC_DataProjection_MaximumNumberOfIterationsGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_MaximumNumberOfIterationsGetObj",err,error,*999)

    CALL DataProjection_MaximumNumberOfIterationsGet(dataProjection%dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("OC_DataProjection_MaximumNumberOfIterationsGetObj")
    RETURN
999 ERRORS("OC_DataProjection_MaximumNumberOfIterationsGetObj",err,error)
    EXITS("OC_DataProjection_MaximumNumberOfIterationsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsGetObj

  !
  !================================================================================================================================
  !

  !>Outputs the analysis of data projection results for a data projection identified by user number.
  SUBROUTINE OC_DataProjection_ResultAnalysisOutputNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,filename,err)
    !DLLEXPORT(OC_DataProjection_ResultAnalysisOutputNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to output the analysis for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to output the analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: filename !<If not empty, the filename to output the data projection result analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultAnalysisOutputNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultAnalysisOutput(dataProjection,filename,err,error,*999)

    EXITS("OC_DataProjection_ResultAnalysisOutputNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultAnalysisOutputNumber",err,error)
    EXITS("OC_DataProjection_ResultAnalysisOutputNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultAnalysisOutputNumber

  !
  !================================================================================================================================
  !

  !>Outputs the analysis of data projection results for a data projection identified by an object.
  SUBROUTINE OC_DataProjection_ResultAnalysisOutputObj(dataProjection,filename,err)
    !DLLEXPORT(OC_DataProjection_ResultAnalysisOutputObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<A pointer to the data projection to output the result analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: filename !<If not empty, the filename to output the data projection result analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ResultAnalysisOutputObj",err,error,*999)

    CALL DataProjection_ResultAnalysisOutput(dataProjection%dataProjection,filename,err,error,*999)

    EXITS("OC_DataProjection_ResultAnalysisOutputObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultAnalysisOutputObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultAnalysisOutputObj

  !
  !================================================================================================================================
  !

  !>Returns the projection distance for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultDistanceGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionDistance,err)
    !DLLEXPORT(OC_DataProjection_ResultDistanceGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data point to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultDistanceGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultDistanceGet(dataProjection,dataPointGlobalNumber,projectionDistance,err,error,*999)

    EXITS("OC_DataProjection_ResultDistanceGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultDistanceGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultDistanceGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the projection distance for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultDistanceGetObj(dataProjection,dataPointUserNumber,projectionDistance,err)
    !DLLEXPORT(OC_DataProjection_ResultDistanceGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultDistanceGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultDistanceGet(dataProjection%dataProjection,dataPointGlobalNumber,projectionDistance, &
      & err,error,*999)

    EXITS("OC_DataProjection_ResultDistanceGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultDistanceGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultDistanceGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element user number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementUserNumber !<On return, the projection element user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementNumberGet(dataProjection,dataPointGlobalNumber,projectionElementUserNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultElementNumberGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementNumberGetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementNumberGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element user number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementNumberGetObj(dataProjection,dataPointUserNumber,projectionElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementNumberGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementUserNumber !<On return, the projection element user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementNumberGet(dataProjection%dataProjection,dataPointGlobalNumber,projectionElementUserNumber, &
      & err,error,*999)

    EXITS("OC_DataProjection_ResultElementNumberGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementNumberGetObj",err,error)
    EXITS("OC_DataProjection_ResultElementNumberGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection element user number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementNumberSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: projectionElementUserNumber !<The projection element user number to set for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementNumberSet(dataProjection,dataPointGlobalNumber,projectionElementUserNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultElementNumberSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementNumberSetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementNumberSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection element number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementNumberSetObj(dataProjection,dataPointUserNumber,projectionElementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementNumberSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: projectionElementUserNumber !<The projection element user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementNumberSetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementNumberSet(dataProjection%dataProjection,dataPointGlobalNumber,projectionElementUserNumber, &
      & err,error,*999)

    EXITS("OC_DataProjection_ResultElementNumberSetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementNumberSetObj",err,error)
    EXITS("OC_DataProjection_ResultElementNumberSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementFaceNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementFaceNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementFaceNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementFaceNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementFaceNumberGet(dataProjection,dataPointGlobalNumber,projectionElementFaceNumber,err, &
      & error,*999)

    EXITS("OC_DataProjection_ResultElementFaceNumberGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementFaceNumberGetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementFaceNumberGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementFaceNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementFaceNumberGetObj(dataProjection,dataPointUserNumber, &
    & projectionElementFaceNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementFaceNumberGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementFaceNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementFaceNumberGet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionElementFaceNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultElementFaceNumberGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementFaceNumberGetObj",err,error)
    EXITS("OC_DataProjection_ResultElementFaceNumberGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementFaceNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection element face number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementFaceNumberSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementUserNumber,localFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ResultElementFaceNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: projectionElementUserNumber !<The projection candidate user element number to set the result
    INTEGER(INTG), INTENT(IN) :: localFaceNormal !<The projection candidate element face normal to set the result for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementFaceNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementFaceNumberSet(dataProjection,dataPointGlobalNumber,projectionElementUserNumber, &
      & localFaceNormal,err,error,*999)

    EXITS("OC_DataProjection_ResultElementFaceNumberSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementFaceNumberSetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementFaceNumberSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementFaceNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection element face number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementFaceNumberSetObj(dataProjection,dataPointUserNumber, &
    & projectionElementUserNumber,localFaceNormal,err)
    !DLLEXPORT(OC_DataProjection_ResultElementFaceNumberSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to Set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to Set attributes for.
    INTEGER(INTG), INTENT(IN) :: projectionElementUserNumber !<The projection candidate user element number to set the result
    INTEGER(INTG), INTENT(IN) :: localFaceNormal !<The projection candidate element face normal to set the result for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementFaceNumberSetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementFaceNumberSet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionElementUserNumber,localFaceNormal,err,error,*999)

    EXITS("OC_DataProjection_ResultElementFaceNumberSetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementFaceNumberSetObj",err,error)
    EXITS("OC_DataProjection_ResultElementFaceNumberSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementFaceNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementLineNumberGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementLineNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementLineNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementLineNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementLineNumberGet(dataProjection,dataPointGlobalNumber,projectionElementLineNumber,err, &
      & error,*999)

    EXITS("OC_DataProjection_ResultElementLineNumberGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementLineNumberGetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementLineNumberGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementLineNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementLineNumberGetObj(dataProjection,dataPointUserNumber, &
    & projectionElementLineNumber,err)
    !DLLEXPORT(OC_DataProjection_ResultElementLineNumberGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementLineNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementLineNumberGet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionElementLineNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultElementLineNumberGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementLineNumberGetObj",err,error)
    EXITS("OC_DataProjection_ResultElementLineNumberGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementLineNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection element line number for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementLineNumberSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionElementUserNumber,localLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ResultElementLineNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: projectionElementUserNumber !The projection element user number for the data point.
    INTEGER(INTG), INTENT(IN) :: localLineNormals(:) !<localLineNormals(normalDirectionIdx). The projection candidate element line normals to set the result for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementLineNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementLineNumberSet(dataProjection,dataPointGlobalNumber,projectionElementUserNumber, &
      & localLineNormals,err,error,*999)

    EXITS("OC_DataProjection_ResultElementLineNumberSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementLineNumberSetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementLineNumberSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementLineNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection element line number for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementLineNumberSetObj(dataProjection,dataPointUserNumber, &
    & projectionElementUserNumber,localLineNormals,err)
    !DLLEXPORT(OC_DataProjection_ResultElementLineNumberSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: projectionElementUserNumber !The projection element user number for the data point.
    INTEGER(INTG), INTENT(IN) :: localLineNormals(:) !<localLineNormals(normalDirectionIdx). The projection candidate element line normals to set the result for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementLineNumberSetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementLineNumberSet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionElementUserNumber,localLineNormals,err,error,*999)

    EXITS("OC_DataProjection_ResultElementLineNumberSetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementLineNumberSetObj",err,error)
    EXITS("OC_DataProjection_ResultElementLineNumberSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementLineNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the element xi for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultElementXiGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,elementXi,err)
    !DLLEXPORT(OC_DataProjection_ResultElementXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: elementXi(:) !<On return, the element xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOFElementXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultElementXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultElementXiGet(dataProjection,dataPointGlobalNumber,numberOfElementXi,elementXi,err,error,*999)

    EXITS("OC_DataProjection_ResultElementXiGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementXiGetNumber",err,error)
    EXITS("OC_DataProjection_ResultElementXiGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element xi for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultElementXiGetObj(dataProjection,dataPointUserNumber,elementXi,err)
    !DLLEXPORT(OC_DataProjection_ResultElementXiGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: elementXi(:) !<On return, the element xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfElementXi
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultElementXiGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultElementXiGet(dataProjection%dataProjection,dataPointGlobalNumber,numberOfElementXi,elementXi, &
      & err,error,*999)

    EXITS("OC_DataProjection_ResultElementXiGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultElementXiGetObj",err,error)
    EXITS("OC_DataProjection_ResultElementXiGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultElementXiGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultExitTagGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionExitTag,err)
    !DLLEXPORT(OC_DataProjection_ResultExitTagGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultExitTagGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultExitTagGet(dataProjection,dataPointGlobalNumber,projectionExitTag,err,error,*999)

    EXITS("OC_DataProjection_ResultExitTagGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultExitTagGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultExitTagGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultExitTagGetObj(dataProjection,dataPointUserNumber,projectionExitTag,err)
    !DLLEXPORT(OC_DataProjection_ResultExitTagGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: projectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultExitTagGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultExitTagGet(dataProjection%dataProjection,dataPointGlobalNumber,projectionExitTag, &
      & err,error,*999)

    EXITS("OC_DataProjection_ResultExitTagGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultExitTagGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultExitTagGetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum error for a data projection given by numbers.
  SUBROUTINE OC_DataProjection_ResultMaximumErrorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumDataPointUserNumber,maximumError,err)
    !DLLEXPORT(OC_DataProjection_ResultMaximumErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the maximum error for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get the maximum error for.
    INTEGER(INTG), INTENT(OUT) :: maximumDataPointUserNumber !<On return, the user number of the data point that has the maximum error.
    REAL(DP), INTENT(OUT) :: maximumError !<On return, the maximum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: maximumDataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultMaximumErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultMaximumErrorGet(dataProjection,maximumDataPointGlobalNumber,maximumError,err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,maximumDataPointGlobalNumber,maximumDataPointUserNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultMaximumErrorGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultMaximumErrorGetNumber",err,error)
    EXITS("OC_DataProjection_ResultMaximumErrorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultMaximumErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the maximum error for a data projection given by an object.
  SUBROUTINE OC_DataProjection_ResultMaximumErrorGetObj(dataProjection,maximumDataPointUserNumber,maximumError,err)
    !DLLEXPORT(OC_DataProjection_ResultMaximumErrorGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get the maximum error for.
    INTEGER(INTG), INTENT(OUT) :: maximumDataPointUserNumber !<On return, the user number of the data point that has the maximum error.
    REAL(DP), INTENT(OUT) :: maximumError !<On return, the maximum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: maximumDataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultMaximumErrorGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataProjection_ResultMaximumErrorGet(dataProjection%dataProjection,maximumDataPointGlobalNumber,maximumError, &
      & err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,maximumDataPointGlobalNumber,maximumDataPointUserNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultMaximumErrorGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultMaximumErrorGetObj",err,error)
    EXITS("OC_DataProjection_ResultMaximumErrorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultMaximumErrorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the minimum error for a data projection given by numbers.
  SUBROUTINE OC_DataProjection_ResultMinimumErrorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,minimumDataPointUserNumber,minimumError,err)
    !DLLEXPORT(OC_DataProjection_ResultMinimumErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the minimum error for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get the minimum error for.
    INTEGER(INTG), INTENT(OUT) :: minimumDataPointUserNumber !<On return, the user number of the data point that has the minimum error.
    REAL(DP), INTENT(OUT) :: minimumError !<On return, the minimum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: minimumDataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultMinimumErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultMinimumErrorGet(dataProjection,minimumDataPointGlobalNumber,minimumError,err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,minimumDataPointGlobalNumber,minimumDataPointUserNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultMinimumErrorGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultMinimumErrorGetNumber",err,error)
    EXITS("OC_DataProjection_ResultMinimumErrorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultMinimumErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the minimum error for a data projection given by an object.
  SUBROUTINE OC_DataProjection_ResultMinimumErrorGetObj(dataProjection,minimumDataPointUserNumber,minimumError,err)
    !DLLEXPORT(OC_DataProjection_ResultMinimumErrorGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get the minimum error for.
    INTEGER(INTG), INTENT(OUT) :: minimumDataPointUserNumber !<On return, the user number of the data point that has the minimum error.
    REAL(DP), INTENT(OUT) :: minimumError !<On return, the minimum error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: minimumDataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultMinimumErrorGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataProjection_ResultMinimumErrorGet(dataProjection%dataProjection,minimumDataPointGlobalNumber,minimumError, &
      & err,error,*999)
    CALL DataPoints_DataUserNumberGet(dataPoints,minimumDataPointGlobalNumber,minimumDataPointUserNumber,err,error,*999)

    EXITS("OC_DataProjection_ResultMinimumErrorGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultMinimumErrorGetObj",err,error)
    EXITS("OC_DataProjection_ResultMinimumErrorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultMinimumErrorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the RMS error for a data projection given by numbers.
  SUBROUTINE OC_DataProjection_ResultRMSErrorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,rmsError,err)
    !DLLEXPORT(OC_DataProjection_ResultRMSErrorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the RMS error for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get the RMS error for.
    REAL(DP), INTENT(OUT) :: rmsError !<On return, the RMS error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultRMSErrorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultRMSErrorGet(dataProjection,rmsError,err,error,*999)

    EXITS("OC_DataProjection_ResultRMSErrorGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultRMSErrorGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultRMSErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the RMS error for a data projection given by an object.
  SUBROUTINE OC_DataProjection_ResultRMSErrorGetObj(dataProjection,rmsError,err)
    !DLLEXPORT(OC_DataProjection_ResultRMSErrorGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get the RMS error for.
    REAL(DP), INTENT(OUT) :: rmsError !<On return, the RMS error for the data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ResultRMSErrorGetObj",err,error,*999)

    CALL DataProjection_ResultRMSErrorGet(dataProjection%dataProjection,rmsError,err,error,*999)

    EXITS("OC_DataProjection_ResultRMSErrorGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultRMSErrorGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultRMSErrorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection vector for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultProjectionVectorGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionVector,err)
    !DLLEXPORT(OC_DataProjection_ResultProjectionVectorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionVector(:) !<On return, the projection vector for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultProjectionVectorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultProjectionVectorGet(dataProjection,dataPointGlobalNumber,projectionVector,err,error,*999)

    EXITS("OC_DataProjection_ResultProjectionVectorGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_ResultProjectionVectorGetNumber",err,error)
    EXITS("OC_DataProjection_ResultProjectionVectorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultProjectionVectorGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection vector for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultProjectionVectorGetObj(dataProjection,dataPointUserNumber,projectionVector,err)
    !DLLEXPORT(OC_DataProjection_ResultProjectionVectorGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionVector(:) !<On return, the projection vector for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultProjectionVectorGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultProjectionVectorGet(dataProjection%dataProjection,dataPointGlobalNumber, &
      & projectionVector,err,error,*999)

    EXITS("OC_DataProjection_ResultProjectionVectorGetObj")
    RETURN
999 ERRORS("OC_DataProjection_ResultProjectionVectorGetObj",err,error)
    EXITS("OC_DataProjection_ResultProjectionVectorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultProjectionVectorGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultProjectionXiGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(OC_DataProjection_ResultProjectionXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfProjectionXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultProjectionXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultProjectionXiGet(dataProjection,dataPointGlobalNumber,numberOfProjectionXi,projectionXi, &
      & err,error,*999)

    EXITS("OC_DataProjection_ResultProjectionXiGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultProjectionXiGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultProjectionXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultProjectionXiGetObj(dataProjection,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(OC_DataProjection_ResultProjectionXiGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfProjectionXi
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultProjectionXiGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultProjectionXiGet(dataProjection%dataProjection,dataPointGlobalNumber,numberOfProjectionXi, &
      & projectionXi,err,error,*999)

    EXITS("OC_DataProjection_ResultProjectionXiGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultProjectionXiGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultProjectionXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE OC_DataProjection_ResultProjectionXiSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(OC_DataProjection_ResultProjectionXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    REAL(DP), INTENT(IN) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ResultProjectionXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ResultProjectionXiSet(dataProjection,dataPointglobalNumber,projectionXi,err,error,*999)

    EXITS("OC_DataProjection_ResultProjectionXiSetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultProjectionXiSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultProjectionXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE OC_DataProjection_ResultProjectionXiSetObj(dataProjection,dataPointUserNumber,projectionXi,err)
    !DLLEXPORT(OC_DataProjection_ResultProjectionXiSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for
    REAL(DP), INTENT(IN) :: projectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_ResultProjectionXiSetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_ResultProjectionXiSet(dataProjection%dataProjection,dataPointGlobalNumber,projectionXi,err,error,*999)

    EXITS("OC_DataProjection_ResultProjectionXiSetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ResultProjectionXiSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ResultProjectionXiSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,maximumNumberOfIterations,err)
    !DLLEXPORT(OC_DataProjection_MaximumNumberOfIterationsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set maximum number of iterations for
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_MaximumNumberOfIterationsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_MaximumNumberOfIterationsSet(dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("OC_DataProjection_MaximumNumberOfIterationsSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_MaximumNumberOfIterationsSetNumber",err,error)
    EXITS("OC_DataProjection_MaximumNumberOfIterationsSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified an object.
  SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsSetObj(dataProjection,maximumNumberOfIterations,err)
    !DLLEXPORT(OC_DataProjection_MaximumNumberOfIterationsSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_MaximumNumberOfIterationsSetObj",err,error,*999)

    CALL DataProjection_MaximumNumberOfIterationsSet(dataProjection%dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("OC_DataProjection_MaximumNumberOfIterationsSetObj")
    RETURN
999 ERRORS("OC_DataProjection_MaximumNumberOfIterationsSetObj",err,error)
    EXITS("OC_DataProjection_MaximumNumberOfIterationsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_MaximumNumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_NumberOfClosestElementsGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,numberOfClosestElements,err)
    !DLLEXPORT(OC_DataProjection_NumberOfClosestElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_NumberOfClosestElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_NumberOfClosestElementsGet(dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("OC_DataProjection_NumberOfClosestElementsGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_NumberOfClosestElementsGetNumber",err,error)
    EXITS("OC_DataProjection_NumberOfClosestElementsGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_NumberOfClosestElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified an object.
  SUBROUTINE OC_DataProjection_NumberOfClosestElementsGetObj(dataProjection,numberOfClosestElements,err)
    !DLLEXPORT(OC_DataProjection_NumberOfClosestElementsGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_NumberOfClosestElementsGetObj",err,error,*999)

    CALL DataProjection_NumberOfClosestElementsGet(dataProjection%dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("OC_DataProjection_NumberOfClosestElementsGetObj")
    RETURN
999 ERRORS("OC_DataProjection_NumberOfClosestElementsGetObj",err,error)
    EXITS("OC_DataProjection_NumberOfClosestElementsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_NumberOfClosestElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_NumberOfClosestElementsSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,numberOfClosestElements,err)
    !DLLEXPORT(OC_DataProjection_NumberOfClosestElementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_NumberOfClosestElementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_NumberOfClosestElementsSet(dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("OC_DataProjection_NumberOfClosestElementsSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_NumberOfClosestElementsSetNumber",err,error)
    EXITS("OC_DataProjection_NumberOfClosestElementsSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_NumberOfClosestElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified an object.
  SUBROUTINE OC_DataProjection_NumberOfClosestElementsSetObj(dataProjection,numberOfClosestElements,err)
    !DLLEXPORT(OC_DataProjection_NumberOfClosestElementsSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_NumberOfClosestElementsSetObj",err,error,*999)

    CALL DataProjection_NumberOfClosestElementsSet(dataProjection%dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("OC_DataProjection_NumberOfClosestElementsSetObj")
    RETURN
999 ERRORS("OC_DataProjection_NumberOfClosestElementsSetObj",err,error)
    EXITS("OC_DataProjection_NumberOfClosestElementsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_NumberOfClosestElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_ProjectionTypeGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionType,err)
    !DLLEXPORT(OC_DataProjection_ProjectionTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get projection type for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionTypeGet(dataProjection,projectionType,err,error,*999)

    EXITS("OC_DataProjection_ProjectionTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ProjectionTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified an object.
  SUBROUTINE OC_DataProjection_ProjectionTypeGetObj(dataProjection,projectionType,err)
    !DLLEXPORT(OC_DataProjection_ProjectionTypeGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionTypeGetObj",err,error,*999)

    CALL DataProjection_ProjectionTypeGet(dataProjection%dataProjection,projectionType,err,error,*999)

    EXITS("OC_DataProjection_ProjectionTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ProjectionTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_ProjectionTypeSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,projectionType,err)
    !DLLEXPORT(OC_DataProjection_ProjectionTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ProjectionTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_ProjectionTypeSet(dataProjection,projectionType,err,error,*999)

    EXITS("OC_DataProjection_ProjectionTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ProjectionTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified an object.
  SUBROUTINE OC_DataProjection_ProjectionTypeSetObj(dataProjection,projectionType,err)
    !DLLEXPORT(OC_DataProjection_ProjectionTypeSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_ProjectionTypeSetObj",err,error,*999)

    CALL DataProjection_ProjectionTypeSet(dataProjection%dataProjection,projectionType,err,error,*999)

    EXITS("OC_DataProjection_ProjectionTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ProjectionTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ProjectionTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE OC_DataProjection_RelativeToleranceGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,relativeTolerance,err)
    !DLLEXPORT(OC_DataProjection_RelativeToleranceGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_RelativeToleranceGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_RelativeToleranceGet(dataProjection,relativeTolerance,err,error,*999)

    EXITS("OC_DataProjection_RelativeToleranceGetNumber")
    RETURN
999 ERRORS("OC_DataProjection_RelativeToleranceGetNumber",err,error)
    EXITS("OC_DataProjection_RelativeToleranceGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_RelativeToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE OC_DataProjection_RelativeToleranceGetObj(dataProjection,relativeTolerance,err)
    !DLLEXPORT(OC_DataProjection_RelativeToleranceGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_RelativeToleranceGetObj",err,error,*999)

    CALL DataProjection_RelativeToleranceGet(dataProjection%dataProjection,relativeTolerance,err,error,*999)

    EXITS("OC_DataProjection_RelativeToleranceGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_RelativeToleranceGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_RelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE OC_DataProjection_RelativeToleranceSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,relativeTolerance,err)
    !DLLEXPORT(OC_DataProjection_RelativeToleranceSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_RelativeToleranceSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_RelativeToleranceSet(dataProjection,relativeTolerance,err,error,*999)

    EXITS("OC_DataProjection_RelativeToleranceSetNumber")
    RETURN
999 ERRORS("OC_DataProjection_RelativeToleranceSetNumber",err,error)
    EXITS("OC_DataProjection_RelativeToleranceSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_RelativeToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE OC_DataProjection_RelativeToleranceSetObj(dataProjection,relativeTolerance,err)
    !DLLEXPORT(OC_DataProjection_RelativeToleranceSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_RelativeToleranceSetObj",err,error,*999)

    CALL DataProjection_RelativeToleranceSet(dataProjection%dataProjection,relativeTolerance,err,error,*999)

    EXITS("OC_DataProjection_RelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_RelativeToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_RelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified by a data projection user number and region user number.
  SUBROUTINE OC_DataProjection_StartingXiGetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,startingXi,err)
    !DLLEXPORT(OC_DataProjection_StartingXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to get the starting xi position for
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfStartingXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_StartingXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_StartingXiGet(dataProjection,dataPointGlobalNumber,numberOfStartingXi,startingXi,err,error,*999)

    EXITS("OC_DataProjection_StartingXiGetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_StartingXiGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_StartingXiGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified an object.
  SUBROUTINE OC_DataProjection_StartingXiGetObj(dataProjection,dataPointUserNumber,startingXi,err)
    !DLLEXPORT(OC_DataProjection_StartingXiGetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to get the starting xi position for
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfStartingXi
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_StartingXiGetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_StartingXiGet(dataProjection%dataProjection,dataPointGlobalNumber,numberOfStartingXi,startingXi, &
      & err,error,*999)

    EXITS("OC_DataProjection_StartingXiGetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_StartingXiGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_StartingXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_StartingXiSetNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,startingXi,err)
    !DLLEXPORT(OC_DataProjection_StartingXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to set the starting xi position for
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_StartingXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_StartingXiSet(dataProjection,dataPointGlobalNumber,startingXi,err,error,*999)

    EXITS("OC_DataProjection_StartingXiSetNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_StartingXiSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_StartingXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE OC_DataProjection_StartingXiSetObj(dataProjection,dataPointUserNumber,startingXi,err)
    !DLLEXPORT(OC_DataProjection_StartingXiSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to set the starting xi position for
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints

    ENTERS("OC_DataProjection_StartingXiSetObj",err,error,*999)

    NULLIFY(dataPoints)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_StartingXiSet(dataProjection%dataProjection,dataPointGlobalNumber,startingXi,err,error,*999)

    EXITS("OC_DataProjection_StartingXiSetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_StartingXiSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_StartingXiSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_ElementSetInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,dataPointUserNumber,elementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ElementSetInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<the element user number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,elementLocalNumber
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ElementSetInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,elementUserNumber,elementLocalNumber, &
      & ghostElement,err,error,*999)
    CALL DataProjection_ElementSet(dataProjection,dataPointGlobalNumber,elementLocalNumber,err,error,*999)

    EXITS("OC_DataProjection_ElementSetInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_ElementSetInterfaceNumber",err,error)
    EXITS("OC_DataProjection_ElementSetInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ElementSetInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_ElementSetRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,dataPointUserNumber,elementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ElementSetRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point user number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<the element user number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,elementLocalNumber
    LOGICAL :: ghostElement
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_ElementSetRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,elementUserNumber,elementLocalNumber, &
      & ghostElement,err,error,*999)
    CALL DataProjection_ElementSet(dataProjection,dataPointGlobalNumber,elementLocalNumber,err,error,*999)

    EXITS("OC_DataProjection_ElementSetRegionNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ElementSetRegionNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ElementSetRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE OC_DataProjection_ElementSetObj(dataProjection,dataPointUserNumber,elementUserNumber,err)
    !DLLEXPORT(OC_DataProjection_ElementSetObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<the element user number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,elementLocalNumber
    LOGICAL :: ghostElement
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_DataProjection_ElementSetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL DataProjection_DataPointsGet(dataProjection%dataProjection,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,dataPointUserNumber,dataPointGlobalNumber,err,error,*999)
    CALL DataProjection_DecompositionGet(dataProjection%dataProjection,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_LocalNumberGet(decompositionElements,elementUserNumber,elementLocalNumber, &
      & ghostElement,err,error,*999)
    CALL DataProjection_ElementSet(dataProjection%dataProjection,dataPointGlobalNumber,elementLocalNumber,err,error,*999)

    EXITS("OC_DataProjection_ElementSetObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_ElementSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_ElementSetObj

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelGetCInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelGetCInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelGetCInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelGetCInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_LabelGetCInterfaceNumber",err,error)
    EXITS("OC_DataProjection_LabelGetCInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelGetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelGetVSInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelGetVSInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelGetVSInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelGetVSInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_LabelGetVSInterfaceNumber",err,error)
    EXITS("OC_DataProjection_LabelGetVSInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelGetVSInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelGetCRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelGetCRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelGetCRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelGetCRegionNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelGetCRegionNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelGetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelGetVSRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelGetVSRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelGetVSRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelGet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelGetVSRegionNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelGetVSRegionNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelGetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Gets the character string label of a data projection identified an object.
  SUBROUTINE OC_DataProjection_LabelGetCObj(dataProjection,label,err)
    !DLLEXPORT(OC_DataProjection_LabelGetCObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_LabelGetCObj",err,error,*999)

    CALL DataProjection_LabelGet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Gets the varying string label of a data projection identified an object.
  SUBROUTINE OC_DataProjection_LabelGetVSObj(dataProjection,label,err)
    !DLLEXPORT(OC_DataProjection_LabelGetVSObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_LabelGetVSObj",err,error,*999)

    CALL DataProjection_LabelGet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelSetCInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelSetCInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelSetCInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelSetCInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_LabelSetCInterfaceNumber",err,error)
    EXITS("OC_DataProjection_LabelSetCInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelSetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelSetVSInterfaceNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & dataPointsUserNumber,dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelSetVSInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the interface.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionsType), POINTER :: regions
    TYPE(RegionType), POINTER :: parentRegion

    ENTERS("OC_DataProjection_LabelSetVSInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelSetVSInterfaceNumber")
    RETURN
999 ERRORS("OC_DataProjection_LabelSetVSInterfaceNumber",err,error)
    EXITS("OC_DataProjection_LabelSetVSInterfaceNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelSetVSInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelSetCRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelSetCRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelSetCRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelSetCRegionNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelSetCRegionNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelSetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE OC_DataProjection_LabelSetVSRegionNumber(contextUserNumber,regionUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,label,err)
    !DLLEXPORT(OC_DataProjection_LabelSetVSRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DataProjection_LabelSetVSRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL DataProjection_LabelSet(dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelSetVSRegionNumber")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelSetVSRegionNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelSetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified an object.
  SUBROUTINE OC_DataProjection_LabelSetCObj(dataProjection,label,err)
    !DLLEXPORT(OC_DataProjection_LabelSetCObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_LabelSetCObj",err,error,*999)

    CALL DataProjection_LabelSet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified an object.
  SUBROUTINE OC_DataProjection_LabelSetVSObj(dataProjection,label,err)
    !DLLEXPORT(OC_DataProjection_LabelSetVSObj)

    !Argument variables
    TYPE(OC_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DataProjection_LabelSetVSObj",err,error,*999)

    CALL DataProjection_LabelSet(dataProjection%dataProjection,label,err,error,*999)

    EXITS("OC_DataProjection_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_DataProjection_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DataProjection_LabelSetVSObj

!!==================================================================================================================================
!!
!! EquationsRoutines
!!
!!==================================================================================================================================

  !>Destroys equations for equations identified by a user number.
  SUBROUTINE OC_Equations_DestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_Equations_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_Destroy(equations,err,error,*999)

    EXITS("OC_Equations_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy equations for equations identified by an object.
  SUBROUTINE OC_Equations_DestroyObj(equations,err)
    !DLLEXPORT(OC_Equations_DestroyObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(INOUT) :: equations !<The equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_DestroyObj",err,error,*999)

    CALL Equations_Destroy(equations%equations,err,error,*999)

    EXITS("OC_Equations_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Equations_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_DestroyObj

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations distributed matrix from equations using the dynamic matrix index
  SUBROUTINE OC_Equations_DynamicMatrixGetObj(equations,matrixIndex,matrix,err)
    !DLLEXPORT(OC_Equations_DynamicMatrixGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: dynamicMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_DynamicMatrixGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(dynamicMatrices)
    NULLIFY(dynamicMatrix)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_DynamicMatricesExists(vectorMatrices,dynamicMatrices,err,error,*999)
    IF(ASSOCIATED(dynamicMatrices)) THEN
      CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,matrixIndex,dynamicMatrix,err,error,*999)
      CALL EquationsMatrix_DistributedMatrixGet(dynamicMatrix,matrix%distributedMatrix,err,error,*999)
    ELSE
      NULLIFY(matrix%distributedMatrix)
    ENDIF

    EXITS("OC_Equations_DynamicMatrixGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_DynamicMatrixGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_DynamicMatrixGetObj

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations distributed matrix from equations using the dynamic matrix type
  SUBROUTINE OC_Equations_DynamicMatrixGetByTypeObj(equations,matrixType,matrix,err)
    !DLLEXPORT(OC_Equations_DynamicMatrixGetByTypeObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixType !<The type of the dynamic matrix to get. \see OpenCMISS_EquationsDynamicMatrixTypes
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: matrixNumber
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesDynamicType), POINTER :: dynamicMatrices
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: dynamicMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_DynamicMatrixGetByTypeObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(dynamicMapping)
    NULLIFY(vectorMatrices)
    NULLIFY(dynamicMatrices)
    NULLIFY(dynamicMatrix)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_DynamicMappingExists(vectorMapping,dynamicMapping,err,error,*999)
    IF(ASSOCIATED(dynamicMatrices)) THEN
      CALL EquationsMappingDynamic_MatrixTypeNumberGet(dynamicMapping,matrixType,matrixNumber,err,error,*999)
      IF(matrixNumber/=0) THEN
        CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
        CALL EquationsMatricesVector_DynamicMatricesGet(vectorMatrices,dynamicMatrices,err,error,*999)
        CALL EquationsMatricesDynamic_EquationsMatrixGet(dynamicMatrices,matrixNumber,dynamicMatrix,err,error,*999)
        CALL EquationsMatrix_DistributedMatrixGet(dynamicMatrix,matrix%distributedMatrix,err,error,*999)
      ELSE
        NULLIFY(matrix%distributedMatrix)
      ENDIF
    ELSE
      NULLIFY(matrix%distributedMatrix)
    ENDIF

    EXITS("OC_Equations_DynamicMatrixGetByTypeObj")
    RETURN
999 ERRORSEXITS("OC_Equations_DynamicMatrixGetByTypeObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_DynamicMatrixGetByTypeObj

  !
  !================================================================================================================================
  !

  !>Get the type of a dynamic matrix from an equations set equations
  SUBROUTINE OC_Equations_DynamicMatrixTypeGetObj(equations,matrixIndex,matrixType,err)
    !DLLEXPORT(OC_Equations_DynamicMatrixTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix type from
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get the type of
    INTEGER(INTG), INTENT(OUT) :: matrixType !<On return, the dynamic matrix type. \see OpenCMISS_EquationsDynamicMatrixTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_DynamicMatrixTypeGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(dynamicMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_DynamicMappingExists(vectorMapping,dynamicMapping,err,error,*999)
    IF(ASSOCIATED(dynamicMapping)) THEN
      CALL EquationsMappingDynamic_MatrixTypeGet(dynamicMapping,matrixIndex,matrixType,err,error,*999)
    ELSE
      matrixType=0
      CALL FlagError("The specified equations do not contain any dynamic matrices.",err,error,*999)
    ENDIF

    EXITS("OC_Equations_DynamicMatrixTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_DynamicMatrixTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_DynamicMatrixTypeGetObj

  !
  !================================================================================================================================
  !

  !>Setting Jacobian matrix calculation type for a matrix specified by user numbers.
  SUBROUTINE OC_Equations_JacobianCalculationTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & variableType,residualIndex,jacobianCalculationType,err)
    !DLLEXPORT(OC_Equations_JacobianCalculationTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations to set the Jacobian calculation type for
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The type of Jacobian calculation. \see OpenCMISS_EquationsJacobianCalculated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_JacobianCalculationTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianCalculationTypeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianCalculationType,err,error,*999)

    EXITS("OC_Equations_JacobianCalculationTypeSetNumber")
    RETURN
999 ERRORS("OC_Equations_JacobianCalculationTypeSetNumber",err,error)
    EXITS("OC_Equations_JacobianCalculationTypeSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_JacobianCalculationTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Setting Jacobian matrix calculation type for a matrix specified by obj.
  SUBROUTINE OC_Equations_JacobianCalculationTypeSetObj(equations,variableType,residualIndex,jacobianCalculationType,err)
    !DLLEXPORT(OC_Equations_JacobianCalculationTypeSetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to set the Jacobian evaluation type for. 
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The type of Jacobian calculation. \see OpenCMISS_EquationsJacobianCalculated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices

    ENTERS("OC_Equations_JacobianCalculationTypeSetObj",err,error,*999)

    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianCalculationTypeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianCalculationType,err,error,*999)

    EXITS("OC_Equations_JacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("OC_Equations_JacobianCalculationTypeSetObj",err,error)
    EXITS("OC_Equations_JacobianCalculationTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_JacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets the Jacobian matrix finite difference step size type for a matrix specified by user numbers.
  SUBROUTINE OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & variableType,residualIndex,jacobianFiniteDifferenceStepSize,err)
    !DLLEXPORT(OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations to set the Jacobian calculation type for
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    REAL(DP), INTENT(IN) :: jacobianFiniteDifferenceStepSize !<The finite difference step size to calculate the Jacobian with.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_VectorEquationsGet(equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianFiniteDifferenceStepSizeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianFiniteDifferenceStepSize,err,error,*999)

    EXITS("OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber")
    RETURN
999 ERRORS("OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber",err,error)
    EXITS("OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_JacobianFiniteDifferenceStepSizeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the finite difference step size used for calculating the Jacobian
  SUBROUTINE OC_Equations_JacobianFiniteDifferenceStepSizeSetObj(equations,variableType,residualIndex, &
    & jacobianFiniteDifferenceStepSize,err)
    !DLLEXPORT(OC_Equations_JacobianFiniteDifferenceStepSizeSetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to set the Jacobian finite difference step size for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector of the Jacobian
    REAL(DP), INTENT(IN) :: jacobianFiniteDifferenceStepSize !<The finite difference step size to calculate the Jacobian with.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices

    ENTERS("OC_Equations_JacobianFiniteDifferenceStepSizeSetObj",err,error,*999)

    NULLIFY(vectorEquations)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    NULLIFY(vectorMatrices)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_JacobianFiniteDifferenceStepSizeSet(vectorMatrices,variableType,residualIndex, &
      & jacobianFiniteDifferenceStepSize,err,error,*999)

    EXITS("OC_Equations_JacobianFiniteDifferenceStepSizeSetObj")
    RETURN
999 ERRORS("OC_Equations_JacobianFiniteDifferenceStepSizeSetObj",err,error)
    EXITS("OC_Equations_JacobianFiniteDifferenceStepSizeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_JacobianFiniteDifferenceStepSizeSetObj

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix distributed matrix for a specified residual and variable indices from equations
  SUBROUTINE OC_Equations_JacobianMatrixGetByNumberObj(equations,residualIndex,variableIndex,matrix,err)
    !DLLEXPORT(OC_Equations_JacobianMatrixGetByNumberObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: variableIndex !<The index of the residual variable to get the Jacobian matrix for
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix distributed matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix

    ENTERS("OC_Equations_JacobianMatrixGetByNumberObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(nonlinearMatrices)
    NULLIFY(residualVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_NonlinearMatricesExists(vectorMatrices,nonlinearMatrices,err,error,*999)
    IF(ASSOCIATED(nonlinearMatrices)) THEN
      CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,residualIndex,residualVector,err,error,*999)
      CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,variableIndex,jacobianMatrix,err,error,*999)
      CALL JacobianMatrix_DistributedMatrixGet(jacobianMatrix,matrix%distributedMatrix,err,error,*999)
    ELSE
      CALL FlagError("The specified equations do not contain any nonlinear matrices.",err,error,*999)
    ENDIF

    EXITS("OC_Equations_JacobianMatrixGetByNumberObj")
    RETURN
999 ERRORSEXITS("OC_Equations_JacobianMatrixGetByNumberObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_JacobianMatrixGetByNumberObj

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix distributed matrix for a specified residual index and variable type from an equations
  SUBROUTINE OC_Equations_JacobianMatrixGetByTypeObj(equations,residualIndex,variableType,matrix,err)
    !DLLEXPORT(OC_Equations_JacobianMatrixGetByTypeObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type in the residual is differentiated with respect to for this Jacobian. \see OpenCMISS_FieldVariableTypes
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: variableIndex
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(JacobianMatrixType), POINTER :: jacobianMatrix

    ENTERS("OC_Equations_JacobianMatrixGetByTypeObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    NULLIFY(vectorMatrices)
    NULLIFY(nonlinearMatrices)
    NULLIFY(residualVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_VariableIndexGet(residualMapping,variableType,variableIndex,err,error,*999)
      IF(variableIndex/=0) THEN
        CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
        CALL EquationsMatricesVector_NonlinearMatricesExists(vectorMatrices,nonlinearMatrices,err,error,*999)
        CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,residualIndex,residualVector,err,error,*999)
        CALL EquationsMatricesResidual_JacobianMatrixGet(residualVector,variableIndex,jacobianMatrix,err,error,*999)
        CALL JacobianMatrix_DistributedMatrixGet(jacobianMatrix,matrix%distributedMatrix,err,error,*999)
      ELSE
        NULLIFY(matrix%distributedMatrix)
      ENDIF
    ELSE
      CALL FlagError("The specified equations do not contain any nonlinear matrices.",err,error,*999)
    ENDIF

    EXITS("OC_Equations_JacobianMatrixGetByTypeObj")
    RETURN
999 ERRORSEXITS("OC_Equations_JacobianMatrixGetByTypeObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_JacobianMatrixGetByTypeObj

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by a user number.
  SUBROUTINE OC_Equations_LinearityTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,linearityType,err)
    !DLLEXPORT(OC_Equations_LinearityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OpenCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_LinearityTypeGet(equations,linearityType,err,error,*999)

    EXITS("OC_Equations_LinearityTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_LinearityTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by an object.
  SUBROUTINE OC_Equations_LinearityTypeGetObj(equations,linearityType,err)
    !DLLEXPORT(OC_Equations_LinearityTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OpenCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_LinearityTypeGetObj",err,error,*999)

    CALL Equations_LinearityTypeGet(equations%equations,linearityType,err,error,*999)

    EXITS("OC_Equations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_LinearityTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get a linear equations distributed matrix from the equations
  SUBROUTINE OC_Equations_LinearMatrixGetObj(equations,matrixIndex,matrix,err)
    !DLLEXPORT(OC_Equations_LinearMatrixGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the linear matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the linear matrix to get
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested linear matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesLinearType), POINTER :: linearMatrices
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsMatrixType), POINTER :: linearMatrix
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_LinearMatrixGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(linearMatrices)
    NULLIFY(linearMatrix)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_LinearMatricesExists(vectorMatrices,linearMatrices,err,error,*999)
    IF(ASSOCIATED(linearMatrices)) THEN
      CALL EquationsMatricesLinear_EquationsMatrixGet(linearMatrices,matrixIndex,linearMatrix,err,error,*999)
      CALL EquationsMatrix_DistributedMatrixGet(linearMatrix,matrix%distributedMatrix,err,error,*999)
    ELSE
      NULLIFY(matrix%distributedMatrix)
    ENDIF

    EXITS("OC_Equations_LinearMatrixGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_LinearMatrixGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LinearMatrixGetObj

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by a user number.
  SUBROUTINE OC_Equations_LumpingTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,lumpingType,err)
    !DLLEXPORT(OC_Equations_LumpingTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_LumpingTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_LumpingTypeGet(equations,lumpingType,err,error,*999)

    EXITS("OC_Equations_LumpingTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_LumpingTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LumpingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by an object.
  SUBROUTINE OC_Equations_LumpingTypeGetObj(equations,lumpingType,err)
    !DLLEXPORT(OC_Equations_LumpingTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_LumpingTypeGetObj",err,error,*999)

    CALL Equations_LumpingTypeGet(equations%equations,lumpingType,err,error,*999)

    EXITS("OC_Equations_LumpingTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_LumpingTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LumpingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by a user number.
  SUBROUTINE OC_Equations_LumpingTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,lumpingType,err)
    !DLLEXPORT(OC_Equations_LumpingTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_LumpingTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_LumpingTypeSet(equations,lumpingType,err,error,*999)

    EXITS("OC_Equations_LumpingTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_LumpingTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LumpingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by an object.
  SUBROUTINE OC_Equations_LumpingTypeSetObj(equations,lumpingType,err)
    !DLLEXPORT(OC_Equations_LumpingTypeSetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(INOUT) :: equations !<The equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OpenCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_LumpingTypeSetObj",err,error,*999)

    CALL Equations_LumpingTypeSet(equations%equations,lumpingType,err,error,*999)

    EXITS("OC_Equations_LumpingTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_LumpingTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_LumpingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Get the number of dynamic matrices in the equations
  SUBROUTINE OC_Equations_NumberOfDynamicMatricesGetObj(equations,numberOfMatrices,err)
    !DLLEXPORT(OC_Equations_NumberOfDynamicMatricesGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the number of dynamic matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of dynamic matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingDynamicType), POINTER :: dynamicMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_NumberOfDynamicMatricesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(dynamicMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_DynamicMappingExists(vectorMapping,dynamicMapping,err,error,*999)
    IF(ASSOCIATED(dynamicMapping)) THEN
      CALL EquationsMappingDynamic_NumberOfDynamicMatricesGet(dynamicMapping,numberOfMatrices,err,error,*999)
    ELSE
      numberOfMatrices=0
    ENDIF

    EXITS("OC_Equations_NumberOfDynamicMatricesGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_NumberOfDynamicMatricesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_NumberOfDynamicMatricesGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of Jacobian matrices in a residual vector in the equations
  SUBROUTINE OC_Equations_NumberOfJacobianMatricesGetObj(equations,residualNumber,numberOfMatrices,err)
    !DLLEXPORT(OC_Equations_NumberOfJacobianMatricesGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(IN) :: residualNumber !<The residual number to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of Jacobian matrices for the residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_NumberOfJacobianMatricesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualNumber,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_NumberOfJacobianMatricesGet(residualMapping,numberOfMatrices,err,error,*999)
    ELSE
      numberOfMatrices=0
    ENDIF

    EXITS("OC_Equations_NumberOfJacobianMatricesGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_NumberOfJacobianMatricesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_NumberOfJacobianMatricesGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of linear matrices in the equations
  SUBROUTINE OC_Equations_NumberOfLinearMatricesGetObj(equations,numberOfMatrices,err)
    !DLLEXPORT(OC_Equations_NumberOfLinearMatricesGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the number of linear matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of linear matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingLinearType), POINTER :: linearMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_NumberOfLinearMatricesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(linearMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_LinearMappingExists(vectorMapping,linearMapping,err,error,*999)
    IF(ASSOCIATED(linearMapping)) THEN
      CALL EquationsMappingLinear_NumberOfLinearMatricesGet(linearMapping,numberOfMatrices,err,error,*999)
    ELSE
      numberOfMatrices=0
    ENDIF

    EXITS("OC_Equations_NumberOfLinearMatricesGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_NumberOfLinearMatricesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_NumberOfLinearMatricesGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of residual vectors in the equations
  SUBROUTINE OC_Equations_NumberOfResidualVectorsGetObj(equations,numberOfVectors,err)
    !DLLEXPORT(OC_Equations_NumberOfResidualVectorsGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the number of residual vectors for
    INTEGER(INTG), INTENT(OUT) :: numberOfVectors !<On return, the number of residual vectors in the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_NumberOfResidualVectorsGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_NumberOfResidualsGet(nonlinearMapping,numberOfVectors,err,error,*999)
    ELSE
      numberOfVectors=0
    ENDIF

    EXITS("OC_Equations_NumberOfResidualVectorsGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_NumberOfResidualVectorsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_NumberOfResidualVectorsGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of source vectors in the equations
  SUBROUTINE OC_Equations_NumberOfSourceVectorsGetObj(equations,numberOfVectors,err)
    !DLLEXPORT(OC_Equations_NumberOfSourceVectorsGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the number of source vectors for
    INTEGER(INTG), INTENT(OUT) :: numberOfVectors !<On return, the number of source vectors in the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingSourcesType), POINTER :: sourcesMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_NumberOfSourceVectorsGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(sourcesMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_SourcesMappingExists(vectorMapping,sourcesMapping,err,error,*999)
    IF(ASSOCIATED(sourcesMapping)) THEN
      CALL EquationsMappingSources_NumberOfSourcesGet(sourcesMapping,numberOfVectors,err,error,*999)
    ELSE
      numberOfVectors=0
    ENDIF

    EXITS("OC_Equations_NumberOfSourceVectorsGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_NumberOfSourceVectorsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_NumberOfSourceVectorsGetObj

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by a user number.
  SUBROUTINE OC_Equations_OutputTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(OC_Equations_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_OutputTypeGet(equations,outputType,err,error,*999)

    EXITS("OC_Equations_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_OutputTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by an object.
  SUBROUTINE OC_Equations_OutputTypeGetObj(equations,outputType,err)
    !DLLEXPORT(OC_Equations_OutputTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_OutputTypeGetObj",err,error,*999)

    CALL Equations_OutputTypeGet(equations%equations,outputType,err,error,*999)

    EXITS("OC_Equations_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_OutputTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by a user number.
  SUBROUTINE OC_Equations_OutputTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(OC_Equations_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_OutputTypeSet(equations,outputType,err,error,*999)

    EXITS("OC_Equations_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_OutputTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by an object.
  SUBROUTINE OC_Equations_OutputTypeSetObj(equations,outputType,err)
    !DLLEXPORT(OC_Equations_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(INOUT) :: equations !<The equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OpenCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_OutputTypeSetObj",err,error,*999)

    CALL Equations_OutputTypeSet(equations%equations,outputType,err,error,*999)

    EXITS("OC_Equations_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Get the number of field variables that contribute to the residual vector
  SUBROUTINE OC_Equations_ResidualNumberOfVariablesGetObj(equations,residualIndex,numberOfVariables,err)
    !DLLEXPORT(OC_Equations_ResidualNumberOfVariablesGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector number of variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the number of variables for
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables that contribute to the residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_ResidualNumberOfVariablesGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_NumberOfResidualVariablesGet(residualMapping,numberOfVariables,err,error,*999)
    ELSE
      numberOfVariables=0
    ENDIF

    EXITS("OC_Equations_ResidualNumberOfVariablesGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_ResidualNumberOfVariablesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_ResidualNumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Get the field variable type in a residual vector
  SUBROUTINE OC_Equations_ResidualVariableTypeGetObj(equations,residualIndex,variableIndex,residualVariableType,err)
    !DLLEXPORT(OC_Equations_ResidualVariableTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the variable type for
    INTEGER(INTG), INTENT(IN) :: variableIndex !<The index of the variable in the residual vector to get the variable type for
    INTEGER(INTG), INTENT(OUT) :: residualVariableType !<On return, the field variable type for the variableIndex'th residual variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_ResidualVariableTypeGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_VariableTypeGet(residualMapping,variableIndex,residualVariableType,err,error,*999)
    ELSE
      residualVariableType=0
    ENDIF

    EXITS("OC_Equations_ResidualVariableTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_ResidualVariableTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_ResidualVariableTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the field variables that contribute to the residual vector
  SUBROUTINE OC_Equations_ResidualVariableTypesGetObj(equations,residualIndex,residualVariableTypes,err)
    !DLLEXPORT(OC_Equations_ResidualVariableTypesGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the variables for
    INTEGER(INTG), INTENT(OUT) :: residualVariableTypes(:) !<residualVariableTypes(varIdx). On return, the field variable type for the varIdx'th residual variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: numberOfVariables,variableIdx
    TYPE(EquationsMappingNonlinearType), POINTER :: nonlinearMapping
    TYPE(EquationsMappingResidualType), POINTER :: residualMapping
    TYPE(EquationsMappingVectorType), POINTER :: vectorMapping
    TYPE(EquationsVectorType), POINTER :: vectorEquations
    TYPE(VARYING_STRING) :: localError

    ENTERS("OC_Equations_ResidualVariableTypesGetObj",err,error,*999)

    residualVariableTypes=0
    NULLIFY(vectorEquations)
    NULLIFY(vectorMapping)
    NULLIFY(nonlinearMapping)
    NULLIFY(residualMapping)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMappingGet(vectorEquations,vectorMapping,err,error,*999)
    CALL EquationsMappingVector_NonlinearMappingExists(vectorMapping,nonlinearMapping,err,error,*999)
    IF(ASSOCIATED(nonlinearMapping)) THEN
      CALL EquationsMappingNonlinear_ResidualMappingGet(nonlinearMapping,residualIndex,residualMapping,err,error,*999)
      CALL EquationsMappingResidual_NumberOfResidualVariablesGet(residualMapping,numberOfVariables,err,error,*999)
      IF(SIZE(residualVariableTypes,1)<numberOfVariables) THEN
        localError="The size of the specified residual variable types array of "// &
          & TRIM(NumberToVString(SIZE(residualVariableTypes,1),"*",err,error))// &
          & " is too small. The size of the residual variable types array should be >= "// &
          & TRIM(NumberToVString(numberOfVariables,"*",err,error))//" for residual number "// &
          & TRIM(NumberToVString(residualIndex,"*",err,error))//" of the equations."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      DO variableIdx=1,numberOfVariables
        CALL EquationsMappingResidual_VariableTypeGet(residualMapping,variableIdx,residualVariableTypes(variableIdx), &
          & err,error,*999)
      ENDDO !variableIdx
    ENDIF

    EXITS("OC_Equations_ResidualVariableTypesGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_ResidualVariableTypesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_ResidualVariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Get a residual distributed vector for equations
  SUBROUTINE OC_Equations_ResidualVectorGetObj(equations,residualIndex,vector,err)
    !DLLEXPORT(OC_Equations_ResidualVectorGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get
    TYPE(OC_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the residual distributed vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesNonlinearType), POINTER :: nonlinearMatrices
    TYPE(EquationsMatricesResidualType), POINTER :: residualVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_ResidualVectorGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(nonlinearMatrices)
    NULLIFY(residualVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_NonlinearMatricesExists(vectorMatrices,nonlinearMatrices,err,error,*999)
    IF(ASSOCIATED(nonlinearMatrices)) THEN
      CALL EquationsMatricesNonlinear_ResidualVectorGet(nonlinearMatrices,residualIndex,residualVector,err,error,*999)
      CALL EquationsMatricesResidual_DistributedVectorGet(residualVector,EQUATIONS_MATRICES_CURRENT_VECTOR, &
        & vector%distributedVector,err,error,*999)
    ELSE
      NULLIFY(vector%distributedVector)
    ENDIF

    EXITS("OC_Equations_ResidualVectorGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_ResidualVectorGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_ResidualVectorGetObj

  !
  !================================================================================================================================
  !

  !>Get the right hand side distributed vector for equations
  SUBROUTINE OC_Equations_RHSVectorGetObj(equations,vector,err)
    !DLLEXPORT(OC_Equations_RHSVectorGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the right hand side vector for
    TYPE(OC_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the right hand side distributed vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesRHSType), POINTER :: rhsVector
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_RHSVectorGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(rhsVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_RHSVectorExists(vectorMatrices,rhsVector,err,error,*999)
    IF(ASSOCIATED(rhsVector)) THEN
      CALL EquationsMatricesRHS_DistributedVectorGet(rhsVector,EQUATIONS_MATRICES_CURRENT_VECTOR,vector%distributedVector, &
        & err,error,*999)
    ELSE
      NULLIFY(vector%distributedVector)
    ENDIF

    EXITS("OC_Equations_RHSVectorGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_RHSVectorGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_RHSVectorGetObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by a user number.
  SUBROUTINE OC_Equations_SparsityTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,sparsityType,err)
    !DLLEXPORT(OC_Equations_SparsityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_SparsityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_SparsityTypeGet(equations,sparsityType,err,error,*999)

    EXITS("OC_Equations_SparsityTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_SparsityTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_SparsityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by an object.
  SUBROUTINE OC_Equations_SparsityTypeGetObj(equations,sparsityType,err)
    !DLLEXPORT(OC_Equations_SparsityTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_SparsityTypeGetObj",err,error,*999)

    CALL Equations_SparsityTypeGet(equations%equations,sparsityType,err,error,*999)

    EXITS("OC_Equations_SparsityTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_SparsityTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_SparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by a user number.
  SUBROUTINE OC_Equations_SparsityTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,sparsityType,err)
    !DLLEXPORT(OC_Equations_SparsityTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_SparsityTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_SparsityTypeSet(equations,sparsityType,err,error,*999)

    EXITS("OC_Equations_SparsityTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_SparsityTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_SparsityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by an object.
  SUBROUTINE OC_Equations_SparsityTypeSetObj(equations,sparsityType,err)
    !DLLEXPORT(OC_Equations_SparsityTypeSetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(INOUT) :: equations !<The equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OpenCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_SparsityTypeSetObj",err,error,*999)

    CALL Equations_SparsityTypeSet(equations%equations,sparsityType,err,error,*999)

    EXITS("OC_Equations_SparsityTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_SparsityTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Get the source distributed vector for equations
  SUBROUTINE OC_Equations_SourceVectorGetObj(equations,sourceIndex,vector,err)
    !DLLEXPORT(OC_Equations_SourceVectorGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the source vector for
    INTEGER(INTG), INTENT(IN) :: sourceIndex !<The index of the source vector to get the distributed vector for
    TYPE(OC_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the source distributed vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(EquationsMatricesSourceType), POINTER :: sourceVector
    TYPE(EquationsMatricesSourcesType), POINTER :: sourceVectors
    TYPE(EquationsMatricesVectorType), POINTER :: vectorMatrices
    TYPE(EquationsVectorType), POINTER :: vectorEquations

    ENTERS("OC_Equations_SourceVectorGetObj",err,error,*999)

    NULLIFY(vectorEquations)
    NULLIFY(vectorMatrices)
    NULLIFY(sourceVectors)
    NULLIFY(sourceVector)
    CALL Equations_VectorEquationsGet(equations%equations,vectorEquations,err,error,*999)
    CALL EquationsVector_VectorMatricesGet(vectorEquations,vectorMatrices,err,error,*999)
    CALL EquationsMatricesVector_SourceVectorsExists(vectorMatrices,sourceVectors,err,error,*999)
    IF(ASSOCIATED(sourceVectors)) THEN
      CALL EquationsMatricesSources_SourceVectorGet(sourceVectors,sourceIndex,sourceVector,err,error,*999)
      CALL EquationsMatricesSource_DistributedVectorGet(sourceVector,EQUATIONS_MATRICES_CURRENT_VECTOR,vector%distributedVector, &
        & err,error,*999)
    ELSE
      NULLIFY(vector%distributedVector)
    ENDIF

    EXITS("OC_Equations_SourceVectorGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_SourceVectorGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_SourceVectorGetObj

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by a user number.
  SUBROUTINE OC_Equations_TimeDependenceTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & timeDependenceType,err)
    !DLLEXPORT(OC_Equations_TimeDependenceTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OpenCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Equations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsGet(equationsSet,equations,err,error,*999)
    CALL Equations_TimeDependenceTypeGet(equations,timeDependenceType,err,error,*999)

    EXITS("OC_Equations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Equations_TimeDependenceTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by an object.
  SUBROUTINE OC_Equations_TimeDependenceTypeGetObj(equations,timeDependenceType,err)
    !DLLEXPORT(OC_Equations_TimeDependenceTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsType), INTENT(IN) :: equations !<The equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OpenCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Equations_TimeDependenceTypeGetObj",err,error,*999)

    CALL Equations_TimeDependenceTypeGet(equations%equations,timeDependenceType,err,error,*999)

    EXITS("OC_Equations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Equations_TimeDependenceTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Equations_TimeDependenceTypeGetObj

!!==================================================================================================================================
!!
!! EquationsSetRoutines
!!
!!==================================================================================================================================

  !>Finish the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_AnalyticCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticCreateFinishNumber")
    RETURN
999 ERRORS("OC_EquationsSet_AnalyticCreateFinishNumber",err,error)
    EXITS("OC_EquationsSet_AnalyticCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a analytic solution for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_AnalyticCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticCreateFinishObj",err,error,*999)

    CALL EquationsSet_AnalyticCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_AnalyticCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & analyticFunctionType,analyticFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OpenCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: analyticField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(analyticField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(analyticFieldUserNumber,region,analyticField,err,error,*999)
    CALL EquationsSet_AnalyticCreateStart(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField, &
      & err,error,*999)

    EXITS("OC_EquationsSet_AnalyticCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an analytic solution for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_AnalyticCreateStartObj(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the analytic creation on.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OpenCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    TYPE(OC_FieldType), INTENT(INOUT) :: analyticField !<If associated on entry, the user created analytic field which has the same user number as the specified analytic field user number. If not associated on entry, on return, the created analytic field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticCreateStartObj",err,error,*999)

    CALL EquationsSet_AnalyticCreateStart(equationsSet%equationsSet,analyticFunctionType,analyticFieldUserNumber, &
      & analyticField%field,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_AnalyticDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_AnalyticDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the analytic for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticDestroyObj",err,error,*999)

    CALL EquationsSet_AnalyticDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticDestroyObj


  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_AnalyticEvaluateNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticEvaluateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to evaluate.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticEvaluateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticEvaluate(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticEvaluateNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticEvaluateNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_AnalyticEvaluateObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticEvaluateObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to evaluate the current analytic solution for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticEvaluateObj",err,error,*999)

    CALL EquationsSet_AnalyticEvaluate(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticEvaluateObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticEvaluateObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_AnalyticTimeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,time,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticTimeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticTimeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticTimeGet(equationsSet,time,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticTimeGetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticTimeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticTimeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_AnalyticTimeGetObj(equationsSet,time,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticTimeGetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the analytic time for.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticTimeGetObj",err,error,*999)

    CALL EquationsSet_AnalyticTimeGet(equationsSet%equationsSet,time,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticTimeGetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticTimeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticTimeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_AnalyticTimeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,time,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticTimeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticTimeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticTimeSet(equationsSet,time,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticTimeSetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticTimeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticTimeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_AnalyticTimeSetObj(equationsSet,time,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticTimeSetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic time for.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticTimeSetObj",err,error,*999)

    CALL EquationsSet_AnalyticTimeSet(equationsSet%equationsSet,time,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticTimeSetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticTimeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticTimeSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE OC_EquationsSet_AnalyticUserParamSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & paramIdx,param,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticUserParamSetNumber)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticUserParamSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticUserParamSet(equationsSet,paramIdx,param,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticUserParamSetNumber")
    RETURN
999 ERRORS("OC_EquationsSet_AnalyticUserParamSetNumber",err,error)
    EXITS("OC_EquationsSet_AnalyticUserParamSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticUserParamSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE OC_EquationsSet_AnalyticUserParamSetObj(equationsSet,paramIdx,param,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticUserParamSetObj)
    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticUserParamSetObj",err,error,*999)

    CALL EquationsSet_AnalyticUserParamSet(equationsSet%equationsSet,paramIdx,param,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticUserParamSetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticUserParamSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticUserParamSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE OC_EquationsSet_AnalyticUserParamGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & paramIdx,param,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticUserParamGetNumber)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_AnalyticUserParamGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_AnalyticUserParamGet(equationsSet,paramIdx,param,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticUserParamGetNumber")
    RETURN
999 ERRORS("OC_EquationsSet_AnalyticUserParamGetNumber",err,error)
    EXITS("OC_EquationsSet_AnalyticUserParamGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticUserParamGetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE OC_EquationsSet_AnalyticUserParamGetObj(equationsSet,paramIdx,param,err)
    !DLLEXPORT(OC_EquationsSet_AnalyticUserParamGetObj)
    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_AnalyticUserParamGetObj",err,error,*999)

    CALL EquationsSet_AnalyticUserParamGet(equationsSet%equationsSet,paramIdx,param,err,error,*999)

    EXITS("OC_EquationsSet_AnalyticUserParamGetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_AnalyticUserParamGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_AnalyticUserParamGetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_CreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_CreateFinish(equationsSet,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    EXITS("OC_EquationsSet_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_CreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_CreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_CreateFinishObj",err,error,*999)

    CALL EquationsSet_CreateFinish(equationsSet%equationsSet,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    EXITS("OC_EquationsSet_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_CreateStartNumber(equationsSetUserNumber,contextUserNumber,regionUserNumber,&
    & geomFibreFieldUserNumber,equationsSetSpecification,equationsSetFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of an equations set on.
    INTEGER(INTG), INTENT(IN) :: geomFibreFieldUserNumber !<The user number of the Geometric/Fibre field for the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetSpecification(:) !<The equations set specification array, containing the equations class, type etc
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: geometryFibreField,equationsSetField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(geometryFibreField)
    NULLIFY(equationsSetField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,geomFibreFieldUserNumber,geometryFibreField,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(equationsSetFieldUserNumber,region,equationsSetField,err,error,*999)
    CALL EquationsSet_CreateStart(equationsSetUserNumber,region,geometryFibreField,&
      & equationsSetSpecification,equationsSetFieldUserNumber,&
      & equationsSetField,equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_CreateStartObj(equationsSetUserNumber,region,geomFibreField,&
    & equationsSetSpecification,equationsSetFieldUserNumber,&
    & equationsSetFieldField,equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to create the equations set on.
    TYPE(OC_FieldType), INTENT(IN) :: geomFibreField !<The Geometric/Fibre field for the creation of the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetSpecification(:) !<The equations set specification array, containing the equations class, type etc
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    TYPE(OC_FieldType), INTENT(INOUT) :: equationsSetFieldField !<On return, a pointer to the equations set field
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<On return, the created equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_CreateStartObj",err,error,*999)

    CALL EquationsSet_CreateStart(equationsSetUserNumber,region%region,geomFibreField%field, &
      & equationsSetSpecification,equationsSetFieldUserNumber,equationsSetFieldField%field, &
      & equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of derived variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DerivedCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DerivedCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DerivedCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DerivedCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of derived variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DerivedCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_DerivedCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DerivedCreateFinishObj",err,error,*999)

    CALL EquationsSet_DerivedCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DerivedCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of derived variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DerivedCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DerivedCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to start the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: derivedFieldUserNumber !<The user number of the derived field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: derivedField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DerivedCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(derivedField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(derivedFieldUserNumber,region,derivedField,err,error,*999)
    CALL EquationsSet_DerivedCreateStart(equationsSet,derivedFieldUserNumber,derivedField,err,error,*999)

    EXITS("OC_EquationsSet_DerivedCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of derived variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DerivedCreateStartObj(equationsSet,derivedFieldUserNumber,derivedField,err)
    !DLLEXPORT(OC_EquationsSet_DerivedCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of derived variables on.
    INTEGER(INTG), INTENT(IN) :: derivedFieldUserNumber !<The user number of the derived field.
    TYPE(OC_FieldType), INTENT(INOUT) :: derivedField !<If associated on entry, the user created derived field which has the same user number as the specified derived field user number. If not associated on entry, on return, the created derived field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DerivedCreateStartObj",err,error,*999)

    CALL EquationsSet_DerivedCreateStart(equationsSet%equationsSet,derivedFieldUserNumber,derivedField%field, &
      & err,error,*999)

    EXITS("OC_EquationsSet_DerivedCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the derived variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DerivedDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DerivedDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DerivedDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DerivedDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the derived variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DerivedDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_DerivedDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DerivedDestroyObj",err,error,*999)

    CALL EquationsSet_DerivedDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DerivedDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedDestroyObj

  !
  !================================================================================================================================
  !

  !>Calculates a derived field value for the equations set and stores the result in the derived field previously set up
  SUBROUTINE OC_EquationsSet_DerivedVariableCalculateNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,err)
    !DLLEXPORT(OC_EquationsSet_DerivedVariableCalculateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived variable type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DerivedVariableCalculateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedVariableCalculate(equationsSet,derivedTensorType,err,error,*999)

    EXITS("OC_EquationsSet_DerivedVariableCalculateNumber")
    RETURN
999 ERRORS("OC_EquationsSet_DerivedVariableCalculateNumber",err,error)
    EXITS("OC_EquationsSet_DerivedVariableCalculateNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedVariableCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates a derived field value for the equations set and stores the result in the derived field previously set up
  SUBROUTINE OC_EquationsSet_DerivedVariableCalculateObj(equationsSet,derivedTensorType,err)
    !DLLEXPORT(OC_EquationsSet_DerivedVariableCalculateObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived field tensor type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_EquationsSet_DerivedVariableCalculateObj",err,error,*999)

    CALL EquationsSet_DerivedVariableCalculate(equationsSet%equationsSet,derivedTensorType,err,error,*999)

    EXITS("OC_EquationsSet_DerivedVariableCalculateObj")
    RETURN
999 ERRORS("OC_EquationsSet_DerivedVariableCalculateObj",err,error)
    EXITS("OC_EquationsSet_DerivedVariableCalculateObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedVariableCalculateObj

  !
  !================================================================================================================================
  !

  !>Sets the field variable type of the derived field to be used to store a derived variable
  SUBROUTINE OC_EquationsSet_DerivedVariableSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,fieldVarType,err)
    !DLLEXPORT(OC_EquationsSet_DerivedVariableSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived variable tensor type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to store the calculated values in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DerivedVariableSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DerivedVariableSet(equationsSet,derivedTensorType,fieldVarType,err,error,*999)

    EXITS("OC_EquationsSet_DerivedVariableSetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedVariableSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedVariableSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the field variable type of the derived field to be used to store a derived variable
  SUBROUTINE OC_EquationsSet_DerivedVariableSetObj(equationsSet,derivedTensorType,fieldVarType,err)
    !DLLEXPORT(OC_EquationsSet_DerivedVariableSetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The derived field type to calculate. \see OpenCMISS_EquationsSetDerivedTensorTypes.
    INTEGER(INTG), INTENT(IN) :: fieldVarType !<The field variable type to store the calculated values in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_EquationsSet_DerivedVariableSetObj",err,error,*999)

    CALL EquationsSet_DerivedVariableSet(equationsSet%equationsSet,derivedTensorType,fieldVarType,err,error,*999)

    EXITS("OC_EquationsSet_DerivedVariableSetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DerivedVariableSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DerivedVariableSetObj

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destory.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_Destroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_DestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DestroyObj",err,error,*999)

    CALL EquationsSet_Destroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DependentCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DependentCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DependentCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DependentCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DependentCreateFinishNumber")
    RETURN
999 ERRORS("OC_EquationsSet_DependentCreateFinishNumber",err,error)
    EXITS("OC_EquationsSet_DependentCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DependentCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_DependentCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DependentCreateFinishObj",err,error,*999)

    CALL EquationsSet_DependentCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DependentCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DependentCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DependentCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & dependentFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DependentCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: dependentField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DependentCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(dependentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(dependentFieldUserNumber,region,dependentField,err,error,*999)
    CALL EquationsSet_DependentCreateStart(equationsSet,dependentFieldUserNumber,dependentField,err,error,*999)

    EXITS("OC_EquationsSet_DependentCreateStartNumber")
    RETURN
999 ERRORS("OC_EquationsSet_DependentCreateStartNumber",err,error)
    EXITS("OC_EquationsSet_DependentCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DependentCreateStartObj(equationsSet,dependentFieldUserNumber,dependentField,err)
    !DLLEXPORT(OC_EquationsSet_DependentCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of dependent variables on.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    TYPE(OC_FieldType), INTENT(INOUT) :: dependentField !<If associated on entry, the user created dependent field which has the same user number as the specified dependent field user number. If not associated on entry, on return, the created dependent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DependentCreateStartObj",err,error,*999)

    CALL EquationsSet_DependentCreateStart(equationsSet%equationsSet,dependentFieldUserNumber,dependentField%field, &
      & err,error,*999)

    EXITS("OC_EquationsSet_DependentCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DependentCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_DependentDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_DependentDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_DependentDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_DependentDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DependentDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DependentDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_DependentDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_DependentDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_DependentDestroyObj",err,error,*999)

    CALL EquationsSet_DependentDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_DependentDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_DependentDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_DependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_EquationsCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_EquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_EquationsCreateFinishNumber")
    RETURN
999 ERRORS("OC_EquationsSet_EquationsCreateFinishNumber",err,error)
    EXITS("OC_EquationsSet_EquationsCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_EquationsCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_EquationsCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_EquationsCreateFinishObj",err,error,*999)

    CALL EquationsSet_EquationsCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_EquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_EquationsCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_EquationsCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_EquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsType), POINTER :: equations
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(equations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsCreateStart(equationsSet,equations,err,error,*999)

    EXITS("OC_EquationsSet_EquationsCreateStartNumber")
    RETURN
999 ERRORS("OC_EquationsSet_EquationsCreateStartNumber",err,error)
    EXITS("OC_EquationsSet_EquationsCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_EquationsCreateStartObj(equationsSet,equations,err)
    !DLLEXPORT(OC_EquationsSet_EquationsCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of equations on.
    TYPE(OC_EquationsType), INTENT(INOUT) :: equations !<On return, the created equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_EquationsCreateStartObj",err,error,*999)

    CALL EquationsSet_EquationsCreateStart(equationsSet%equationsSet,equations%equations,err,error,*999)

    EXITS("OC_EquationsSet_EquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_EquationsCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_EquationsDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_EquationsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_EquationsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_EquationsDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_EquationsDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_EquationsDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_EquationsDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_EquationsDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_EquationsDestroyObj",err,error,*999)

    CALL EquationsSet_EquationsDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_EquationsDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_EquationsDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_EquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_IndependentCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_IndependentCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_IndependentCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_IndependentCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_IndependentCreateFinishNumber")
    RETURN
999 ERRORS("OC_EquationsSet_IndependentCreateFinishNumber",err,error)
    EXITS("OC_EquationsSet_IndependentCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_IndependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_IndependentCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_IndependentCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_IndependentCreateFinishObj",err,error,*999)

    CALL EquationsSet_IndependentCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_IndependentCreateFinishObj")
    RETURN
999 ERRORS("OC_EquationsSet_IndependentCreateFinishObj",err,error)
    EXITS("OC_EquationsSet_IndependentCreateFinishObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_IndependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_IndependentCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & independentFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_IndependentCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the independent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: independentField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_IndependentCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(independentField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(independentFieldUserNumber,region,independentField,err,error,*999)
    CALL EquationsSet_IndependentCreateStart(equationsSet,independentFieldUserNumber,independentField,err,error,*999)

    EXITS("OC_EquationsSet_IndependentCreateStartNumber")
    RETURN
999 ERRORS("OC_EquationsSet_IndependentCreateStartNumber",err,error)
    EXITS("OC_EquationsSet_IndependentCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_IndependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_IndependentCreateStartObj(equationsSet,independentFieldUserNumber,independentField,err)
    !DLLEXPORT(OC_EquationsSet_IndependentCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of independent variables on.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the dependent field.
    TYPE(OC_FieldType), INTENT(INOUT) :: independentField !<If associated on entry, the user created independent field which has the same user number as the specified independent field user number. If not associated on entry, on return, the created independent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_IndependentCreateStartObj",err,error,*999)

    CALL EquationsSet_IndependentCreateStart(equationsSet%equationsSet,independentFieldUserNumber,independentField%field, &
      & err,error,*999)

    EXITS("OC_EquationsSet_IndependentCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_IndependentCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_IndependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_IndependentDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_IndependentDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_IndependentDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_IndependentDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_IndependentDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_IndependentDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_IndependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_IndependentDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_IndependentDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_IndependentDestroyObj",err,error,*999)

    CALL EquationsSet_IndependentDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_IndependentDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_IndependentDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_IndependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_LabelGetCNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to get the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the equationss set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelGet(equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_LabelGetCObj(equationsSet,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelGetCObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the equations set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_LabelGetCObj",err,error,*999)

    CALL EquationsSet_LabelGet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_LabelGetVSNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to get the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the equations set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelGet(equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_LabelGetVSObj(equationsSet,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelGetVSObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the equations set label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_LabelGetVSObj",err,error,*999)

    CALL EquationsSet_LabelGet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_LabelSetCNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The equations set label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelSet(equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_LabelSetCObj(equationsSet,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelSetCObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The equations set label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_LabelSetCObj",err,error,*999)

    CALL EquationsSet_LabelSet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_LabelSetVSNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the label for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The equations set label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_LabelSet(equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_LabelSetVSObj(equationsSet,label,err)
    !DLLEXPORT(OC_EquationsSet_LabelSetVSObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The equations set label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_LabelSetVSObj",err,error,*999)

    CALL EquationsSet_LabelSet(equationsSet%equationsSet,label,err,error,*999)

    EXITS("OC_EquationsSet_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_MaterialsCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_MaterialsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_MaterialsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_MaterialsCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_MaterialsCreateFinishNumber")
    RETURN
999 ERRORS("OC_EquationsSet_MaterialsCreateFinishNumber",err,error)
    EXITS("OC_EquationsSet_MaterialsCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_MaterialsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_MaterialsCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_MaterialsCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_MaterialsCreateFinishObj",err,error,*999)

    CALL EquationsSet_MaterialsCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_MaterialsCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_MaterialsCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_MaterialsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_MaterialsCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & materialsFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_MaterialsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: materialsField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_MaterialsCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(materialsField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(materialsFieldUserNumber,region,materialsField,err,error,*999)
    CALL EquationsSet_MaterialsCreateStart(equationsSet,materialsFieldUserNumber,materialsField,err,error,*999)

    EXITS("OC_EquationsSet_MaterialsCreateStartNumber")
    RETURN
999 ERRORS("OC_EquationsSet_MaterialsCreateStartNumber",err,error)
    EXITS("OC_EquationsSet_MaterialsCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_MaterialsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_MaterialsCreateStartObj(equationsSet,materialsFieldUserNumber,materialsField,err)
    !DLLEXPORT(OC_EquationsSet_MaterialsCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of materials on.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    TYPE(OC_FieldType), INTENT(INOUT) :: materialsField !<If associated on entry, the user created materials field which has the same user number as the specified materials field user number. If not associated on entry, on return, the created materials field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_MaterialsCreateStartObj",err,error,*999)

    CALL EquationsSet_MaterialsCreateStart(equationsSet%equationsSet,materialsFieldUserNumber,materialsField%field, &
      & err,error,*999)

    EXITS("OC_EquationsSet_MaterialsCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_MaterialsCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_MaterialsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_MaterialsDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_MaterialsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_MaterialsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_MaterialsDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_MaterialsDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_MaterialsDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_MaterialsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_MaterialsDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_MaterialsDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_MaterialsDestroyObj",err,error,*999)

    CALL EquationsSet_MaterialsDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_MaterialsDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_MaterialsDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_MaterialsDestroyObj

  !
  !================================================================================================================================
  !

  !>Gets the output type an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_OutputTypeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(OC_EquationsSet_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_OutputTypeGet(equationsSet,outputType,err,error,*999)

    EXITS("OC_EquationsSet_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_OutputTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_OutputTypeGetObj(equationsSet,outputType,err)
    !DLLEXPORT(OC_EquationsSet_OutputTypeGetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_OutputTypeGetObj",err,error,*999)

    CALL EquationsSet_OutputTypeGet(equationsSet%equationsSet,outputType,err,error,*999)

    EXITS("OC_EquationsSet_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_OutputTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_OutputTypeSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,outputType,err)
    !DLLEXPORT(OC_EquationsSet_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations set to set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_OutputTypeSet(equationsSet,outputType,err,error,*999)

    EXITS("OC_EquationsSet_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_OutputTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_OutputTypeSetObj(equationsSet,outputType,err)
    !DLLEXPORT(OC_EquationsSet_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations set to set \see OpenCMISS_EquationsSetOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_OutputTypeSetObj",err,error,*999)

    CALL EquationsSet_OutputTypeSet(equationsSet%equationsSet,outputType,err,error,*999)

    EXITS("OC_EquationsSet_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SolutionMethodGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & solutionMethod,err)
    !DLLEXPORT(OC_EquationsSet_SolutionMethodGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On return, the solution method. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SolutionMethodGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SolutionMethodGet(equationsSet,solutionMethod,err,error,*999)

    EXITS("OC_EquationsSet_SolutionMethodGetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SolutionMethodGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SolutionMethodGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SolutionMethodGetObj(equationsSet,solutionMethod,err)
    !DLLEXPORT(OC_EquationsSet_SolutionMethodGetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On Return, the solution method. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SolutionMethodGetObj",err,error,*999)

    CALL EquationsSet_SolutionMethodGet(equationsSet%equationsSet,solutionMethod,err,error,*999)

    EXITS("OC_EquationsSet_SolutionMethodGetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SolutionMethodGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SolutionMethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SolutionMethodSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & solutionMethod,err)
    !DLLEXPORT(OC_EquationsSet_SolutionMethodSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SolutionMethodSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SolutionMethodSet(equationsSet,solutionMethod,err,error,*999)

    EXITS("OC_EquationsSet_SolutionMethodSetNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SolutionMethodSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SolutionMethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SolutionMethodSetObj(equationsSet,solutionMethod,err)
    !DLLEXPORT(OC_EquationsSet_SolutionMethodSetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OpenCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SolutionMethodSetObj",err,error,*999)

    CALL EquationsSet_SolutionMethodSet(equationsSet%equationsSet,solutionMethod,err,error,*999)

    EXITS("OC_EquationsSet_SolutionMethodSetObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SolutionMethodSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SolutionMethodSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SourceCreateFinishNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_SourceCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SourceCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SourceCreateFinish(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_SourceCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SourceCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SourceCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SourceCreateFinishObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_SourceCreateFinishObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SourceCreateFinishObj",err,error,*999)

    CALL EquationsSet_SourceCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_SourceCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SourceCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SourceCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SourceCreateStartNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & sourceFieldUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_SourceCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(FieldType), POINTER :: sourceField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SourceCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(sourceField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    !Find the field so that non-auto created fields can be used by number
    CALL Field_UserNumberFind(sourceFieldUserNumber,region,sourceField,err,error,*999)
    CALL EquationsSet_SourceCreateStart(equationsSet,sourceFieldUserNumber,sourceField,err,error,*999)

    EXITS("OC_EquationsSet_SourceCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SourceCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SourceCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SourceCreateStartObj(equationsSet,sourceFieldUserNumber,sourceField,err)
    !DLLEXPORT(OC_EquationsSet_SourceCreateStartObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of a source on.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    TYPE(OC_FieldType), INTENT(INOUT) :: sourceField !<If associated on entry, the user created source field which has the same user number as the specified source field user number. If not associated on entry, on return, the created source field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SourceCreateStartObj",err,error,*999)

    CALL EquationsSet_SourceCreateStart(equationsSet%equationsSet,sourceFieldUserNumber,sourceField%field,err,error,*999)

    EXITS("OC_EquationsSet_SourceCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SourceCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SourceCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SourceDestroyNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,err)
    !DLLEXPORT(OC_EquationsSet_SourceDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SourceDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SourceDestroy(equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_SourceDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SourceDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SourceDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SourceDestroyObj(equationsSet,err)
    !DLLEXPORT(OC_EquationsSet_SourceDestroyObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SourceDestroyObj",err,error,*999)

    CALL EquationsSet_SourceDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("OC_EquationsSet_SourceDestroyObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_SourceDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SourceDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification array for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SpecificationGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & equationsSetSpecification,err)
    !DLLEXPORT(OC_EquationsSet_SpecificationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: equationsSetSpecification(:) !<On return, the equations set specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SpecificationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SpecificationGet(equationsSet,0,equationsSetSpecification,err,error,*999)

    EXITS("OC_EquationsSet_SpecificationGetNumber")
    RETURN
999 ERRORS("OC_EquationsSet_SpecificationGetNumber",err,error)
    EXITS("OC_EquationsSet_SpecificationGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification array for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SpecificationGetObj(equationsSet,equationsSetSpecification,err)
    !DLLEXPORT(OC_EquationsSet_SpecificationGetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: equationsSetSpecification(:) !<On return, the equations set specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SpecificationGetObj",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet%equationsSet,0,equationsSetSpecification,err,error,*999)

    EXITS("OC_EquationsSet_SpecificationGetObj")
    RETURN
999 ERRORS("OC_EquationsSet_SpecificationGetObj",err,error)
    EXITS("OC_EquationsSet_SpecificationGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Returns the size of the equations set specification array for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_SpecificationSizeGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & specificationSize,err)
    !DLLEXPORT(OC_EquationsSet_SpecificationSizeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification size for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification size for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the equations set specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_SpecificationSizeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_SpecificationSizeGet(equationsSet,specificationSize,err,error,*999)

    EXITS("OC_EquationsSet_SpecificationSizeGetNumber")
    RETURN
999 ERRORS("OC_EquationsSet_SpecificationSizeGetNumber",err,error)
    EXITS("OC_EquationsSet_SpecificationSizeGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SpecificationSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the equations set specification array for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_SpecificationSizeGetObj(equationsSet,specificationSize,err)
    !DLLEXPORT(OC_EquationsSet_SpecificationSizeGetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification size for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the equations set specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_SpecificationSizeGetObj",err,error,*999)

    CALL EquationsSet_SpecificationSizeGet(equationsSet%equationsSet,specificationSize,err,error,*999)

    EXITS("OC_EquationsSet_SpecificationSizeGetObj")
    RETURN
999 ERRORS("OC_EquationsSet_SpecificationSizeGetObj",err,error)
    EXITS("OC_EquationsSet_SpecificationSizeGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_SpecificationSizeGetObj

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element Gauss point, for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_TensorInterpolateGaussPointNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,gaussPointNumber,userElementNumber,values,err)
    !DLLEXPORT(OC_EquationsSet_TensorInterpolateGaussPointNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evalaute the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of derived tensor to interpolate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(OUT) :: values(:,:) !On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_TensorInterpolateGaussPointNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TensorInterpolateGaussPoint(equationsSet,derivedTensorType,gaussPointNumber,userElementNumber,values, &
      & err,error,*999)

    EXITS("OC_EquationsSet_TensorInterpolateGaussPointNumber")
    RETURN
999 ERRORS("OC_EquationsSet_TensorInterpolateGaussPointNumber",err,error)
    EXITS("OC_EquationsSet_TensorInterpolateGaussPointNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TensorInterpolateGaussPointNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element Gauss point, for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_TensorInterpolateGaussPointObj(equationsSet,derivedTensorType,gaussPointNumber,userElementNumber, &
    & values,err)
    !DLLEXPORT(OC_EquationsSet_TensorInterpolateGaussPointObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<A pointer to the equations set to evaluate the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of derived tensor to interpolate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(OUT) :: values(:,:) !<On exit, the interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_EquationsSet_TensorInterpolateGaussPointObj",err,error,*999)

    CALL EquationsSet_TensorInterpolateGaussPoint(equationsSet%equationsSet,derivedTensorType,gaussPointNumber,userElementNumber, &
      & values,err,error,*999)

    EXITS("OC_EquationsSet_TensorInterpolateGaussPointObj")
    RETURN
999 ERRORS("OC_EquationsSet_TensorInterpolateGaussPointObj",err,error)
    EXITS("OC_EquationsSet_TensorInterpolateGaussPointObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TensorInterpolateGaussPointObj

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element xi location, for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_TensorInterpolateXiNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber, &
    & derivedTensorType,userElementNumber,xi,values,err)
    !DLLEXPORT(OC_EquationsSet_TensorInterpolateXiNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evalaute the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of derived tensor to interpolate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_TensorInterpolateXiNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TensorInterpolateXi(equationsSet,derivedTensorType,userElementNumber,xi,values,err,error,*999)

    EXITS("OC_EquationsSet_TensorInterpolateXiNumber")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_TensorInterpolateXiNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TensorInterpolateXiNumber

  !
  !================================================================================================================================
  !

  !>Evaluate a tensor at a given element xi location, for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_TensorInterpolateXiObj(equationsSet,derivedTensorType,userElementNumber,xi,values,err)
    !DLLEXPORT(OC_EquationsSet_TensorInterpolateXiObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<A pointer to the equations set to evaluate the tensor for.
    INTEGER(INTG), INTENT(IN) :: derivedTensorType !<The type of tensor to evaluate. \see OpenCMISS_EquationsSetDerivedTensorTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_EquationsSet_TensorInterpolateXiObj",err,error,*999)

    CALL EquationsSet_TensorInterpolateXi(equationsSet%equationsSet,derivedTensorType,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("OC_EquationsSet_TensorInterpolateXiObj")
    RETURN
999 ERRORSEXITS("OC_EquationsSet_TensorInterpolateXiObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TensorInterpolateXiObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set current times for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_TimesGetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,currentTime,deltaTime,err)
    !DLLEXPORT(OC_EquationsSet_TimesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the times for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the equations set current time.
    REAL(DP), INTENT(OUT) :: deltaTime !<On return, the equations set current delta time.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_TimesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TimesGet(equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("OC_EquationsSet_TimesGetNumber")
    RETURN
999 ERRORS("OC_EquationsSet_TimesGetNumber",err,error)
    EXITS("OC_EquationsSet_TimesGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TimesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set current times for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_TimesGetObj(equationsSet,currentTime,deltaTime,err)
    !DLLEXPORT(OC_EquationsSet_TimesGetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the equations set current time.
    REAL(DP), INTENT(OUT) :: deltaTime !<On return, the equations set current delta time.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_TimesGetObj",err,error,*999)

    CALL EquationsSet_TimesGet(equationsSet%equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("OC_EquationsSet_TimesGetObj")
    RETURN
999 ERRORS("OC_EquationsSet_TimesGetObj",err,error)
    EXITS("OC_EquationsSet_TimesGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set current times for an equations set identified by a user number.
  SUBROUTINE OC_EquationsSet_TimesSetNumber(contextUserNumber,regionUserNumber,equationsSetUserNumber,currentTime,deltaTime,err)
    !DLLEXPORT(OC_EquationsSet_TimesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the times for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The equations set current time to set.
    REAL(DP), INTENT(IN) :: deltaTime !<The equations set current delta time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_EquationsSet_TimesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL EquationsSet_TimesSet(equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("OC_EquationsSet_TimesSetNumber")
    RETURN
999 ERRORS("OC_EquationsSet_TimesSetNumber",err,error)
    EXITS("OC_EquationsSet_TimesSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TimesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set current times for an equations set identified by an object.
  SUBROUTINE OC_EquationsSet_TimesSetObj(equationsSet,currentTime,deltaTime,err)
    !DLLEXPORT(OC_EquationsSet_TimesSetObj)

    !Argument variables
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The equations set current time to set.
    REAL(DP), INTENT(IN) :: deltaTime !<The equations set current delta time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_EquationsSet_TimesSetObj",err,error,*999)

    CALL EquationsSet_TimesSet(equationsSet%equationsSet,currentTime,deltaTime,err,error,*999)

    EXITS("OC_EquationsSet_TimesSetObj")
    RETURN
999 ERRORS("OC_EquationsSet_TimesSetObj",err,error)
    EXITS("OC_EquationsSet_TimesSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_EquationsSet_TimesSetObj

!!==================================================================================================================================
!!
!! ExportRoutines
!!
!!==================================================================================================================================

  !>Gets the varying string base filename for an export identified by a user number.
  SUBROUTINE OC_Export_BaseFilenameGetNumberVS(contextUserNumber,exportUserNumber,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameGetNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to get the base filename for.
    TYPE(VARYING_STRING), INTENT(OUT) :: baseFilename !<On return, the base filename for the export. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_BaseFilenameGetNumberVS",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_BaseFilenameGet(export,baseFilename,err,error,*999)
    
    EXITS("OC_Export_BaseFilenameGetNumberVS")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameGetNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameGetNumberVS

  !
  !================================================================================================================================
  !

  !>Gets the character base filename for an export identified by a user number.
  SUBROUTINE OC_Export_BaseFilenameGetNumberC(contextUserNumber,exportUserNumber,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameGetNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to set the base filename for.
    CHARACTER(LEN=*), INTENT(OUT) :: baseFilename !<On return, the base filename. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_BaseFilenameGetNumberC",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_BaseFilenameGet(export,baseFilename,err,error,*999)
    
    EXITS("OC_Export_BaseFilenameGetNumberC")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameGetNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameGetNumberC

  !
  !================================================================================================================================
  !

  !>Gets the varying string base filename for an export identified by an object.
  SUBROUTINE OC_Export_BaseFilenameGetObjVS(export,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameGetObjVS)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to set the base filename for.
    TYPE(VARYING_STRING), INTENT(OUT) :: baseFilename !<On return, the base filename. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_BaseFilenameGetObjVS",err,error,*999)

    CALL Export_BaseFilenameGet(export%export,baseFilename,err,error,*999)

    EXITS("OC_Export_BaseFilenameGetObjVS")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameGetObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameGetObjVS

  !
  !================================================================================================================================
  !

  !>Gets the character base filename for an export identified by an object.
  SUBROUTINE OC_Export_BaseFilenameGetObjC(export,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameGetObjC)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to set the base filename for.
    CHARACTER(LEN=*), INTENT(OUT) :: baseFilename !<On return, the base filename to set. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_BaseFilenameGetObjC",err,error,*999)

    CALL Export_BaseFilenameGet(export%export,baseFilename,err,error,*999)

    EXITS("OC_Export_BaseFilenameGetObjC")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameGetObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameGetObjC

  !
  !================================================================================================================================
  !

  !>Sets the varying string base filename for an export identified by a user number.
  SUBROUTINE OC_Export_BaseFilenameSetNumberVS(contextUserNumber,exportUserNumber,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameSetNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to set the base filename for.
    TYPE(VARYING_STRING), INTENT(IN) :: baseFilename !<The base filename to set. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_BaseFilenameSetNumberVS",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_BaseFilenameSet(export,baseFilename,err,error,*999)
    
    EXITS("OC_Export_BaseFilenameSetNumberVS")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameSetNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameSetNumberVS

  !
  !================================================================================================================================
  !

  !>Sets the character base filename for an export identified by a user number.
  SUBROUTINE OC_Export_BaseFilenameSetNumberC(contextUserNumber,exportUserNumber,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameSetNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to set the base filename for.
    CHARACTER(LEN=*), INTENT(IN) :: baseFilename !<The base filename to set. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_BaseFilenameSetNumberC",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_BaseFilenameSet(export,baseFilename,err,error,*999)
    
    EXITS("OC_Export_BaseFilenameSetNumberC")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameSetNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameSetNumberC

  !
  !================================================================================================================================
  !

  !>Sets the varying string base filename for an export identified by an object.
  SUBROUTINE OC_Export_BaseFilenameSetObjVS(export,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameSetObjVS)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to set the base filename for.
    TYPE(VARYING_STRING), INTENT(IN) :: baseFilename !<The base filename to set. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_BaseFilenameSetObjVS",err,error,*999)

    CALL Export_BaseFilenameSet(export%export,baseFilename,err,error,*999)

    EXITS("OC_Export_BaseFilenameSetObjVS")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameSetObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameSetObjVS

  !
  !================================================================================================================================
  !

  !>Sets the character base filename for an export identified by an object.
  SUBROUTINE OC_Export_BaseFilenameSetObjC(export,baseFilename,err)
    !DLLEXPORT(OC_Export_BaseFilenameSetObjC)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to set the base filename for.
    CHARACTER(LEN=*), INTENT(IN) :: baseFilename !<The base filename to set. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_BaseFilenameSetObjC",err,error,*999)

    CALL Export_BaseFilenameSet(export%export,baseFilename,err,error,*999)

    EXITS("OC_Export_BaseFilenameSetObjC")
    RETURN
999 ERRORSEXITS("OC_Export_BaseFilenameSetObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_BaseFilenameSetObjC

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an export identified by a user number.
  SUBROUTINE OC_Export_CreateFinishNumber(contextUserNumber,exportUserNumber,err)
    !DLLEXPORT(OC_Export_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the export.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_CreateFinish(export,err,error,*999)

    EXITS("OC_Export_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Export_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an export identified by an object.
  SUBROUTINE OC_Export_CreateFinishObj(export,err)
    !DLLEXPORT(OC_Export_CreateFinishObj)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_CreateFinishObj",err,error,*999)

    CALL Export_CreateFinish(export%export,err,error,*999)

    EXITS("OC_Export_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Export_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an export identified by a user number.
  SUBROUTINE OC_Export_CreateStartNumber(exportUserNumber,contextUserNumber,err)
    !DLLEXPORT(OC_Export_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_CreateStart(exportUserNumber,exports,export,err,error,*999)

    EXITS("OC_Export_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Export_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an export identified by an object.
  SUBROUTINE OC_Export_CreateStartObj(exportUserNumber,context,export,err)
    !DLLEXPORT(OC_Export_CreateFinishObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to start the creation of.
    TYPE(OC_ContextType), INTENT(INOUT) :: context !<The context in which to create the export
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variable
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_CreateStartObj",err,error,*999)

    NULLIFY(exports)
    CALL Context_ExportsGet(context%context,exports,err,error,*999)
    CALL Export_CreateStart(exportUserNumber,exports,export%export,err,error,*999)

    EXITS("OC_Export_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Export_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys an export identified by a user number.
  SUBROUTINE OC_Export_DestroyNumber(contextUserNumber,exportUserNumber,err)
    !DLLEXPORT(OC_Export_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export to destroy.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_Destroy(export,err,error,*999)

    EXITS("OC_Export_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Export_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an export identified by an object.
  SUBROUTINE OC_Export_DestroyObj(export,err)
    !DLLEXPORT(OC_Export_DestroyObj)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_DestroyObj",err,error,*999)

    CALL Export_Destroy(export%export,err,error,*999)

    EXITS("OC_Export_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Export_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_DestroyObj

  !
  !================================================================================================================================
  !

  !>Export files an export identified by a user number.
  SUBROUTINE OC_Export_ExportNumber(contextUserNumber,exportUserNumber,err)
    !DLLEXPORT(OC_Export_ExportNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export to export.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to export.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_ExportNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_Export(export,err,error,*999)

    EXITS("OC_Export_ExportNumber")
    RETURN
999 ERRORSEXITS("OC_Export_ExportNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportNumber

  !
  !================================================================================================================================
  !

  !>Export files for an export identified by an object.
  SUBROUTINE OC_Export_ExportObj(export,err)
    !DLLEXPORT(OC_Export_ExportObj)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to export.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_ExportObj",err,error,*999)

    CALL Export_Export(export%export,err,error,*999)

    EXITS("OC_Export_ExportObj")
    RETURN
999 ERRORSEXITS("OC_Export_ExportObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportObj

  !
  !================================================================================================================================
  !

  !>Sets the format for an export identified by a user number.
  SUBROUTINE OC_Export_ExportFormatSetNumber(contextUserNumber,exportUserNumber,exportFormat,err)
    !DLLEXPORT(OC_Export_ExportFormatSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the export to destroy.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export to destroy.
    INTEGER(INTG), INTENT(IN) :: exportFormat !<The export format to set \see OpenCMISS_ExportFormatTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports

    ENTERS("OC_Export_ExportFormatSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Export_ExportFormatSet(export,exportFormat,err,error,*999)

    EXITS("OC_Export_ExportFormatSetNumber")
    RETURN
999 ERRORSEXITS("OC_Export_ExportFormatSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportFormatSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the export format for an export identified by an object.
  SUBROUTINE OC_Export_ExportFormatSetObj(export,exportFormat,err)
    !DLLEXPORT(OC_Export_ExportFormatSetObj)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to destroy.
    INTEGER(INTG), INTENT(IN) :: exportFormat !<The export format to set \see OpenCMISS_ExportFormatTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Export_ExportFormatSetObj",err,error,*999)

    CALL Export_ExportFormatSet(export%export,exportFormat,err,error,*999)

    EXITS("OC_Export_ExportFormatSetObj")
    RETURN
999 ERRORSEXITS("OC_Export_ExportFormatSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportFormatSetObj
  
  !
  !================================================================================================================================
  !

  !>Adds an export variable with a varying string name to an export identified by a user number.
  SUBROUTINE OC_Export_ExportVariableAddNumberVS(contextUserNumber,exportUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,startComponent,endComponent,exportName,exportVariableIndex,err)
    !DLLEXPORT(OC_Export_ExportVariableAddNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field variable to add. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field variable to add. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: startComponent !<The start component number of the field variable to add.
    INTEGER(INTG), INTENT(IN) :: endComponent !<The end component number of the field variable to add.
    TYPE(VARYING_STRING), INTENT(IN) :: exportName !<The name of the export variable.
    INTEGER(INTG), INTENT(OUT) :: exportVariableIndex !<On exit, the index of the added export variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Export_ExportVariableAddNumberVS",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(fieldVariable)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL Export_ExportVariableAdd(export,fieldVariable,fieldSetType,startComponent,endComponent,exportName,exportVariableIndex, &
      & err,error,*999)

    EXITS("OC_Export_ExportVariableAddNumberVS")
    RETURN
999 ERRORSEXITS("OC_Export_ExportVariableAddNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportVariableAddNumberVS

  !
  !================================================================================================================================
  !

  !>Adds an export variable with a character name to an export identified by a user number.
  SUBROUTINE OC_Export_ExportVariableAddNumberC(contextUserNumber,exportUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,startComponent,endComponent,exportName,exportVariableIndex,err)
    !DLLEXPORT(OC_Export_ExportVariableAddNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context.
    INTEGER(INTG), INTENT(IN) :: exportUserNumber !<The user number of the export.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field variable to add. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field variable to add. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: startComponent !<The start component number of the field variable to add.
    INTEGER(INTG), INTENT(IN) :: endComponent !<The end component number of the field variable to add.
    CHARACTER(LEN=*), INTENT(IN) :: exportName !<The name of the export variable.
    INTEGER(INTG), INTENT(OUT) :: exportVariableIndex !<On exit, the index of the added export variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ExportType), POINTER :: export
    TYPE(ExportsType), POINTER :: exports
    TYPE(FieldType), POINTER :: field
    TYPE(FieldVariableType), POINTER :: fieldVariable
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Export_ExportVariableAddNumberC",err,error,*999)

    NULLIFY(context)
    NULLIFY(exports)
    NULLIFY(export)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(fieldVariable)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ExportsGet(context,exports,err,error,*999)
    CALL Export_Get(exports,exportUserNumber,export,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL Export_ExportVariableAdd(export,fieldVariable,fieldSetType,startComponent,endComponent,VAR_STR(exportName), &
      & exportVariableIndex,err,error,*999)

    EXITS("OC_Export_ExportVariableAddNumberC")
    RETURN
999 ERRORSEXITS("OC_Export_ExportVariableAddNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportVariableAddNumberC

  !
  !================================================================================================================================
  !

  !>Adds an export variable with a varying string name to an export identified by an object.
  SUBROUTINE OC_Export_ExportVariableAddObjVS(export,field,variableType,fieldSetType,startComponent,endComponent,exportName, &
    & exportVariableIndex,err)
   !DLLEXPORT(OC_Export_ExportVariableAddObjVS)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to add the variable for.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field variable to add. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field variable to add. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: startComponent !<The start component number of the field variable to add.
    INTEGER(INTG), INTENT(IN) :: endComponent !<The end component number of the field variable to add.
    TYPE(VARYING_STRING), INTENT(IN) :: exportName !<The name of the export variable.
    INTEGER(INTG), INTENT(OUT) :: exportVariableIndex !<On exit, the index of the added export variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("OC_Export_ExportVariableAddObjVS",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field%field,variableType,fieldVariable,err,error,*999)
    CALL Export_ExportVariableAdd(export%export,fieldVariable,fieldSetType,startComponent,endComponent,exportName, &
      & exportVariableIndex,err,error,*999)

    EXITS("OC_Export_ExportVariableAddObjVS")
    RETURN
999 ERRORSEXITS("OC_Export_ExportVariableAddObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportVariableAddObjVS
  
  !
  !================================================================================================================================
  !

  !>Adds an export variable with a character name to an export identified by an object.
  SUBROUTINE OC_Export_ExportVariableAddObjC(export,field,variableType,fieldSetType,startComponent,endComponent,exportName, &
    & exportVariableIndex,err)
   !DLLEXPORT(OC_Export_ExportVariableAddObjC)

    !Argument variables
    TYPE(OC_ExportType), INTENT(INOUT) :: export !<The export to add the variable for.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field variable to add. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field variable to add. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: startComponent !<The start component number of the field variable to add.
    INTEGER(INTG), INTENT(IN) :: endComponent !<The end component number of the field variable to add.
    CHARACTER(LEN=*), INTENT(IN) :: exportName !<The name of the export variable.
    INTEGER(INTG), INTENT(OUT) :: exportVariableIndex !<On exit, the index of the added export variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FieldVariableType), POINTER :: fieldVariable

    ENTERS("OC_Export_ExportVariableAddObjC",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field%field,variableType,fieldVariable,err,error,*999)
    CALL Export_ExportVariableAdd(export%export,fieldVariable,fieldSetType,startComponent,endComponent,VAR_STR(exportName), &
      & exportVariableIndex,err,error,*999)

    EXITS("OC_Export_ExportVariableAddObjC")
    RETURN
999 ERRORSEXITS("OC_Export_ExportVariableAddObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Export_ExportVariableAddObjC
  
!!==================================================================================================================================
!!
!! FieldRoutines
!!
!!==================================================================================================================================

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentInterpolationGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,interpolationType,err)
    !DLLEXPORT(OC_Field_ComponentInterpolationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentInterpolationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentInterpolationGet(field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("OC_Field_ComponentInterpolationGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentInterpolationGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentInterpolationGetObj(field,variableType,componentNumber,interpolationType,err)
    !DLLEXPORT(OC_Field_ComponentInterpolationGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentInterpolationGetObj",err,error,*999)

    CALL Field_ComponentInterpolationGet(field%field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("OC_Field_ComponentInterpolationGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentInterpolationGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentInterpolationSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,interpolationType,err)
    !DLLEXPORT(OC_Field_ComponentInterpolationSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentInterpolationSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentInterpolationSet(field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("OC_Field_ComponentInterpolationSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentInterpolationSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentInterpolationSetObj(field,variableType,componentNumber,interpolationType,err)
    !DLLEXPORT(OC_Field_ComponentInterpolationSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OpenCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentInterpolationSetObj",err,error,*999)

    CALL Field_ComponentInterpolationSet(field%field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("OC_Field_ComponentInterpolationSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentInterpolationSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentLabelGetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentLabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelGet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentLabelGetCObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelGetCObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentLabelGetCObj",err,error,*999)

    CALL Field_ComponentLabelGet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentLabelGetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentLabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelGet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentLabelGetVSObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelGetVSObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentLabelGetVSObj",err,error,*999)

    CALL Field_ComponentLabelGet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentLabelSetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentLabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelSet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentLabelSetCObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelSetCObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentLabelSetCObj",err,error,*999)

    CALL Field_ComponentLabelSet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentLabelSetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentLabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentLabelSet(field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentLabelSetVSObj(field,variableType,componentNumber,label,err)
    !DLLEXPORT(OC_Field_ComponentLabelSetVSObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentLabelSetVSObj",err,error,*999)

    CALL Field_ComponentLabelSet(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("OC_Field_ComponentLabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentLabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentMeshComponentGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,meshComponent,err)
    !DLLEXPORT(OC_Field_ComponentMeshComponentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentMeshComponentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentMeshComponentGet(field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("OC_Field_ComponentMeshComponentGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentMeshComponentGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentMeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentMeshComponentGetObj(field,variableType,componentNumber,meshComponent,err)
    !DLLEXPORT(OC_Field_ComponentMeshComponentGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentMeshComponentGetObj",err,error,*999)

    CALL Field_ComponentMeshComponentGet(field%field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("OC_Field_ComponentMeshComponentGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentMeshComponentGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentMeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentMeshComponentSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,meshComponent,err)
    !DLLEXPORT(OC_Field_ComponentMeshComponentSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentMeshComponentSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentMeshComponentSet(field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("OC_Field_ComponentMeshComponentSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentMeshComponentSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentMeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ComponentMeshComponentSetObj(field,variableType,componentNumber,meshComponent,err)
    !DLLEXPORT(OC_Field_ComponentMeshComponentSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentMeshComponentSetObj",err,error,*999)

    CALL Field_ComponentMeshComponentSet(field%field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("OC_Field_ComponentMeshComponentSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentMeshComponentSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentMeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentValuesInitialiseIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentValuesInitialiseIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseIntgNumber")
    RETURN
999 ERRORS("OC_Field_ComponentValuesInitialiseIntgNumber",err,error)
    EXITS("OC_Field_ComponentValuesInitialiseIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseIntgNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by an object.
  SUBROUTINE OC_Field_ComponentValuesInitialiseIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentValuesInitialiseIntgObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentValuesInitialiseIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseIntgObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentValuesInitialiseSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentValuesInitialiseSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseSPNumber")
    RETURN
999 ERRORS("OC_Field_ComponentValuesInitialiseSPNumber",err,error)
    EXITS("OC_Field_ComponentValuesInitialiseSPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseSPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by an object.
  SUBROUTINE OC_Field_ComponentValuesInitialiseSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentValuesInitialiseSPObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentValuesInitialiseSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseSPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentValuesInitialiseDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentValuesInitialiseDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseDPNumber")
    RETURN
999 ERRORS("OC_Field_ComponentValuesInitialiseDPNumber",err,error)
    EXITS("OC_Field_ComponentValuesInitialiseDPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseDPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by an object.
  SUBROUTINE OC_Field_ComponentValuesInitialiseDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentValuesInitialiseDPObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentValuesInitialiseDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseDPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by a user number.
  SUBROUTINE OC_Field_ComponentValuesInitialiseLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ComponentValuesInitialiseLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ComponentValuesInitialise(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentValuesInitialiseLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseLNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by an object.
  SUBROUTINE OC_Field_ComponentValuesInitialiseLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ComponentValuesInitialiseLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ComponentValuesInitialiseLObj",err,error,*999)

    CALL Field_ComponentValuesInitialise(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ComponentValuesInitialiseLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ComponentValuesInitialiseLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ComponentValuesInitialiseLObj

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_DataTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,dataType,err)
    !DLLEXPORT(OC_Field_DataTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DataTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DataTypeGet(field,variableType,dataType,err,error,*999)

    EXITS("OC_Field_DataTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DataTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DataTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_DataTypeGetObj(field,variableType,dataType,err)
    !DLLEXPORT(OC_Field_DataTypeGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DataTypeGetObj",err,error,*999)

    CALL Field_DataTypeGet(field%field,variableType,dataType,err,error,*999)

    EXITS("OC_Field_DataTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DataTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_DataTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,dataType,err)
    !DLLEXPORT(OC_Field_DataTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DataTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DataTypeSet(field,variableType,dataType,err,error,*999)

    EXITS("OC_Field_DataTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DataTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DataTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_DataTypeSetObj(field,variableType,dataType,err)
    !DLLEXPORT(OC_Field_DataTypeSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OpenCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DataTypeSetObj",err,error,*999)

    CALL Field_DataTypeSet(field%field,variableType,dataType,err,error,*999)

    EXITS("OC_Field_DataTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DataTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DataTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_DOFOrderTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)
    !DLLEXPORT(OC_Field_DOFOrderTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF Order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF Order type. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DOFOrderTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DOFOrderTypeGet(field,variableType,DOFOrderType,err,error,*999)

    EXITS("OC_Field_DOFOrderTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DOFOrderTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DOFOrderTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_DOFOrderTypeGetObj(field,variableType,DOFOrderType,err)
    !DLLEXPORT(OC_Field_DOFOrderTypeGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF order type. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DOFOrderTypeGetObj",err,error,*999)

    CALL Field_DOFOrderTypeGet(field%field,variableType,DOFOrderType,err,error,*999)

    EXITS("OC_Field_DOFOrderTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DOFOrderTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DOFOrderTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_DOFOrderTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)
    !DLLEXPORT(OC_Field_DOFOrderTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF Order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF Order type to set. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DOFOrderTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DOFOrderTypeSet(field,variableType,DOFOrderType,err,error,*999)

    EXITS("OC_Field_DOFOrderTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DOFOrderTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DOFOrderTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_DOFOrderTypeSetObj(field,variableType,DOFOrderType,err)
    !DLLEXPORT(OC_Field_DOFOrderTypeSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF order type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF order type to set. \see OpenCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DOFOrderTypeSetObj",err,error,*999)

    CALL Field_DOFOrderTypeSet(field%field,variableType,DOFOrderType,err,error,*999)

    EXITS("OC_Field_DOFOrderTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DOFOrderTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DOFOrderTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by a user number.
  SUBROUTINE OC_Field_CreateFinishNumber(contextUserNumber,regionUserNumber,fieldUserNumber,err)
    !DLLEXPORT(OC_Field_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_CreateFinish(field,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    EXITS("OC_Field_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Field_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by an object.
  SUBROUTINE OC_Field_CreateFinishObj(field,err)
    !DLLEXPORT(OC_Field_CreateFinishObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<The field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_CreateFinishObj",err,error,*999)

    CALL Field_CreateFinish(field%field,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('field Create')
#endif

    EXITS("OC_Field_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Field_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field identified by a user number.
  SUBROUTINE OC_Field_CreateStartNumber(fieldUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_Field_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Field_CreateStart(fieldUserNumber,region,field,err,error,*999)

    EXITS("OC_Field_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Field_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field on an interface identified by an object.
  SUBROUTINE OC_Field_CreateStartInterfaceObj(fieldUserNumber,interface,field,err)
    !DLLEXPORT(OC_Field_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to create the field on.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_CreateStartInterfaceObj",err,error,*999)

    CALL Field_CreateStart(fieldUserNumber,interface%interface,field%field,err,error,*999)

    EXITS("OC_Field_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("OC_Field_CreateStartInterfaceObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field on a region identified by an object.
  SUBROUTINE OC_Field_CreateStartRegionObj(fieldUserNumber,region,field,err)
    !DLLEXPORT(OC_Field_CreateStartRegionObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to create the field on.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('field Create')
#endif

    CALL Field_CreateStart(fieldUserNumber,region%region,field%field,err,error,*999)

    EXITS("OC_Field_CreateStartRegionObj")
    RETURN
999 ERRORSEXITS("OC_Field_CreateStartRegionObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by a user number.
  SUBROUTINE OC_Field_DependentTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,dependentType,err)
    !DLLEXPORT(OC_Field_DependentTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DependentTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DependentTypeGet(field,dependentType,err,error,*999)

    EXITS("OC_Field_DependentTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DependentTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DependentTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by an object.
  SUBROUTINE OC_Field_DependentTypeGetObj(field,dependentType,err)
    !DLLEXPORT(OC_Field_DependentTypeGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DependentTypeGetObj",err,error,*999)

    CALL Field_DependentTypeGet(field%field,dependentType,err,error,*999)

    EXITS("OC_Field_DependentTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DependentTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DependentTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by a user number.
  SUBROUTINE OC_Field_DependentTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,dependentType,err)
    !DLLEXPORT(OC_Field_DependentTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DependentTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DependentTypeSet(field,dependentType,err,error,*999)

    EXITS("OC_Field_DependentTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DependentTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DependentTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by an object.
  SUBROUTINE OC_Field_DependentTypeSetObj(field,dependentType,err)
    !DLLEXPORT(OC_Field_DependentTypeSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OpenCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DependentTypeSetObj",err,error,*999)

    CALL Field_DependentTypeSet(field%field,dependentType,err,error,*999)

    EXITS("OC_Field_DependentTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DependentTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DependentTypeSetObj

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by a user number.
  SUBROUTINE OC_Field_DestroyNumber(contextUserNumber,regionUserNumber,fieldUserNumber,err)
    !DLLEXPORT(OC_Field_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_Destroy(field,err,error,*999)

    EXITS("OC_Field_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by an object.
  SUBROUTINE OC_Field_DestroyObj(field,err)
    !DLLEXPORT(OC_Field_DestroyObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DestroyObj",err,error,*999)

    CALL Field_Destroy(field%field,err,error,*999)

    EXITS("OC_Field_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Field_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by a user number.
  SUBROUTINE OC_Field_DimensionGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,dimension,err)
    !DLLEXPORT(OC_Field_DimensionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dimension !<On return, the field dimension. \see OpenCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DimensionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DimensionGet(field,variableType,DIMENSION,err,error,*999)

    EXITS("OC_Field_DimensionGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DimensionGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by an object.
  SUBROUTINE OC_Field_DimensionGetObj(field,variableType,dimension,err)
    !DLLEXPORT(OC_Field_DimensionGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OpenCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DimensionGetObj",err,error,*999)

    CALL Field_DimensionGet(field%field,variableType,dimension,err,error,*999)

    EXITS("OC_Field_DimensionGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DimensionGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by a user number.
  SUBROUTINE OC_Field_DimensionSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,DIMENSION,err)
    !DLLEXPORT(OC_Field_DimensionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OpenCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DimensionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DimensionSet(field,variableType,DIMENSION,err,error,*999)

    EXITS("OC_Field_DimensionSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DimensionSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by an object.
  SUBROUTINE OC_Field_DimensionSetObj(field,variableType,dimension,err)
    !DLLEXPORT(OC_Field_DimensionSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dimension !<The field dimension to set. \see OpenCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DimensionSetObj",err,error,*999)

    CALL Field_DimensionSet(field%field,variableType,DIMENSION,err,error,*999)

    EXITS("OC_Field_DimensionSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DimensionSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by a user number.
  SUBROUTINE OC_Field_GeometricFieldGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)
    !DLLEXPORT(OC_Field_GeometricFieldGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<On return, the field geometric field user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_GeometricFieldGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_GeometricFieldGet(field,geometricField,err,error,*999)
    geometricFieldUserNumber=geometricField%userNumber

    EXITS("OC_Field_GeometricFieldGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_GeometricFieldGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by an object.
  SUBROUTINE OC_Field_GeometricFieldGetObj(field,geometricField,err)
    !DLLEXPORT(OC_Field_GeometricFieldGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the geometric field for.
    TYPE(OC_FieldType), INTENT(INOUT) :: geometricField !<On return, the geometric field for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_GeometricFieldGetObj",err,error,*999)

    CALL Field_GeometricFieldGet(field%field,geometricField%field,err,error,*999)

    EXITS("OC_Field_GeometricFieldGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_GeometricFieldGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricFieldGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by a user number.
  SUBROUTINE OC_Field_GeometricFieldSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)
    !DLLEXPORT(OC_Field_GeometricFieldSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The field geometric field user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field,geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_GeometricFieldSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_FieldGet(region,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL Field_GeometricFieldSet(field,geometricField,err,error,*999)

    EXITS("OC_Field_GeometricFieldSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_GeometricFieldSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by an object.
  SUBROUTINE OC_Field_GeometricFieldSetObj(field,geometricField,err)
    !DLLEXPORT(OC_Field_GeometricFieldSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the geometric field for.
    TYPE(OC_FieldType), INTENT(IN) :: geometricField !<The geometric field for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_GeometricFieldSetObj",err,error,*999)

    CALL Field_GeometricFieldSet(field%field,geometricField%field,err,error,*999)

    EXITS("OC_Field_GeometricFieldSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_GeometricFieldSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricFieldSetObj

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and line xi normal directions by a user number.
  SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetNumber0(contextUserNumber,regionUserNumber, &
    & geometricFieldUserNumber,userElementNumber,xiNormalDirection,lineLength,err)
    !DLLEXPORT(OC_Field_GeometricParametersElementLineLengthGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the line length from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirection !<The xi normal direction to specify the line
    REAL(DP), INTENT(OUT) :: lineLength !<On return, the line length of the chosen line 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_GeometricParametersElementLineLengthGetNumber0",err,error,*999)

    CALL OC_Field_GeometricParametersElementLineLengthGetNumber1(contextUserNumber,regionUserNumber, &
      & geometricFieldUserNumber,userElementNumber,[xiNormalDirection],lineLength,err)

    EXITS("OC_Field_GeometricParametersElementLineLengthGetNumber0")
    RETURN
999 ERRORS("OC_Field_GeometricParametersElementLineLengthGetNumber0",err,error)
    EXITS("OC_Field_GeometricParametersElementLineLengthGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number by a user number.
  SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetNumber1(contextUserNumber,regionUserNumber, &
    & geometricFieldUserNumber,userElementNumber,xiNormalDirections,lineLength,err)
    !DLLEXPORT(OC_Field_GeometricParametersElementLineLengthGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the line length from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirections(:) !<xiNormalDirections(xiIdx). The xi normal directions to specify the line
    REAL(DP), INTENT(OUT) :: lineLength !<On return, the line length of the chosen line 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_GeometricParametersElementLineLengthGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL Field_GeometricParametersElementLineLengthGet(geometricField,userElementNumber,xiNormalDirections,lineLength, &
      & err,error,*999)

    EXITS("OC_Field_GeometricParametersElementLineLengthGetNumber1")
    RETURN
999 ERRORS("OC_Field_GeometricParametersElementLineLengthGetNumber1",err,error)
    EXITS("OC_Field_GeometricParametersElementLineLengthGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and line xi normal direction by an object.
  SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetObj0(geometricField,userElementNumber,xiNormalDirection, &
    & lineLength,err)
    !DLLEXPORT(OC_Field_GeometricParametersElementLineLengthGetObj0)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirection !<The line xi normal direction to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_GeometricParametersElementLineLengthGetObj0",err,error,*999)

    CALL OC_Field_GeometricParametersElementLineLengthGetObj1(geometricField,userElementNumber,[xiNormalDirection], &
      & lineLength,err)

    EXITS("OC_Field_GeometricParametersElementLineLengthGetObj0")
    RETURN
999 ERRORS("OC_Field_GeometricParametersElementLineLengthGetObj0",err,error)
    EXITS("OC_Field_GeometricParametersElementLineLengthGetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetObj0

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given user element number and line xi normal directions  by an object.
  SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetObj1(geometricField,userElementNumber,xiNormalDirections, &
    & lineLength,err)
    !DLLEXPORT(OC_Field_GeometricParametersElementLineLengthGetObj1)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the line length for
    INTEGER(INTG), INTENT(IN) :: xiNormalDirections(:) !<xiNormalDirections(xiIdx). The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_GeometricParametersElementLineLengthGetObj1",err,error,*999)

    CALL Field_GeometricParametersElementLineLengthGet(geometricField%field,userElementNumber,xiNormalDirections,lineLength, &
      & err,error,*999)

    EXITS("OC_Field_GeometricParametersElementLineLengthGetObj1")
    RETURN
999 ERRORS("OC_Field_GeometricParametersElementLineLengthGetObj1",err,error)
    EXITS("OC_Field_GeometricParametersElementLineLengthGetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricParametersElementLineLengthGetObj1

  !
  !================================================================================================================================
  !

  !>Gets the volume for a given user element number by a user number.
  SUBROUTINE OC_Field_GeometricParametersElementVolumeGetNumber(contextUserNumber,regionUserNumber,geometricFieldUserNumber, &
    & userElementNumber,elementVolume,err)
    !DLLEXPORT(OC_Field_GeometricParametersElementVolumeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the volume from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the volume from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element number to get the volume for
    REAL(DP), INTENT(OUT) :: elementVolume !<On return, the volume of the chosen element number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_GeometricParametersElementVolumeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(geometricField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL Field_GeometricParametersElementVolumeGet(geometricField,userElementNumber,elementVolume,err,error,*999)

    EXITS("OC_Field_GeometricParametersElementVolumeGetNumber")
    RETURN
999 ERRORS("OC_Field_GeometricParametersElementVolumeGetNumber",err,error)
    EXITS("OC_Field_GeometricParametersElementVolumeGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricParametersElementVolumeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the volume for a given user element number by an object.
  SUBROUTINE OC_Field_GeometricParametersElementVolumeGetObj(geometricField,userElementNumber,elementVolume,err)
    !DLLEXPORT(OC_Field_GeometricParametersElementVolumeGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the volume from
    INTEGER(INTG),  INTENT(IN) :: userElementNumber !<The user element to get the volume for
    REAL(DP), INTENT(OUT) :: elementVolume !<On return, the volume of the chosen element 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_GeometricParametersElementVolumeGetObj",err,error,*999)

    CALL Field_GeometricParametersElementVolumeGet(geometricField%field,userElementNumber,elementVolume, &
      & err,error,*999)

    EXITS("OC_Field_GeometricParametersElementVolumeGetObj")
    RETURN
999 ERRORS("OC_Field_GeometricParametersElementVolumeGetObj",err,error)
    EXITS("OC_Field_GeometricParametersElementVolumeGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_GeometricParametersElementVolumeGetObj


  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by a user number.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetNodeScaleFactorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorGetNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorGetNumber",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by an object.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorGetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetNodeScaleFactorGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorGet(field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorGetObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorGetObj",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorGetObj

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by a user number.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetNodeScaleFactorsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorsGetNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorsGetNumber",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorsGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by an object.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsGetObj(field,variableType,meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorsGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetNodeScaleFactorsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsGet(field%field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorsGetObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorsGetObj",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsGetObj
  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by a user number.
  SUBROUTINE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,meshComponentNumber,numberOfScaleFactorsDofs,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of scalefactors for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error)
    EXITS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by an object.
  SUBROUTINE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj(field,variableType,meshComponentNumber, &
    & numberOfScaleFactorsDofs,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field%field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error)
    EXITS("OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by a user number.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetNodeScaleFactorSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorSetNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorSetNumber",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by an object.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorSetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetNodeScaleFactorSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorSet(field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorSetObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorSetObj",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorSetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by a user number.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetNodeScaleFactorsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorsSetNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorsSetNumber",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorsSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by an object.
  SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsSetObj(field,variableType,meshComponentNumber,scaleFactors,err)
    !DLLEXPORT(OC_Field_ParameterSetNodeScaleFactorsSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetNodeScaleFactorsSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsSet(field%field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("OC_Field_ParameterSetNodeScaleFactorsSetObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetNodeScaleFactorsSetObj",err,error)
    EXITS("OC_Field_ParameterSetNodeScaleFactorsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetNodeScaleFactorsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by a user number.
  SUBROUTINE OC_Field_LabelGetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(OC_Field_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelGet(field,label,err,error,*999)

    EXITS("OC_Field_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_Field_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by an object.
  SUBROUTINE OC_Field_LabelGetCObj(field,label,err)
    !DLLEXPORT(OC_Field_LabelGetCObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_LabelGetCObj",err,error,*999)

    CALL Field_LabelGet(field%field,label,err,error,*999)

    EXITS("OC_Field_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Field_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by a user number.
  SUBROUTINE OC_Field_LabelGetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(OC_Field_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelGet(field,label,err,error,*999)

    EXITS("OC_Field_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Field_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by an object.
  SUBROUTINE OC_Field_LabelGetVSObj(field,label,err)
    !DLLEXPORT(OC_Field_LabelGetVSObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_LabelGetVSObj",err,error,*999)

    CALL Field_LabelGet(field%field,label,err,error,*999)

    EXITS("OC_Field_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Field_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by a user number.
  SUBROUTINE OC_Field_LabelSetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(OC_Field_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelSet(field,label,err,error,*999)

    EXITS("OC_Field_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_Field_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by an object.
  SUBROUTINE OC_Field_LabelSetCObj(field,label,err)
    !DLLEXPORT(OC_Field_LabelSetCObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_LabelSetCObj",err,error,*999)

    CALL Field_LabelSet(field%field,label,err,error,*999)

    EXITS("OC_Field_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Field_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by a user number.
  SUBROUTINE OC_Field_LabelSetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,label,err)
    !DLLEXPORT(OC_Field_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_LabelSet(field,label,err,error,*999)

    EXITS("OC_Field_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Field_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by an object.
  SUBROUTINE OC_Field_LabelSetVSObj(field,label,err)
    !DLLEXPORT(OC_Field_LabelSetVSObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_LabelSetVSObj",err,error,*999)

    CALL Field_LabelSet(field%field,label,err,error,*999)

    EXITS("OC_Field_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Field_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_PositionNormalTangentCalculateNodeNumber(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,componentNumber,localNodeNumber,position,normal,tangents,err)
    !DLLEXPORT(OC_Field_PositionNormalTangentCalculateNodeNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    REAL(DP) :: fullPosition(SIZE(position,1),MAXIMUM_GLOBAL_DERIV_NUMBER)
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_PositionNormalTangentCalculateNodeNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_PositionNormalTangentsCalculateNode(field,variableType,componentNumber,localNodeNumber, &
      & fullPosition,normal,tangents,err,error,*999)
    position(1:SIZE(position,1))=fullPosition(1:SIZE(position,1),NO_PHYSICAL_DERIV)

    EXITS("OC_Field_PositionNormalTangentCalculateNodeNumber")
    RETURN
999 ERRORS("OC_Field_PositionNormalTangentCalculateNodeNumber",err,error)
    EXITS("OC_Field_PositionNormalTangentCalculateNodeNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_PositionNormalTangentCalculateNodeNumber

  !
  !================================================================================================================================
  !

  !>Returns the position, normal and tangents for a field node for a field identified by an object.
  SUBROUTINE OC_Field_PositionNormalTangentCalculateNodeObj(field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err)
    !DLLEXPORT(OC_Field_PositionNormalTangentCalculateNodeObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    REAL(DP) :: fullPosition(SIZE(position,1),MAXIMUM_GLOBAL_DERIV_NUMBER)

    ENTERS("OC_Field_PositionNormalTangentCalculateNodeObj",err,error,*999)

    CALL Field_PositionNormalTangentsCalculateNode(field%field,variableType,componentNumber,localNodeNumber, &
      & fullPosition,normal,tangents,err,error,*999)
    position(1:SIZE(position,1))=fullPosition(1:SIZE(position,1),NO_PHYSICAL_DERIV)

    EXITS("OC_Field_PositionNormalTangentCalculateNodeObj")
    RETURN
999 ERRORS("OC_Field_PositionNormalTangentCalculateNodeObj",err,error)
    EXITS("OC_Field_PositionNormalTangentCalculateNodeObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_PositionNormalTangentCalculateNodeObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by a user number.
  SUBROUTINE OC_Field_DecompositionGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,decompositionUserNumber,err)
    !DLLEXPORT(OC_Field_DecompositionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(OUT) :: decompositionUserNumber !<On return, the field decomposition user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DecompositionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_DecompositionGet(field,decomposition,err,error,*999)
    decompositionUserNumber=decomposition%userNumber

    EXITS("OC_Field_DecompositionGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DecompositionGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DecompositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by an object.
  SUBROUTINE OC_Field_DecompositionGetObj(field,meshDecomposition,err)
    !DLLEXPORT(OC_Field_DecompositionGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(OC_DecompositionType), INTENT(INOUT) :: meshDecomposition !<On return, the mesh decomposition for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DecompositionGetObj",err,error,*999)

    CALL Field_DecompositionGet(field%field,meshDecomposition%decomposition,err,error,*999)

    EXITS("OC_Field_DecompositionGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DecompositionGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DecompositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by a user number.
  SUBROUTINE OC_Field_DecompositionSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,meshUserNumber, &
    & decompositionUserNumber,err)
    !DLLEXPORT(OC_Field_DecompositionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The field mesh decomposition user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DecompositionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(decomposition)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Field_DecompositionSet(field,decomposition,err,error,*999)

    EXITS("OC_Field_DecompositionSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DecompositionSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DecompositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by an object.
  SUBROUTINE OC_Field_DecompositionSetObj(field,meshDecomposition,err)
    !DLLEXPORT(OC_Field_DecompositionSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(OC_DecompositionType), INTENT(IN) :: meshDecomposition !<The mesh decomposition for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DecompositionSetObj",err,error,*999)

    CALL Field_DecompositionSet(field%field,meshDecomposition%decomposition,err,error,*999)

    EXITS("OC_Field_DecompositionSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DecompositionSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DecompositionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by a user number.
  SUBROUTINE OC_Field_DataProjectionSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,dataPointsUserNumber, &
    & dataProjectionUserNumber,err)
    !DLLEXPORT(OC_Field_DataProjectionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points on the data projection in the region.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The field data projection user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_DataProjectionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_DataPointsGet(region,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL Field_DataProjectionSet(field,dataProjection,err,error,*999)

    EXITS("OC_Field_DataProjectionSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_DataProjectionSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DataProjectionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by an object.
  SUBROUTINE OC_Field_DataProjectionSetObj(field,dataProjection,err)
    !DLLEXPORT(OC_Field_DataProjectionSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_DataProjectionSetObj",err,error,*999)

    CALL Field_DataProjectionSet(field%field,dataProjection%dataProjection,err,error,*999)

    EXITS("OC_Field_DataProjectionSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_DataProjectionSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_DataProjectionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_NumberOfComponentsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & numberOfComponents,err)
    !DLLEXPORT(OC_Field_NumberOfComponentsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfComponentsGet(field,variableType,numberOfComponents,err,error,*999)

    EXITS("OC_Field_NumberOfComponentsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfComponentsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_NumberOfComponentsGetObj(field,variableType,numberOfComponents,err)
    !DLLEXPORT(OC_Field_NumberOfComponentsGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_NumberOfComponentsGetObj",err,error,*999)

    CALL Field_NumberOfComponentsGet(field%field,variableType,numberOfComponents,err,error,*999)

    EXITS("OC_Field_NumberOfComponentsGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfComponentsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_NumberOfComponentsSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & numberOfComponents,err)
    !DLLEXPORT(OC_Field_NumberOfComponentsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfComponentsSet(field,variableType,numberOfComponents,err,error,*999)

    EXITS("OC_Field_NumberOfComponentsSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfComponentsSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_NumberOfComponentsSetObj(field,variableType,numberOfComponents,err)
    !DLLEXPORT(OC_Field_NumberOfComponentsSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_NumberOfComponentsSetObj",err,error,*999)

    CALL Field_NumberOfComponentsSet(field%field,variableType,numberOfComponents,err,error,*999)

    EXITS("OC_Field_NumberOfComponentsSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfComponentsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of DOFs for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_NumberOfDOFsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & numberOfDOFs,err)
    !DLLEXPORT(OC_Field_NumberOfDOFsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of DOFs for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of DOFs for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of DOFs for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfDOFs !<On return, the number of DOFs in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_NumberOfDOFsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfDOFsGet(field,variableType,numberOfDOFs,err,error,*999)

    EXITS("OC_Field_NumberOfDOFsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfDOFsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfDOFsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of DOFs for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_NumberOfDOFsGetObj(field,variableType,numberOfDOFs,err)
    !DLLEXPORT(OC_Field_NumberOfDOFsGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the number of DOFs for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of DOFs for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfDOFs !<On return, the number of DOFs in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_NumberOfDOFsGetObj",err,error,*999)

    CALL Field_NumberOfDOFsGet(field%field,variableType,numberOfDOFs,err,error,*999)

    EXITS("OC_Field_NumberOfDOFsGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfDOFsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfDOFsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of global DOFs for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_NumberOfGlobalDOFsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & numberOfGlobalDOFs,err)
    !DLLEXPORT(OC_Field_NumberOfGlobalDOFsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of global DOFs for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of global DOFs for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of global DOFs for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfGlobalDOFs !<On return, the number of global DOFs in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_NumberOfGlobalDOFsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfGlobalDOFsGet(field,variableType,numberOfGLobalDOFs,err,error,*999)

    EXITS("OC_Field_NumberOfGlobalDOFsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfGlobalDOFsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfGlobalDOFsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of global DOFs for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_NumberOfGlobalDOFsGetObj(field,variableType,numberOfGlobalDOFs,err)
    !DLLEXPORT(OC_Field_NumberOfGlobalDOFsGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the number of global DOFs for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of global DOFs for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfGlobalDOFs !<On return, the number of global DOFs in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_NumberOfGlobalDOFsGetObj",err,error,*999)

    CALL Field_NumberOfGlobalDOFsGet(field%field,variableType,numberOfGlobalDOFs,err,error,*999)

    EXITS("OC_Field_NumberOfGlobalDOFsGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfGlobalDOFsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfGlobalDOFsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by a user number.
  SUBROUTINE OC_Field_NumberOfVariablesGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,numberOfVariables,err)
    !DLLEXPORT(OC_Field_NumberOfVariablesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_NumberOfVariablesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfVariablesGet(field,numberOfVariables,err,error,*999)

    EXITS("OC_Field_NumberOfVariablesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfVariablesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfVariablesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by an object.
  SUBROUTINE OC_Field_NumberOfVariablesGetObj(field,numberOfVariables,err)
    !DLLEXPORT(OC_Field_NumberOfVariablesGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_NumberOfVariablesGetObj",err,error,*999)

    CALL Field_NumberOfVariablesGet(field%field,numberOfVariables,err,error,*999)

    EXITS("OC_Field_NumberOfVariablesGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfVariablesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/chnages the number of variables for a field identified by a user number.
  SUBROUTINE OC_Field_NumberOfVariablesSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,numberOfVariables,err)
    !DLLEXPORT(OC_Field_NumberOfVariablesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_NumberOfVariablesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_NumberOfVariablesSet(field,numberOfVariables,err,error,*999)

    EXITS("OC_Field_NumberOfVariablesSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfVariablesSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfVariablesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field identified by an object.
  SUBROUTINE OC_Field_NumberOfVariablesSetObj(field,numberOfVariables,err)
    !DLLEXPORT(OC_Field_NumberOfVariablesSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_NumberOfVariablesSetObj",err,error,*999)

    CALL Field_NumberOfVariablesSet(field%field,numberOfVariables,err,error,*999)

    EXITS("OC_Field_NumberOfVariablesSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_NumberOfVariablesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_NumberOfVariablesSetObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddConstantIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddConstantIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddConstantIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetAddConstantIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddConstantIntgObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddConstantSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddConstantSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddConstantSPObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddConstantDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddConstantDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddConstantDPObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddConstantLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddConstantLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddConstantLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddConstantLObj",err,error,*999)

    CALL Field_ParameterSetAddConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddConstantLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddConstantLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddConstantLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddElementIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddElementIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementIntgNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementIntgNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddElementIntgObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,UserElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddElementSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddElementSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddElementSPObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddElementDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddElementDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddElementDPObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddElementLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddElementLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddElementLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddElementLObj",err,error,*999)

    CALL Field_ParameterSetAddElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetAddElementLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddElementLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddElementLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to a Gauss point of an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss Point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddGaussPointIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to a Gauss point in an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointIntgObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddGaussPointIntgObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointIntgObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointIntgObj",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointIntgObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to a Gauss point in an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddGaussPointSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointSPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointSPNumber",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointSPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to a Gauss point in an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointSPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddGaussPointSPObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointSPObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointSPObj",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointSPObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to a Gauss point to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddGaussPointDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber,componentNumber, &
      & VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointDPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointDPNumber",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointDPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to a Gauss point of an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointDPObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointDPObj",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointDPObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to a Gauss point in an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddGaussPointLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointLNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointLNumber",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointLNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to a Gauss point in an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddGaussPointLObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetAddGaussPointLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to add the value to.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddGaussPointLObj",err,error,*999)

    CALL Field_ParameterSetAddGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddGaussPointLObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetAddGaussPointLObj",err,error)
    EXITS("OC_Field_ParameterSetAddGaussPointLObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddGaussPointLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddNodeIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddNodeIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeIntgNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeIntgNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddNodeIntgObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddNodeSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddNodeSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddNodeSPObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddNodeDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddNodeDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddNodeDPObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetAddNodeLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetAddNodeLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetAddNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetAddNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber, value,err)
    !DLLEXPORT(OC_Field_ParameterSetAddNodeLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetAddNodeLObj",err,error,*999)

    CALL Field_ParameterSetAddNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    EXITS("OC_Field_ParameterSetAddNodeLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetAddNodeLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetAddNodeLObj

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetCreateNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetCreateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetCreateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetCreate(field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetCreateNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetCreateNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetCreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetCreateObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetCreateObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to create the field parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetCreateObj",err,error,*999)

    CALL Field_ParameterSetCreate(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetCreateObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetCreateObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetCreateObj

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetDestroyNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDestroy(field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetDestroyObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetDestroyObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to destroy the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDestroyObj",err,error,*999)

    CALL Field_ParameterSetDestroy(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetDestroyObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataGetIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetIntgNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetIntgNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetIntgObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataGetIntgObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataGetSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetSPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetSPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataGetSPObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetSPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataGetDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetDPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetDPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataGetDPObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetDPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataGetLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataGet(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetLNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::OC_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE OC_Field_ParameterSetDataGetLObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataGetLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataGetLObj",err,error,*999)

    CALL Field_ParameterSetDataGet(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataGetLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataGetLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataGetLObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE OC_Field_ParameterSetDataRestoreIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataRestoreIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetDataRestoreIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetDataRestoreIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreIntgNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE OC_Field_ParameterSetDataRestoreIntgObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataRestoreIntgObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE OC_Field_ParameterSetDataRestoreSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataRestoreSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreSPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE OC_Field_ParameterSetDataRestoreSPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataRestoreSPObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE OC_Field_ParameterSetDataRestoreDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataRestoreDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreDPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE OC_Field_ParameterSetDataRestoreDPObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataRestoreDPObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE OC_Field_ParameterSetDataRestoreLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetDataRestoreLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetDataRestore(field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreLNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OpenCMISS::OC_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE OC_Field_ParameterSetDataRestoreLObj(field,variableType,fieldSetType,parameters,err)
    !DLLEXPORT(OC_Field_ParameterSetDataRestoreLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OpenCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetDataRestoreLObj",err,error,*999)

    CALL Field_ParameterSetDataRestore(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("OC_Field_ParameterSetDataRestoreLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetDataRestoreLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetDataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetConstantIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetConstantIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetConstantIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetGetConstantIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetConstantIntgObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetConstantSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetConstantSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetConstantSPObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetConstantDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetConstantDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetConstantDPObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetConstantLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetConstantLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetConstantLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetConstantLObj",err,error,*999)

    CALL Field_ParameterSetGetConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetConstantLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetConstantLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetConstantLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointIntgNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointIntgNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointIntgNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_FieldGet(INTERFACE,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointIntgNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetDataPointIntgNumberI",err,error)
    EXITS("OC_Field_ParameterSetGetDataPointIntgNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointIntgNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointIntgNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointIntgNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointIntgNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointIntgNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetDataPointIntgNumberR",err,error)
    EXITS("OC_Field_ParameterSetGetDataPointIntgNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetDataPointIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointSPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointSPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointSPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointSPNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetDataPointSPNumberI",err,error)
    EXITS("OC_Field_ParameterSetGetDataPointSPNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointSPNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointSPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointSPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointSPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointSPNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetDataPointSPNumberR",err,error)
    EXITS("OC_Field_ParameterSetGetDataPointSPNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetDataPointSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointDPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointDPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointDPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointDPNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetDataPointDPNumberI",err,error)
    EXITS("OC_Field_ParameterSetGetDataPointDPNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointDPNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointDPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointDPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointDPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointDPNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetDataPointDPNumberR",err,error)
    EXITS("OC_Field_ParameterSetGetDataPointDPNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetDataPointDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointLNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointLNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointLNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointLNumberI")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetDataPointLNumberI",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointLNumberI

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetDataPointLNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointLNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetDataPointLNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointLNumberR")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetDataPointLNumberR",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetDataPointLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetDataPointLObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetDataPointLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetDataPointLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetDataPointLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetElementIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetElementIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementIntgNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementIntgNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetElementIntgObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetElementSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetElementSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetElementSPObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetElementDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetElementDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetElementDPObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetElementLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetElementLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetElementLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetElementLObj",err,error,*999)

    CALL Field_ParameterSetGetElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetGetElementLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetElementLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetElementLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetNodeIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetNodeIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeIntgNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeIntgNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetNodeIntgObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetNodeSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetNodeSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetNodeSPObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetNodeDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetNodeDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetNodeDPObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetGetNodeLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetGetNodeLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetGetNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetGetNodeLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetNodeLObj",err,error,*999)

    CALL Field_ParameterSetGetNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetNodeLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetNodeLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetNodeLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetGetGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)
    !DLLEXPORT(OC_Field_ParameterSetGetGaussPointDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetGetGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetGetGaussPointDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetGetGaussPointDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetGaussPointDPObj
  !
  !================================================================================================================================
  !


  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateConstantIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateConstantIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateConstantIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateConstantIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantIntgObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateConstantIntgObj",err,error)
    EXITS("OC_Field_ParameterSetUpdateConstantIntgObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateConstantSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantSPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateConstantSPNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateConstantSPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateConstantSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateConstantSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateConstantDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantDPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateConstantDPNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateConstantDPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateConstantDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateConstantDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateConstantLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateConstant(field,variableType,fieldSetType,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantLNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateConstantLNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateConstantLNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateConstantLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateConstantLObj",err,error,*999)

    CALL Field_ParameterSetUpdateConstant(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateConstantLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateConstantLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateConstantLObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointIntgNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointIntgNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointIntgNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointIntgNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointIntgNumberI",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointIntgNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointIntgNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointIntgNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointIntgNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointIntgNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointIntgNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointIntgNumberR",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointIntgNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointIntgObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointIntgObj",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointIntgObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointIntgObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointSPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointSPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointSPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointSPNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointSPNumberI",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointSPNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointSPNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointSPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointSPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointSPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointSPNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointSPNumberR",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointSPNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateDataPointSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointSPObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointDPNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointDPNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointDPNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_FieldGet(INTERFACE,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointDPNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointDPNumberI",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointDPNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointDPNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointDPNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointDPNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointDPNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointDPNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointDPNumberR",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointDPNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateDataPointDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointLNumberI(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & fieldUserNumber,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointLNumberI)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointLNumberI",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointLNumberI")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointLNumberI",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointLNumberI")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointLNumberI

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointLNumberR(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userDataPointNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointLNumberR)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateDataPointLNumberR",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointLNumberR")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateDataPointLNumberR",err,error)
    EXITS("OC_Field_ParameterSetUpdateDataPointLNumberR")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateDataPointLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateDataPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateDataPointLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateDataPointLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateDataPointLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateElementIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateElementIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateElementIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateElementIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateElementIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateElementIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateElementSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateElementSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementSPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateElementSPNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateElementSPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateElementSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateElementSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateElementDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateElementDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementDPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateElementDPNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateElementDPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateElementDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateElementDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateElementLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateElementLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateElement(field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateElementLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateElementLObj",err,error,*999)

    CALL Field_ParameterSetUpdateElement(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateElementLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element data point of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateElementDataPointDPObj(field,variableType,fieldSetType,elementNumber,dataPointIndex, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateElementDataPointDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The user element number to update the data point for.
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point for the data points projected on this element.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateElementDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElementDataPoint(field%field,variableType,fieldSetType,elementNumber,&
      & dataPointIndex,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateElementDataPointDPObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateElementDataPointDPObj",err,error)
    EXITS("OC_Field_ParameterSetUpdateElementDataPointDPObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateElementDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateFinishNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateFinish(field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateFinishObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateFinishObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to finishe the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateFinishObj",err,error,*999)

    CALL Field_ParameterSetUpdateFinish(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateFinishObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateNodeIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateNodeIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeIntgNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeIntgNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE OC_Field_ParameterSetUpdateNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateNodeIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeIntgObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateNodeSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateNodeSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeSPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeSPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE OC_Field_ParameterSetUpdateNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber, componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateNodeSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeSPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateNodeDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateNodeDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeDPNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeDPNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE OC_Field_ParameterSetUpdateNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateNodeDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeDPObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateNodeLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateNodeLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateNode(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeLNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeLNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE OC_Field_ParameterSetUpdateNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateNodeLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateNodeLObj",err,error,*999)

    CALL Field_ParameterSetUpdateNode(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateNodeLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateNodeLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateNodeLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointIntgNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointIntgNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateGaussPointIntgNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointIntgNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointIntgNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointIntgNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointIntgObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber, value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointIntgObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateGaussPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointIntgObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointIntgObj",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointIntgObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointIntgObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointSPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointSPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateGaussPointSPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointSPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointSPNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointSPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointSPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointSPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateGaussPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointSPObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointSPObj",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointSPObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointSPObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointDPNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointDPNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateGaussPointDPNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointDPNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointDPNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointDPNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber, value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointDPObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointDPObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointDPObj",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointDPObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointDPObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointLNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,gaussPointNumber,userElementNumber,componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointLNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateGaussPointLNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,VALUE,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointLNumber")
    RETURN
999 ERRORS("OC_Field_ParameterSetUpdateGaussPointLNumber",err,error)
    EXITS("OC_Field_ParameterSetUpdateGaussPointLNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointLNumber

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateGaussPointLObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateGaussPointLObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateGaussPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateGaussPointLObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateGaussPointLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateGaussPointLObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetInterpolateXiDPNumber0(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,partialDerivativeType,userElementNumber,xi,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateXiDPNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetInterpolateXiDPNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateXi(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & xi,values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateXiDPNumber0")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateXiDPNumber0",err,error)
    EXITS("OC_Field_ParameterSetInterpolateXiDPNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateXiDPNumber0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetInterpolateXiDPObj0(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateXiDPObj0)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetInterpolateXiDPObj0",err,error,*999)

    CALL Field_ParameterSetInterpolateXi(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateXiDPObj0")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateXiDPObj0",err,error)
    EXITS("OC_Field_ParameterSetInterpolateXiDPObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateXiDPObj0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetInterpolateXiDPNumber1(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,partialDerivativeType,userElementNumber,xi,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateXiDPNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetInterpolateXiDPNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateXi(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & xi,values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateXiDPNumber1")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateXiDPNumber1",err,error)
    EXITS("OC_Field_ParameterSetInterpolateXiDPNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateXiDPNumber1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetInterpolateXiDPObj1(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
    & xi,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateXiDPObj1)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<xi(xiIdx,xiPointIdx). The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,xiPointIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetInterpolateXiDPObj1",err,error,*999)

    CALL Field_ParameterSetInterpolateXi(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateXiDPObj1")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateXiDPObj1",err,error)
    EXITS("OC_Field_ParameterSetInterpolateXiDPObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateXiDPObj1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a or a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPNumber0(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,partialDerivativeType,userElementNumber,quadratureScheme,gaussPointNumber,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateGaussDPNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetInterpolateGaussDPNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateGauss(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,gaussPointNumber,values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateGaussDPNumber0")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateGaussDPNumber0",err,error)
    EXITS("OC_Field_ParameterSetInterpolateGaussDPNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPNumber0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPObj0(field,variableType,fieldSetType,partialDerivativeType, &
    & userElementNumber,quadratureScheme,gaussPoint,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateGaussDPObj0)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolte. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<values(componentIdx). On return, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetInterpolateGaussDPObj",err,error,*999)

    CALL Field_ParameterSetInterpolateGauss(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,GaussPoint,values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateGaussDPObj0")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateGaussDPObj0",err,error)
    EXITS("OC_Field_ParameterSetInterpolateGaussDPObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPObj0

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a or a field identified by a user number. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPNumber1(contextUserNumber,regionUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,partialDerivativeType,userElementNumber,quadratureScheme,gaussPoints,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateGaussDPNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On return, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetInterpolateGaussDPNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetInterpolateGauss(field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,gaussPoints,values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateGaussDPNumber1")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateGaussDPNumber1",err,error)
    EXITS("OC_Field_ParameterSetInterpolateGaussDPNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPNumber1

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a field identified by an object. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPObj1(field,variableType,fieldSetType,partialDerivativeType, &
    & userElementNumber,quadratureScheme,gaussPoints,values,err)
    !DLLEXPORT(OC_Field_ParameterSetInterpolateGaussDPObj1)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to interpolate.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: partialDerivativeType !<The partial derivative type of the field to interpolate. \see OpenCMISS_PartialDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate at.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for. \see OpenCMISS_BasisQuadratureSchemes
    INTEGER(INTG), INTENT(IN) :: gaussPoints(:) !<gaussPoints(gaussPointIdx). The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<values(componentIdx,gaussPointIdx). On exit, the interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetInterpolateGaussDPObj1",err,error,*999)

    CALL Field_ParameterSetInterpolateGauss(field%field,variableType,fieldSetType,partialDerivativeType,userElementNumber, &
      & quadratureScheme,gaussPoints,values,err,error,*999)

    EXITS("OC_Field_ParameterSetInterpolateGaussDPObj1")
    RETURN
999 ERRORS("OC_Field_ParameterSetInterpolateGaussDPObj1",err,error)
    EXITS("OC_Field_ParameterSetInterpolateGaussDPObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetInterpolateGaussDPObj1

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_ParameterSetUpdateStartNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParameterSetUpdateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ParameterSetUpdateStart(field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_ParameterSetUpdateStartObj(field,variableType,fieldSetType,err)
    !DLLEXPORT(OC_Field_ParameterSetUpdateStartObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OpenCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ParameterSetUpdateStartObj",err,error,*999)

    CALL Field_ParameterSetUpdateStart(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("OC_Field_ParameterSetUpdateStartObj")
    RETURN
999 ERRORSEXITS("OC_Field_ParameterSetUpdateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetUpdateStartObj

  !
  !================================================================================================================================
  !

  !>Adds the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE OC_Field_ParametersToFieldParametersComponentAddNumber(contextUserNumber,fromRegionUserNumber, &
    & fromFieldUserNumber,fromVariableType,fromParameterSetType,fromComponentNumber,toRegionUserNumber, &
    & toFieldUserNumber,toVariableType,toParameterSetType,toComponentNumber,err)
    !DLLEXPORT(OC_Field_ParametersToFieldParametersComponentAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the regions.
    INTEGER(INTG), INTENT(IN) :: fromRegionUserNumber !<The user number of the region containing the field to add from
    INTEGER(INTG), INTENT(IN) :: fromFieldUserNumber !<The field to add from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to add from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to add from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to add from
    INTEGER(INTG), INTENT(IN) :: toRegionUserNumber !<The user number of the region containing the field to add to
    INTEGER(INTG), INTENT(IN) :: toFieldUserNumber !<The field to add to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to add to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to add to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to add to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: fromField,toField
    TYPE(RegionType), POINTER :: fromRegion,toRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParametersToFieldParametersComponentAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(fromRegion)
    NULLIFY(toRegion)
    NULLIFY(fromField)
    NULLIFY(toField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,fromRegionUserNumber,fromRegion,err,error,*999)
    CALL Region_FieldGet(fromRegion,fromFieldUserNumber,fromField,err,error,*999)
    CALL Region_Get(regions,toRegionUserNumber,toRegion,err,error,*999)
    CALL Region_FieldGet(toRegion,toFieldUserNumber,toField,err,error,*999)
    CALL Field_ParametersToFieldParametersAdd(fromField,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    EXITS("OC_Field_ParametersToFieldParametersComponentAddNumber")
    RETURN
999 ERRORS("OC_Field_ParametersToFieldParametersComponentAddNumber",err,error)
    EXITS("OC_Field_ParametersToFieldParametersComponentAddNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParametersToFieldParametersComponentAddNumber

  !
  !================================================================================================================================
  !

  !>Adds the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE OC_Field_ParametersToFieldParametersComponentAddObj(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err)
    !DLLEXPORT(OC_Field_ParametersToFieldParametersComponentAddObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: fromField !<The field to add from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to add from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to add from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to add from
    TYPE(OC_FieldType), INTENT(IN) :: toField !<The field to add to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to add to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to add to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to add to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_Field_ParametersToFieldParametersComponentAddObj",err,error,*999)

    CALL Field_ParametersToFieldParametersAdd(fromField%field,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField%field,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    EXITS("OC_Field_ParametersToFieldParametersComponentAddObj")
    RETURN
999 ERRORS("OC_Field_ParametersToFieldParametersComponentAddObj",err,error)
    EXITS("OC_Field_ParametersToFieldParametersComponentAddObj")
    CALL OC_HandleError(err,error)
    RETURN
    
  END SUBROUTINE OC_Field_ParametersToFieldParametersComponentAddObj

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE OC_Field_ParametersToFieldParametersComponentCopyNumber(contextUserNumber,fromRegionUserNumber, &
    & fromFieldUserNumber,fromVariableType,fromParameterSetType,fromComponentNumber,toRegionUserNumber, &
    & toFieldUserNumber,toVariableType,toParameterSetType,toComponentNumber,err)
    !DLLEXPORT(OC_Field_ParametersToFieldParametersComponentCopyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the regions.
    INTEGER(INTG), INTENT(IN) :: fromRegionUserNumber !<The user number of the region containing the field to copy from
    INTEGER(INTG), INTENT(IN) :: fromFieldUserNumber !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    INTEGER(INTG), INTENT(IN) :: toRegionUserNumber !<The user number of the region containing the field to copy to
    INTEGER(INTG), INTENT(IN) :: toFieldUserNumber !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: fromField,toField
    TYPE(RegionType), POINTER :: fromRegion,toRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ParametersToFieldParametersComponentCopyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(fromRegion)
    NULLIFY(toRegion)
    NULLIFY(fromField)
    NULLIFY(toField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,fromRegionUserNumber,fromRegion,err,error,*999)
    CALL Region_FieldGet(fromRegion,fromFieldUserNumber,fromField,err,error,*999)
    CALL Region_Get(regions,toRegionUserNumber,toRegion,err,error,*999)
    CALL Region_FieldGet(toRegion,toFieldUserNumber,toField,err,error,*999)
    CALL Field_ParametersToFieldParametersCopy(fromField,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    EXITS("OC_Field_ParametersToFieldParametersComponentCopyNumber")
    RETURN
999 ERRORS("OC_Field_ParametersToFieldParametersComponentCopyNumber",err,error)
    EXITS("OC_Field_ParametersToFieldParametersComponentCopyNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParametersToFieldParametersComponentCopyNumber

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE OC_Field_ParametersToFieldParametersComponentCopyObj(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err)
    !DLLEXPORT(OC_Field_ParametersToFieldParametersComponentCopyObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: fromField !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(OC_FieldType), INTENT(IN) :: toField !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("OC_Field_ParametersToFieldParametersComponentCopyObj",err,error,*999)

    CALL Field_ParametersToFieldParametersCopy(fromField%field,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField%field,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    EXITS("OC_Field_ParametersToFieldParametersComponentCopyObj")
    RETURN
999 ERRORS("OC_Field_ParametersToFieldParametersComponentCopyObj",err,error)
    EXITS("OC_Field_ParametersToFieldParametersComponentCopyObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParametersToFieldParametersComponentCopyObj

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by a user number.
  SUBROUTINE OC_Field_ScalingTypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,scalingType,err)
    !DLLEXPORT(OC_Field_ScalingTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ScalingTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ScalingTypeGet(field,scalingType,err,error,*999)

    EXITS("OC_Field_ScalingTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ScalingTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ScalingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by an object.
  SUBROUTINE OC_Field_ScalingTypeGetObj(field,scalingType,err)
    !DLLEXPORT(OC_Field_ScalingTypeGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ScalingTypeGetObj",err,error,*999)

    CALL Field_ScalingTypeGet(field%field,scalingType,err,error,*999)

    EXITS("OC_Field_ScalingTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_ScalingTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ScalingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by a user number.
  SUBROUTINE OC_Field_ScalingTypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,scalingType,err)
    !DLLEXPORT(OC_Field_ScalingTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_ScalingTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_ScalingTypeSet(field,scalingType,err,error,*999)

    EXITS("OC_Field_ScalingTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_ScalingTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ScalingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by an object.
  SUBROUTINE OC_Field_ScalingTypeSetObj(field,scalingType,err)
    !DLLEXPORT(OC_Field_ScalingTypeSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OpenCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_ScalingTypeSetObj",err,error,*999)

    CALL Field_ScalingTypeSet(field%field,scalingType,err,error,*999)

    EXITS("OC_Field_ScalingTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_ScalingTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ScalingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the total number of DOFs for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_TotalNumberOfDOFsGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType, &
    & totalNumberOfDOFs,err)
    !DLLEXPORT(OC_Field_TotalNumberOfDOFsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the total number of DOFs for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the total number of DOFs for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the total number of DOFs for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: totalNumberOfDOFs !<On return, the total number of DOFs in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_TotalNumberOfDOFsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_TotalNumberOfDOFsGet(field,variableType,totalNumberOfDOFs,err,error,*999)

    EXITS("OC_Field_TotalNumberOfDOFsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_TotalNumberOfDOFsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_TotalNumberOfDOFsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the total number of DOFs for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_TotalNumberOfDOFsGetObj(field,variableType,totalNumberOfDOFs,err)
    !DLLEXPORT(OC_Field_TotalNumberOfDOFsGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the total number of DOFs for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the total number of DOFs for. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: totalNumberOfDOFs !<On return, the total number of DOFs in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_TotalNumberOfDOFsGetObj",err,error,*999)

    CALL Field_TotalNumberOfDOFsGet(field%field,variableType,totalNumberOfDOFs,err,error,*999)

    EXITS("OC_Field_TotalNumberOfDOFsGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_TotalNumberOfDOFsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_TotalNumberOfDOFsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the field type for a field identified by a user number.
  SUBROUTINE OC_Field_TypeGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,fieldType_,err)
    !DLLEXPORT(OC_Field_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType_ !<On return, the field type. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_TypeGet(field,fieldType_,err,error,*999)

    EXITS("OC_Field_TypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_TypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type for a field identified by an object.
  SUBROUTINE OC_Field_TypeGetObj(field,fieldType_,err)
    !DLLEXPORT(OC_Field_TypeGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType_ !<On return, the field type. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_TypeGetObj",err,error,*999)

    CALL Field_TypeGet(field%field,fieldType_,err,error,*999)

    EXITS("OC_Field_TypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_TypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field identified by a user number.
  SUBROUTINE OC_Field_TypeSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,fieldType_,err)
    !DLLEXPORT(OC_Field_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType_ !<The field type to set. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_TypeSet(field,fieldType_,err,error,*999)

    EXITS("OC_Field_TypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_TypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a field identified by an object.
  SUBROUTINE OC_Field_TypeSetObj(field,fieldType_,err)
    !DLLEXPORT(OC_Field_TypeSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType_ !<The field type to set. \see OpenCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_TypeSetObj",err,error,*999)

    CALL Field_TypeSet(field%field,fieldType_,err,error,*999)

    EXITS("OC_Field_TypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_TypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_VariableLabelGetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_VariableLabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelGet(field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_VariableLabelGetCObj(field,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelGetCObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_VariableLabelGetCObj",err,error,*999)

    CALL Field_VariableLabelGet(field%field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_VariableLabelGetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_VariableLabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelGet(field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_VariableLabelGetVSObj(field,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelGetVSObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_VariableLabelGetVSObj",err,error,*999)

    CALL Field_VariableLabelGet(field%field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_VariableLabelSetCNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_VariableLabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelSet(field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_VariableLabelSetCObj(field,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelSetCObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_VariableLabelSetCObj",err,error,*999)

    CALL Field_VariableLabelSet(field%field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE OC_Field_VariableLabelSetVSNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_VariableLabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableLabelSet(field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by an object.
  SUBROUTINE OC_Field_VariableLabelSetVSObj(field,variableType,label,err)
    !DLLEXPORT(OC_Field_VariableLabelSetVSObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OpenCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_VariableLabelSetVSObj",err,error,*999)

    CALL Field_VariableLabelSet(field%field,variableType,label,err,error,*999)

    EXITS("OC_Field_VariableLabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Field_VariableLabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the field variable types for a field identified by a user number.
  SUBROUTINE OC_Field_VariableTypesGetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableTypes,err)
    !DLLEXPORT(OC_Field_VariableTypesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variableIdx). On return, the field variable types for the variableIdx'th field variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_VariableTypesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableTypesGet(field,variableTypes,err,error,*999)

    EXITS("OC_Field_VariableTypesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_VariableTypesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableTypesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the variable types for a field identified by an object.
  SUBROUTINE OC_Field_VariableTypesGetObj(field,variableTypes,err)
    !DLLEXPORT(OC_Field_VariableTypesGetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variableIdx). On return, the field variable types for the variableIdx'th field variable. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_VariableTypesGetObj",err,error,*999)

    CALL Field_VariableTypesGet(field%field,variableTypes,err,error,*999)

    EXITS("OC_Field_VariableTypesGetObj")
    RETURN
999 ERRORSEXITS("OC_Field_VariableTypesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field identified by a user number.
  SUBROUTINE OC_Field_VariableTypesSetNumber(contextUserNumber,regionUserNumber,fieldUserNumber,variableTypes,err)
    !DLLEXPORT(OC_Field_VariableTypesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context which has the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variableIdx). The field variable types for the variableIdx'th field variable to set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Field_VariableTypesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Field_VariableTypesSet(field,variableTypes,err,error,*999)

    EXITS("OC_Field_VariableTypesSetNumber")
    RETURN
999 ERRORSEXITS("OC_Field_VariableTypesSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableTypesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the variable types for a field identified by an object.
  SUBROUTINE OC_Field_VariableTypesSetObj(field,variableTypes,err)
    !DLLEXPORT(OC_Field_VariableTypesSetObj)

    !Argument variables
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variableIdx). The field variable types for the variableIdx'th field variable to set. \see OpenCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Field_VariableTypesSetObj",err,error,*999)

    CALL Field_VariableTypesSet(field%field,variableTypes,err,error,*999)

    EXITS("OC_Field_VariableTypesSetObj")
    RETURN
999 ERRORSEXITS("OC_Field_VariableTypesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_VariableTypesSetObj

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !>Export element information for fields set identified by user number. 
  SUBROUTINE OC_Fields_ElementsExportCCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportCCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength,MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName,VMethod

    ENTERS("OC_Fields_ElementsExportCCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,VFileName,VMethod,err,error,*999)

    EXITS("OC_Fields_ElementsExportCCNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportCCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportCCNumber

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by user number. 
  SUBROUTINE OC_Fields_ElementsExportVSCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportVSCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VMethod

    ENTERS("OC_Fields_ElementsExportVSCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,fileName,VMethod,err,error,*999)

    EXITS("OC_Fields_ElementsExportVSCNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportVSCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportVSCNumber

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by user number
  SUBROUTINE OC_Fields_ElementsExportCVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportCVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName

    ENTERS("OC_Fields_ElementsExportCVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,VFileName,method,err,error,*999)

    EXITS("OC_Fields_ElementsExportCVSNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportCVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportCVSNumber

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by user number.
  SUBROUTINE OC_Fields_ElementsExportVSVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportVSVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Fields_ElementsExportVSVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)

    CALL FIELD_IO_ELEMENTS_EXPORT(region%fields,fileName,method,err,error,*999)

    EXITS("OC_Fields_ElementsExportVSVSNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportVSVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportVSVSNumber

  !  
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object. 
  SUBROUTINE OC_Fields_ElementsExportCCObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportCCObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    ENTERS("OC_Fields_ElementsExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,VFileName,VMethod,err,error,*999)

    EXITS("OC_Fields_ElementsExportCCObj")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportCCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportCCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object.
  SUBROUTINE OC_Fields_ElementsExportVSCObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportVSCObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    ENTERS("OC_Fields_ElementsExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,fileName,VMethod,err,error,*999)

    EXITS("OC_Fields_ElementsExportVSCObj")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportVSCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportVSCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object.
  SUBROUTINE OC_Fields_ElementsExportCVSObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportCVSObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    ENTERS("OC_Fields_ElementsExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,VFileName,method,err,error,*999)

    EXITS("OC_Fields_ElementsExportCVSObj")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportCVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object.
  SUBROUTINE OC_Fields_ElementsExportVSVSObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_ElementsExportVSVSObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_ElementsExportVSVSObj",err,error,*999)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,fileName,method,err,error,*999)

    EXITS("OC_Fields_ElementsExportVSVSObj")
    RETURN
999 ERRORSEXITS("OC_Fields_ElementsExportVSVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_ElementsExportVSVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number
  SUBROUTINE OC_Fields_NodesExportCCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportCCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength,MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName,VMethod

    ENTERS("OC_Fields_NodesExportCCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(region%fields,VFileName,VMethod,err,error,*999)

    EXITS("OC_Fields_NodesExportCCNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportCCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportCCNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number
  SUBROUTINE OC_Fields_NodesExportVSCNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportVSCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: MethodLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VMethod

    ENTERS("OC_Fields_NodesExportVSCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(region%fields,fileName,VMethod,err,error,*999)

    EXITS("OC_Fields_NodesExportVSCNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportVSCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportVSCNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number
  SUBROUTINE OC_Fields_NodesExportCVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportCVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: FileNameLength
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(VARYING_STRING) :: VFileName

    ENTERS("OC_Fields_NodesExportCVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(region%fields,VFileName,method,err,error,*999)

    EXITS("OC_Fields_NodesExportCVSNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportCVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportCVSNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by user number.
  SUBROUTINE OC_Fields_NodesExportVSVSNumber(contextUserNumber,regionUserNumber,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportVSVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context containing the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to export
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Fields_NodesExportVSVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)

    CALL FIELD_IO_NODES_EXPORT(region%fields,fileName,method,err,error,*999)

    EXITS("OC_Fields_NodesExportVSVSNumber")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportVSVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportVSVSNumber

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE OC_Fields_NodesExportCCObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportCCObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    ENTERS("OC_Fields_NodesExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,VFileName,VMethod,err,error,*999)

    EXITS("OC_Fields_NodesExportCCObj")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportCCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportCCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE OC_Fields_NodesExportVSCObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportVSCObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    ENTERS("OC_Fields_NodesExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,fileName,VMethod,err,error,*999)

    EXITS("OC_Fields_NodesExportVSCObj")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportVSCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportVSCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE OC_Fields_NodesExportCVSObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportCVSObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    ENTERS("OC_Fields_NodesExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,VFileName,method,err,error,*999)

    EXITS("OC_Fields_NodesExportCVSObj")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportCVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object.
  SUBROUTINE OC_Fields_NodesExportVSVSObj(fields,fileName,method,err)
    !DLLEXPORT(OC_Fields_NodesExportVSVSObj)

    !Argument variables
    TYPE(OC_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Fields_NodesExportVSVSObj",err,error,*999)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,fileName,method,err,error,*999)

    EXITS("OC_Fields_NodesExportVSVSObj")
    RETURN
999 ERRORSEXITS("OC_Fields_NodesExportVSVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Fields_NodesExportVSVSObj

!!==================================================================================================================================
!!
!! GeneratedMeshRoutines
!!
!!==================================================================================================================================

  !>Returns the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_BasisGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)
    !DLLEXPORT(OC_GeneratedMesh_BasisGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(INOUT) :: basisUserNumbers(:) !<On return, the user numbers of the bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisPtrType), POINTER :: bases(:)
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    INTEGER(INTG) :: basisIdx,numberOfBases
    TYPE(VARYING_STRING) :: localError

    ENTERS("OC_GeneratedMesh_BasisGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    NULLIFY(bases)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_BasisGet(generatedMesh,bases,err,error,*999)
    numberOfBases=SIZE(bases)
    IF(SIZE(basisUserNumbers)<numberOfBases) THEN
      localError="The basis user numbers array must have a size of at least "// &
        & TRIM(NumberToVString(numberOfBases,"*",err,error))// &
        & ". However, it has a size of " &
        & //TRIM(NumberToVString(SIZE(basisUserNumbers),"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END IF
    DO basisIdx=1,numberOfBases
      IF(ASSOCIATED(bases(basisIdx)%ptr)) THEN
        basisUserNumbers(basisIdx)=bases(basisIdx)%PTR%userNumber
      ELSE
        localError="The basis with index "//TRIM(NumberToVString(basisIdx,"*",err,error))// &
          & " is not associated for the generated mesh with a user number of "// &
          & TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ENDDO !basisIdx

    EXITS("OC_GeneratedMesh_BasisGetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BasisGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_BasisGetObj(generatedMesh,bases,err)
    !DLLEXPORT(OC_GeneratedMesh_BasisGetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the basis for.
    TYPE(OC_BasisType), INTENT(INOUT) :: bases(:) !<On return, the array of bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisPtrType), POINTER :: bases2(:)
    INTEGER(INTG) :: basisIdx,numberOfBases
    TYPE(VARYING_STRING) :: localError

    ENTERS("OC_GeneratedMesh_BasisGetObj",err,error,*999)

    NULLIFY(bases2)
    CALL GeneratedMesh_BasisGet(generatedMesh%generatedMesh,bases2,err,error,*999)
    IF(ASSOCIATED(bases2)) THEN
      numberOfBases=SIZE(bases2)
      IF(SIZE(bases)<numberOfBases) THEN
        localError="The bases array must have a size of at least "// &
          & TRIM(NumberToVString(numberOfBases,"*",err,error))// &
          & ". However, it has a size of " &
          & //TRIM(NumberToVString(SIZE(bases),"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
      DO basisIdx=1,numberOfBases
        bases(basisIdx)%basis=>bases2(basisIdx)%ptr
      ENDDO !basisIdx
    ELSE
      localError="The bases are not associated for the generated mesh."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("OC_GeneratedMesh_BasisGetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BasisGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_BasisSetNumber0(contextUserNumber,regionUserNumber,generatedMeshUserNumber,basisUserNumber,err)
    !DLLEXPORT(OC_GeneratedMesh_BasisSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_BasisSetNumber0",err,error,*999)

    CALL OC_GeneratedMesh_BasisSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber,[basisUserNumber],err)

    EXITS("OC_GeneratedMesh_BasisSetNumber0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BasisSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BasisSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_BasisSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)
    !DLLEXPORT(OC_GeneratedMesh_BasisSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumbers(:) !<The user numbers of the bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisPtrType), POINTER :: bases(:)
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    INTEGER(INTG) :: basisIdx,numberOfBases

    ENTERS("OC_GeneratedMesh_BasisSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    NULLIFY(bases)
    numberOfBases=SIZE(basisUserNumbers)
    ALLOCATE(bases(numberOfBases),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)

    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    DO basisIdx=1,numberOfBases
      NULLIFY(basis)
      CALL Basis_Get(basisFunctions,basisUserNumbers(basisIdx),basis,err,error,*999)
      bases(basisIdx)%ptr=>basis
    ENDDO !basisIdx
    CALL GeneratedMesh_BasisSet(generatedMesh,bases,err,error,*999)

    EXITS("OC_GeneratedMesh_BasisSetNumber1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BasisSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BasisSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_BasisSetObj0(generatedMesh,basis,err)
    !DLLEXPORT(OC_GeneratedMesh_BasisSetObj0)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_BasisSetObj0",err,error,*999)

    CALL OC_GeneratedMesh_BasisSetObj1(generatedMesh,[basis],err)

    EXITS("OC_GeneratedMesh_BasisSetObj0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BasisSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BasisSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_BasisSetObj1(generatedMesh,bases,err)
    !DLLEXPORT(OC_GeneratedMesh_BasisSetObj1)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(OC_BasisType), INTENT(IN) :: bases(:) !<The bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basisIdx
    TYPE(BasisPtrType), ALLOCATABLE :: bases2(:)
    TYPE(VARYING_STRING) :: localError

    ENTERS("OC_GeneratedMesh_BasisSetObj1",err,error,*999)

    ALLOCATE(bases2(SIZE(bases,1)),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)
    DO basisIdx=1,SIZE(bases,1)
      IF(ASSOCIATED(bases(basisIdx)%basis)) THEN
        bases2(basisIdx)%ptr=>bases(basisIdx)%basis
      ELSE
        localError="The basis for index "//TRIM(NumberToVString(basisIdx,"*",err,error))//" is not associated."
        CALL FlagError(localError,err,error,*999)
      END IF
    ENDDO !basisIdx
    CALL GeneratedMesh_BasisSet(generatedMesh%generatedMesh,bases2,err,error,*999)

    EXITS("OC_GeneratedMesh_BasisSetObj1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BasisSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BasisSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_BaseVectorsSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,baseVectors,err)
    !DLLEXPORT(OC_GeneratedMesh_BaseVectorsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the base vectors for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_BaseVectorsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_BaseVectorsSet(generatedMesh,baseVectors,err,error,*999)

    EXITS("OC_GeneratedMesh_BaseVectorsSetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BaseVectorsSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BaseVectorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_BaseVectorsSetObj(generatedMesh,baseVectors,err)
    !DLLEXPORT(OC_GeneratedMesh_BaseVectorsSetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_BaseVectorsSetObj",err,error,*999)

    CALL GeneratedMesh_BaseVectorsSet(generatedMesh%generatedMesh,baseVectors,err,error,*999)

    EXITS("OC_GeneratedMesh_BaseVectorsSetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_BaseVectorsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_BaseVectorsSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_CreateFinishNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,meshUserNumber,err)
    !DLLEXPORT(OC_GeneratedMesh_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_CreateFinish(generatedMesh,meshUserNumber,mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    EXITS("OC_GeneratedMesh_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_CreateFinishObj(generatedMesh,meshUserNumber,mesh,err)
    !DLLEXPORT(OC_GeneratedMesh_CreateFinishObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    TYPE(OC_MeshType), INTENT(INOUT) :: mesh !<On return, the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_CreateFinishObj",err,error,*999)

    CALL GeneratedMesh_CreateFinish(generatedMesh%generatedMesh,meshUserNumber,mesh%mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    EXITS("OC_GeneratedMesh_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_CreateStartNumber(generatedMeshUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_GeneratedMesh_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the generated mesh in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL GeneratedMesh_CreateStart(generatedMeshUserNumber,region,generatedMesh,err,error,*999)

    EXITS("OC_GeneratedMesh_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on an interface identified by an object.
  SUBROUTINE OC_GeneratedMesh_CreateStartInterfaceObj(generatedMeshUserNumber,interface,generatedMesh,err)
    !DLLEXPORT(OC_GeneratedMesh_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(OC_InterfaceType), INTENT(INOUT) :: interface !<The interface to created generated mesh in.
    TYPE(OC_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_CreateStartInterfaceObj",err,error,*999)

    CALL GeneratedMesh_CreateStart(generatedMeshUserNumber,interface%interface,generatedMesh%generatedMesh,err,error,*999)

    EXITS("OC_GeneratedMesh_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_CreateStartInterfaceObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by an object.
  SUBROUTINE OC_GeneratedMesh_CreateStartRegionObj(generatedMeshUserNumber,region,generatedMesh,err)
    !DLLEXPORT(OC_GeneratedMesh_CreateStartRegionObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(OC_RegionType), INTENT(INOUT) :: region !<The region to created generated mesh in.
    TYPE(OC_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    CALL GeneratedMesh_CreateStart(generatedMeshUserNumber,region%region,generatedMesh%generatedMesh,err,error,*999)

    EXITS("OC_GeneratedMesh_CreateStartRegionObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_CreateStartRegionObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_DestroyNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,err)
    !DLLEXPORT(OC_GeneratedMesh_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_Destroy(generatedMesh,err,error,*999)

    EXITS("OC_GeneratedMesh_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_DestroyObj(generatedMesh,err)
    !DLLEXPORT(OC_GeneratedMesh_DestroyObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<The generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_DestroyObj",err,error,*999)

    CALL GeneratedMesh_Destroy(generatedMesh%generatedMesh,err,error,*999)

    EXITS("OC_GeneratedMesh_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_DestroyObj
  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_ExtentGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,extent,err)
    !DLLEXPORT(OC_GeneratedMesh_ExtentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_ExtentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_ExtentGet(generatedMesh,extent,err,error,*999)

    EXITS("OC_GeneratedMesh_ExtentGetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_ExtentGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_ExtentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_ExtentGetObj(generatedMesh,extent,err)
    !DLLEXPORT(OC_GeneratedMesh_ExtentGetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_ExtentGetObj",err,error,*999)

    CALL GeneratedMesh_ExtentGet(generatedMesh%generatedMesh,extent,err,error,*999)

    EXITS("OC_GeneratedMesh_ExtentGetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_ExtentGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_ExtentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_ExtentSetNumber0(contextUserNumber,regionUserNumber,generatedMeshUserNumber,extent,err)
    !DLLEXPORT(OC_GeneratedMesh_ExtentSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent !<The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("OC_GeneratedMesh_ExtentSetNumber0",err,error,*999)

    CALL OC_GeneratedMesh_ExtentSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber,[extent],err)

    EXITS("OC_GeneratedMesh_ExtentSetNumber0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_ExtentSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_ExtentSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_ExtentSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber,extent,err)
    !DLLEXPORT(OC_GeneratedMesh_ExtentSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_ExtentSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_ExtentSet(generatedMesh,extent,err,error,*999)

    EXITS("OC_GeneratedMesh_ExtentSetNumber1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_ExtentSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_ExtentSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_ExtentSetObj0(generatedMesh,extent,err)
    !DLLEXPORT(OC_GeneratedMesh_ExtentSetObj0)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent !<The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_ExtentSetObj0",err,error,*999)

    CALL GeneratedMesh_ExtentSet(generatedMesh%generatedMesh,[extent],err,error,*999)

    EXITS("OC_GeneratedMesh_ExtentSetObj0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_ExtentSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_ExtentSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_ExtentSetObj1(generatedMesh,extent,err)
    !DLLEXPORT(OC_GeneratedMesh_ExtentSetObj1)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). the extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_ExtentSetObj1",err,error,*999)

    CALL GeneratedMesh_ExtentSet(generatedMesh%generatedMesh,extent,err,error,*999)

    EXITS("OC_GeneratedMesh_ExtentSetObj1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_ExtentSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_ExtentSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_NumberOfElementsGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
    & numberOfElements,err)
    !DLLEXPORT(OC_GeneratedMesh_NumberOfElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_NumberOfElementsGet(generatedMesh,numberOfElements,err,error,*999)

    EXITS("OC_GeneratedMesh_NumberOfElementsGetNumber")
    RETURN
999 ERRORS("OC_GeneratedMesh_NumberOfElementsGetNumber",err,error)
    EXITS("OC_GeneratedMesh_NumberOfElementsGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_NumberOfElementsGetObj(generatedMesh,numberOfElements,err)
    !DLLEXPORT(OC_GeneratedMesh_NumberOfElementsGetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_NumberOfElementsGetObj",err,error,*999)

    CALL GeneratedMesh_NumberOfElementsGet(generatedMesh%generatedMesh,numberOfElements,err,error,*999)

    EXITS("OC_GeneratedMesh_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_NumberOfElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetNumber0(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
    & numberOfElements,err)
    !DLLEXPORT(OC_GeneratedMesh_NumberOfElementsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_NumberOfElementsSetNumber0",err,error,*999)

    CALL OC_GeneratedMesh_NumberOfElementsSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
      & [numberOfElements],err)

    EXITS("OC_GeneratedMesh_NumberOfElementsSetNumber0")
    RETURN
999 ERRORS("OC_GeneratedMesh_NumberOfElementsSetNumber0",err,error)
    EXITS("OC_GeneratedMesh_NumberOfElementsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetNumber1(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
    & numberOfElements,err)
    !DLLEXPORT(OC_GeneratedMesh_NumberOfElementsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_NumberOfElementsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_NumberOfElementsSet(generatedMesh,numberOfElements,err,error,*999)

    EXITS("OC_GeneratedMesh_NumberOfElementsSetNumber1")
    RETURN
999 ERRORS("OC_GeneratedMesh_NumberOfElementsSetNumber1",err,error)
    EXITS("OC_GeneratedMesh_NumberOfElementsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetObj0(generatedMesh,numberOfElements,err)
    !DLLEXPORT(OC_GeneratedMesh_NumberOfElementsSetObj0)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElementS !<The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_NumberOfElementsSetObj0",err,error,*999)

    CALL GeneratedMesh_NumberOfElementsSet(generatedMesh%generatedMesh,[numberOfElements],err,error,*999)

    EXITS("OC_GeneratedMesh_NumberOfElementsSetObj0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_NumberOfElementsSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetObj1(generatedMesh,numberOfElements,err)
    !DLLEXPORT(OC_GeneratedMesh_NumberOfElementsSetObj1)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_NumberOfElementsSetObj1",err,error,*999)

    CALL GeneratedMesh_NumberOfElementsSet(generatedMesh%generatedMesh,numberOfElements,err,error,*999)

    EXITS("OC_GeneratedMesh_NumberOfElementsSetObj1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_NumberOfElementsSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_NumberOfElementsSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_OriginGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,origin,err)
    !DLLEXPORT(OC_GeneratedMesh_OriginGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_OriginGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_OriginGet(generatedMesh,origin,err,error,*999)

    EXITS("OC_GeneratedMesh_OriginGetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_OriginGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_OriginGetObj(generatedMesh,origin,err)
    !DLLEXPORT(OC_GeneratedMesh_OriginGetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_OriginGetObj",err,error,*999)

    CALL GeneratedMesh_OriginGet(generatedMesh%generatedMesh,origin,err,error,*999)

    EXITS("OC_GeneratedMesh_OriginGetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_OriginGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_OriginSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,origin,err)
    !DLLEXPORT(OC_GeneratedMesh_OriginSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_OriginSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_OriginSet(generatedMesh,origin,err,error,*999)

    EXITS("OC_GeneratedMesh_OriginSetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_OriginSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_OriginSetObj(generatedMesh,origin,err)
    !DLLEXPORT(OC_GeneratedMesh_OriginSetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_OriginSetObj",err,error,*999)

    CALL GeneratedMesh_OriginSet(generatedMesh%generatedMesh,origin,err,error,*999)

    EXITS("OC_GeneratedMesh_OriginSetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_OriginSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_TypeGetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,generatedMeshType_,err)
    !DLLEXPORT(OC_GeneratedMesh_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType_ !<On return, the type of the generated mesh. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_TypeGet(generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("OC_GeneratedMesh_TypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_TypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_TypeGetObj(generatedMesh,generatedMeshType_,err)
    !DLLEXPORT(OC_GeneratedMesh_TypeGetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the generated mesh type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType_ !<On return, the type of the generated mesh. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_TypeGetObj",err,error,*999)

    CALL GeneratedMesh_TypeGet(generatedMesh%generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("OC_GeneratedMesh_TypeGetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_TypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh on a region identified by a user number.
  SUBROUTINE OC_GeneratedMesh_TypeSetNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber,generatedMeshType_,err)
    !DLLEXPORT(OC_GeneratedMesh_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType_ !<The type of the generated mesh to set. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_TypeSet(generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("OC_GeneratedMesh_TypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_TypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_TypeSetObj(generatedMesh,generatedMeshType_,err)
    !DLLEXPORT(OC_GeneratedMesh_TypeSetObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the generated mesh type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType_ !<The type of the generated mesh to set. \see OpenCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_TypeSetObj",err,error,*999)

    CALL GeneratedMesh_TypeSet(generatedMesh%generatedMesh,generatedMeshType_,err,error,*999)

    EXITS("OC_GeneratedMesh_TypeSetObj")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_TypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by a user number.
  SUBROUTINE OC_GeneratedMesh_GeometricParametersCalculateNumber(contextUserNumber,regionUserNumber,generatedMeshUserNumber, &
    & fieldUserNumber,err)
    !DLLEXPORT(OC_GeneratedMesh_GeometricParametersCalculateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_GeometricParametersCalculateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_GeometricParametersCalculate(generatedMesh,field,err,error,*999)

    EXITS("OC_GeneratedMesh_GeometricParametersCalculateNumber")
    RETURN
999 ERRORS("OC_GeneratedMesh_GeometricParametersCalculateNumber",err,error)
    EXITS("OC_GeneratedMesh_GeometricParametersCalculateNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_GeometricParametersCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_GeometricParametersCalculateObj(generatedMesh,field,err)
    !DLLEXPORT(OC_GeneratedMesh_GeometricParametersCalculateObj)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to calculate the geometric parameters for.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_GeneratedMesh_GeometricParametersCalculateObj",err,error,*999)

    CALL GeneratedMesh_GeometricParametersCalculate(generatedMesh%generatedMesh,field%field,err,error,*999)

    EXITS("OC_GeneratedMesh_GeometricParametersCalculateObj")
    RETURN
999 ERRORS("OC_GeneratedMesh_GeometricParametersCalculateObj",err,error)
    EXITS("OC_GeneratedMesh_GeometricParametersCalculateObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_GeneratedMesh_GeometricParametersCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_SurfaceGetNumber0(contextUserNumber,regionUserNumber,generatedMeshUserNumber,surfaceType, &
    & surfaceNodes,normalXi,err)
    !DLLEXPORT(OC_GeneratedMesh_SurfaceGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_SurfaceGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_SurfaceGet(generatedMesh,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("OC_GeneratedMesh_SurfaceGetNumber0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_SurfaceGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN
  END SUBROUTINE OC_GeneratedMesh_SurfaceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_SurfaceGetNumber1(contextUserNumber,regionUserNumber,meshComponent,generatedMeshUserNumber, &
    & surfaceType,surfaceNodes,normalXi,err)
    !DLLEXPORT(OC_GeneratedMesh_SurfaceGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(GeneratedMeshType), POINTER :: generatedMesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_GeneratedMesh_SurfaceGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(generatedMesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_GeneratedMeshGet(region,generatedMeshUserNumber,generatedMesh,err,error,*999)
    CALL GeneratedMesh_SurfaceGet(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("OC_GeneratedMesh_SurfaceGetNumber1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_SurfaceGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN
  END SUBROUTINE OC_GeneratedMesh_SurfaceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_SurfaceGetObj0(generatedMesh,surfaceType,surfaceNodes,normalXi,err)
    !DLLEXPORT(OC_GeneratedMesh_SurfaceGetObj0)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_GeneratedMesh_SurfaceGetObj0",err,error,*999)

    CALL GeneratedMesh_SurfaceGet(generatedMesh%generatedMesh,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("OC_GeneratedMesh_SurfaceGetObj0")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_SurfaceGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN
  END SUBROUTINE OC_GeneratedMesh_SurfaceGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE OC_GeneratedMesh_SurfaceGetObj1(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err)
    !DLLEXPORT(OC_GeneratedMesh_SurfaceGetObj1)

    !Argument variables
    TYPE(OC_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_GeneratedMesh_SurfaceGetObj1",err,error,*999)

    CALL GeneratedMesh_SurfaceGet(generatedMesh%generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("OC_GeneratedMesh_SurfaceGetObj1")
    RETURN
999 ERRORSEXITS("OC_GeneratedMesh_SurfaceGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN
  END SUBROUTINE OC_GeneratedMesh_SurfaceGetObj1


!!==================================================================================================================================
!!
!! MESH EMBEDDING ROUTINES
!!
!!==================================================================================================================================

  !>Initialises a EmbeddedMeshType object.
  SUBROUTINE OC_MeshEmbedding_Initialise(meshEmbedding,err)
    !DLLEXPORT(OC_MeshEmbedding_Initialise)
    !Argument variables
    TYPE(OC_MeshEmbeddingType), INTENT(OUT) ::  meshEmbedding !<The  MeshEmbeddingType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshEmbedding_Initialise",err,error,*999)

    NULLIFY(meshEmbedding%meshEmbedding)

    EXITS("OC_MeshEmbedding_Initialise")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_Initialise",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_Initialise

  !
  !================================================================================================================================
  !
  !>Creates a mesh embedding
  SUBROUTINE OC_MeshEmbedding_CreateNumber(contextUserNumber,regionOneUserNumber,regionTwoUserNumber,meshEmbedding, &
    & parentMeshUserNumber,childMeshUserNumber,err)
    !DLLEXPORT(OC_MeshEmbedding_CreateNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionOneUserNumber, regionTwoUserNumber !<The user number of the region containing the mesh.
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: parentMeshUserNumber, childMeshUserNumber  !<The user number of the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: PARENTMESH,CHILDMESH
    TYPE(RegionType), POINTER :: region1, REGION2
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshEmbedding_CreateNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(REGION1)
    NULLIFY(REGION2)
    NULLIFY(PARENTMESH)
    NULLIFY(CHILDMESH)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionOneUserNumber,REGION1,err,error,*999)
    CALL Region_Get(regions,regionTwoUserNumber,REGION2,err,error,*999)
    CALL Region_MeshGet(region1,parentMeshUserNumber,PARENTMESH,err,error,*999)
    CALL Region_MeshGet(region2,childMeshUserNumber,CHILDMESH,err,error,*999)
    CALL MESH_EMBEDDING_CREATE(meshEmbedding%meshEmbedding,PARENTMESH,CHILDMESH,err,error,*999)

    EXITS("OC_MeshEmbedding_CreateNumber")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_CreateNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_CreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a mesh embedding
  SUBROUTINE OC_MeshEmbedding_CreateObj(meshEmbedding, parentMesh, childMesh, err)
    !DLLEXPORT(OC_MeshEmbedding_CreateObj)
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(OC_MeshType), INTENT(IN) :: parentMesh, childMesh   !<The parent and child meshes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_MeshEmbedding_CreateObj",err,error,*999)

    CALL MESH_EMBEDDING_CREATE(meshEmbedding%meshEmbedding,parentMesh%mesh,childMesh%mesh,err,error,*999)

    EXITS("OC_MeshEmbedding_CreateObj")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_CreateObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_CreateObj

  !
  !================================================================================================================================
  !

  !>Sets the embedded nodes for one parent element
  SUBROUTINE OC_MeshEmbedding_SetChildNodePositionObj(meshEmbedding, elementNumber, nodeNumbers, xiCoords, err)
    !DLLEXPORT(OC_MeshEmbedding_SetChildNodePositionObj)
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: elementNumber   !<Parent element number
    INTEGER(INTG), INTENT(IN) :: nodeNumbers(:)  !<Node numbers in child mesh
    REAL(DP), INTENT(IN)      :: xiCoords(:,:)   !<Xi coordinates of embedded nodes wrt parent element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_MeshEmbedding_SetChildNodePositionObj",err,error,*999)

    CALL MESH_EMBEDDING_SET_CHILD_NODE_POSITION(meshEmbedding%meshEmbedding,elementNumber, nodeNumbers, xiCoords, err, error, *999)

    EXITS("OC_MeshEmbedding_SetChildNodePositionObj")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_SetChildNodePositionObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_SetChildNodePositionObj

  !
  !================================================================================================================================
  !

  !>Pushes data to embedded mesh. Will generally be used at library and not API level. /TODO: Parameter set etc, function name?
  SUBROUTINE OC_MeshEmbedding_PushDataObj(meshEmbedding, parentField, parentComponent, childField, childComponent, err)
    !DLLEXPORT(OC_MeshEmbedding_PushDataObj)
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(OC_FieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
    !    TYPE(OC_FieldType), POINTER, INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from

    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_MeshEmbedding_PushDataObj",err,error,*999)

    CALL MeshEmbedding_PushData(meshEmbedding%meshEmbedding,parentField%field, parentComponent, childField%field, &
      & childComponent, err, error, *999)

    EXITS("OC_MeshEmbedding_PushDataObj")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_PushDataObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_PushDataObj

  !
  !================================================================================================================================
  !
  !   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
  SUBROUTINE OC_MeshEmbedding_SetGaussPointDataObj(meshEmbedding, parentElementNumber,gaussPointNumber, &
    & parentXiCoords,childElementNumber,childXiCoords, err)
    !DLLEXPORT(OC_MeshEmbedding_SetGaussPointDataObj)
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: parentElementNumber   !<Parent element number
    INTEGER(INTG), INTENT(IN) :: childElementNumber   !<Child element number
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber  !<Gauss point number in this element
    REAL(DP), INTENT(IN)      :: parentXiCoords(:)   !<Xi coordinates of embedded nodes wrt parent element
    REAL(DP), INTENT(IN)      :: childXiCoords(:)   !<Xi coordinates of embedded nodes wrt Child element
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    !
    ENTERS("OC_MeshEmbedding_SetGaussPointDataObj",err,error,*999)

    CALL MESH_EMBEDDING_SET_GAUSS_POINT_DATA(meshEmbedding%meshEmbedding, parentElementNumber, gaussPointNumber,&
      & parentXiCoords, childElementNumber, childXiCoords,err,error,*999)

    EXITS("OC_MeshEmbedding_SetGaussPointDataObj")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_SetGaussPointDataObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_SetGaussPointDataObj
  ! !
  !================================================================================================================================
  !
  !   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
  SUBROUTINE OC_MeshEmbedding_PullGaussPointDataObj(meshEmbedding, parentField, parentComponent, childField, &
    & childComponent, err)
    !DLLEXPORT(OC_MeshEmbedding_PullGaussPointDataObj)
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(OC_FieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_MeshEmbedding_PullGaussPointDataObj",err,error,*999)

    CALL MeshEmbedding_PullGaussPointData(meshEmbedding%meshEmbedding,parentField%field, parentComponent, &
      &  childField%field,childComponent, err, error, *999)

    EXITS("OC_MeshEmbedding_PullGaussPointDataObj")
    RETURN
999 ERRORSEXITS("OC_MeshEmbedding_PullGaussPointDataObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshEmbedding_PullGaussPointDataObj
  ! !
  !================================================================================================================================
  !
  SUBROUTINE OC_Field_ParameterSetGetGaussPointCoordObj(meshEmbedding,componentNumber,numberOfGaussPoints, &
    & coords,err)
    !DLLEXPORT(OC_Field_ParameterSetGetGaussPointCoordObj)

    !Argument variables
    TYPE(OC_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: componentNumber
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussPoints
    REAL(DP), INTENT(OUT)      :: coords(:)   !<Xi coordinates of embedded nodes wrt Child element
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    !Local variables

    ENTERS("OC_Field_ParameterSetGetGaussPointCoordObj",err,error,*999)

    CALL Field_ParameterSetGetGaussPointCoord(meshEmbedding%meshEmbedding,componentNumber, &
      & NumberofGaussPoints,COORDS,err,error,*999)

    EXITS("OC_Field_ParameterSetGetGaussPointCoordObj")
    RETURN
999 ERRORS("OC_Field_ParameterSetGetGaussPointCoordObj",err,error)
    EXITS("OC_Field_ParameterSetGetGaussPointCoordObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Field_ParameterSetGetGaussPointCoordObj

!!==================================================================================================================================
!!
!! InterfaceRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface identified by a user number.
  SUBROUTINE OC_Interface_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(OC_Interface_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_CreateFinish(interface,err,error,*999)

    EXITS("OC_Interface_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by an object.
  SUBROUTINE OC_Interface_CreateFinishObj(interface,err)
    !DLLEXPORT(OC_Interface_CreateFinishObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_CreateFinishObj",err,error,*999)

    CALL Interface_CreateFinish(interface%interface,err,error,*999)

    EXITS("OC_Interface_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Interface_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by a user number.
  SUBROUTINE OC_Interface_CreateStartNumber(interfaceUserNumber,contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_Interface_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Interface_CreateStart(interfaceUserNumber,region,interface,err,error,*999)

    EXITS("OC_Interface_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by an object.
  SUBROUTINE OC_Interface_CreateStartObj(interfaceUserNumber,region,interface,err)
    !DLLEXPORT(OC_Interface_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the field to start the creation of.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to create the interface on.
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<On return, the created interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_CreateStartObj",err,error,*999)

    CALL Interface_CreateStart(interfaceUserNumber,region%region,interface%interface,err,error,*999)

    EXITS("OC_Interface_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Interface_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for an interface identified by an user number.
  SUBROUTINE OC_Interface_CoordinateSystemSetNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & coordinateSystemUserNumber,err)
    !DLLEXPORT(OC_Interface_CoordinateSystemSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region where interface was created.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_CoordinateSystemSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(coordinateSystems)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL Interface_CoordinateSystemSet(interface,coordinateSystem,err,error,*999)

    EXITS("OC_Interface_CoordinateSystemSetNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_CoordinateSystemSetNumber",err,error)
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_Interface_CoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for an interface identified by an object.
  SUBROUTINE OC_Interface_CoordinateSystemSetObj(interface,coordinateSystem,err)
    !DLLEXPORT(OC_Interface_CoordinateSystemSetObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to set the coordinate system for
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_Interface_CoordinateSystemSetObj",err,error,*999)

    CALL Interface_CoordinateSystemSet(interface%interface,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("OC_Interface_CoordinateSystemSetObj")
    RETURN
999 ERRORSEXITS("OC_Interface_CoordinateSystemSetObj",err,error)
    CALL OC_HandleError(Err,error)
    RETURN
  END SUBROUTINE OC_Interface_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for an interface identified by an user number.
  SUBROUTINE OC_Interface_CoordinateSystemGetNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & coordinateSystemUserNumber,err)
    !DLLEXPORT(OC_Interface_CoordinateSystemGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_CoordinateSystemGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_CoordinateSystemGet(interface,coordinateSystem,err,error,*999)
    coordinateSystemUserNumber = coordinateSystem%userNumber

    EXITS("OC_Interface_CoordinateSystemGetNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_CoordinateSystemGetNumber",err,error)
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_Interface_CoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for an interface identified by an object.
  SUBROUTINE OC_Interface_CoordinateSystemGetObj(Interface,CoordinateSystem,err)
    !DLLEXPORT(OC_Interface_CoordinateSystemGetObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: Interface !<The interface to get the coordinate system for.
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<On return, the interface coordinate system.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_Interface_CoordinateSystemGetObj",err,error,*999)

    CALL Interface_CoordinateSystemGet(Interface%interface,CoordinateSystem%coordinateSystem,err,error,*999)

    EXITS("OC_Interface_CoordinateSystemGetObj")
    RETURN
999 ERRORSEXITS("OC_Interface_CoordinateSystemGetObj",err,error)
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_Interface_CoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by a user number.
  SUBROUTINE OC_Interface_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(OC_Interface_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_Destroy(interface,err,error,*999)

    EXITS("OC_Interface_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by an object.
  SUBROUTINE OC_Interface_DestroyObj(interface,err)
    !DLLEXPORT(OC_Interface_DestroyObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_DestroyObj",err,error,*999)

    CALL Interface_Destroy(interface%interface,err,error,*999)

    EXITS("OC_Interface_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Interface_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an user number.
  SUBROUTINE OC_Interface_LabelGetCNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(OC_Interface_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelGet(interface,label,err,error,*999)

    EXITS("OC_Interface_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an object.
  SUBROUTINE OC_Interface_LabelGetCObj(interface,label,err)
    !DLLEXPORT(OC_Interface_LabelGetCObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_LabelGetCObj",err,error,*999)

    CALL Interface_LabelGet(interface%interface,label,err,error,*999)

    EXITS("OC_Interface_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an user number.
  SUBROUTINE OC_Interface_LabelGetVSNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(OC_Interface_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelGet(interface,label,err,error,*999)

    EXITS("OC_Interface_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an object.
  SUBROUTINE OC_Interface_LabelGetVSObj(interface,label,err)
    !DLLEXPORT(OC_Interface_LabelGetVSObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: Interface !<The interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_LabelGetVSObj",err,error,*999)

    CALL Interface_LabelGet(interface%interface,label,err,error,*999)

    EXITS("OC_Interface_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an user number.
  SUBROUTINE OC_Interface_LabelSetCNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(OC_Interface_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelSet(interface,label,err,error,*999)

    EXITS("OC_Interface_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an object.
  SUBROUTINE OC_Interface_LabelSetCObj(interface,label,err)
    !DLLEXPORT(OC_Interface_LabelSetCObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_LabelSetCObj",err,error,*999)

    CALL Interface_LabelSet(interface%interface,label,err,error,*999)

    EXITS("OC_Interface_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface identified by an user number.
  SUBROUTINE OC_Interface_LabelSetVSNumber(contextUserNumber,parentRegionUserNumber,interfaceUserNumber,label,err)
    !DLLEXPORT(OC_Interface_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_LabelSet(interface,CHAR(label),err,error,*999)

    EXITS("OC_Interface_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for an interface identified by an object.
  SUBROUTINE OC_Interface_LabelSetVSObj(interface,label,err)
    !DLLEXPORT(OC_Interface_LabelSetVSObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_LabelSetVSObj",err,error,*999)

    CALL Interface_LabelSet(interface%interface,CHAR(label),err,error,*999)

    EXITS("OC_Interface_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Interface_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a interface identified by an object.
  SUBROUTINE OC_Interface_NodesGetObj(interface,nodes,err)
    !DLLEXPORT(OC_Interface_NodesGetObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to get the nodes for.
    TYPE(OC_NodesType), INTENT(INOUT) :: nodes !<On return, the interfaces nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_NodesGetObj",err,error,*999)

    CALL Interface_NodesGet(interface%interface,nodes%nodes,err,error,*999)

    EXITS("OC_Interface_NodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Interface_NodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by a user number.
  SUBROUTINE OC_Interface_MeshAddNumber(contextUserNumber,interfaceRegionUserNumber,interfaceUserNumber,meshRegionUserNumber, &
    & meshUserNumber,meshIndex,err)
    !DLLEXPORT(OC_Interface_MeshAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the parent region containing the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The user number of the region containing the mesh to add to the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: meshRegion,parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Interface_MeshAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(meshRegion)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Region_Get(regions,meshRegionUserNumber,meshRegion,err,error,*999)
    CALL Region_MeshGet(meshRegion,meshUserNumber,mesh,err,error,*999)
    CALL Interface_MeshAdd(interface,mesh,meshIndex,err,error,*999)

    EXITS("OC_Interface_MeshAddNumber")
    RETURN
999 ERRORSEXITS("OC_Interface_MeshAddNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_MeshAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by an object.
  SUBROUTINE OC_Interface_MeshAddObj(interface,mesh,meshIndex,err)
    !DLLEXPORT(OC_Interface_MeshAddObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Interface_MeshAddObj",err,error,*999)

    CALL Interface_MeshAdd(interface%interface,mesh%mesh,meshIndex,err,error,*999)

    EXITS("OC_Interface_MeshAddObj")
    RETURN
999 ERRORSEXITS("OC_Interface_MeshAddObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Interface_MeshAddObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh connectivity identified by a user number.
  SUBROUTINE OC_InterfaceMeshConnectivity_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the meshes connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceMeshConnectivity_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_CreateFinish(interface%meshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_CreateFinishNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_CreateFinishNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_CreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE OC_InterfaceMeshConnectivity_CreateFinishObj(interfaceMeshConnectivity,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_CreateFinishObj)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_CreateFinishObj",err,error,*999)

    CALL InterfaceMeshConnectivity_CreateFinish(interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_CreateFinishObj")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_CreateFinishObj",err,error)
    EXITS("OC_InterfaceMeshConnectivity_CreateFinishObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by a user number.
  SUBROUTINE OC_InterfaceMeshConnectivity_CreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & meshNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(MeshType), POINTER :: mesh
    TYPE(InterfaceMeshConnectivityType), POINTER :: interfaceMeshConnectivity
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceMeshConnectivity_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceMeshConnectivity)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_MeshGet(interface,meshNumber,mesh,err,error,*999)
    CALL InterfaceMeshConnectivity_CreateStart(interface,mesh,interfaceMeshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_CreateStartNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_CreateStartNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_CreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE OC_InterfaceMeshConnectivity_CreateStartObj(interface,interfaceMesh,interfaceMeshConnectivity,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_CreateStartObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(OC_MeshType), INTENT(IN) :: interfaceMesh
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(INOUT) :: interfaceMeshConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_CreateStartObj",err,error,*999)

    CALL interfaceMeshConnectivity_CreateStart(interface%interface,interfaceMesh%mesh, &
      & interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_CreateStartObj")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_CreateStartObj",err,error)
    EXITS("OC_InterfaceMeshConnectivity_CreateStartObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_CreateStartObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE OC_InterfaceMeshConnectivity_ElementNumberSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_ElementNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_ElementNumberSet(interface%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledElementNumber,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_ElementNumberSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_ElementNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE OC_InterfaceMeshConnectivity_ElementNumberSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
    &  coupledMeshIndexNumber,coupledElementNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_ElementNumberSetObj)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber  !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_ElementNumberSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_ElementNumberSet(interfaceMeshConnectivity%meshConnectivity, &
      & interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_ElementNumberSetObj")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_ElementNumberSetObj",err,error)
    EXITS("OC_InterfaceMeshConnectivity_ElementNumberSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_ElementNumberSetObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE OC_InterfaceMeshConnectivity_NodeNumberSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_NodeNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_NodeNumberSetNumber",err,error,*999)

    CALL FlagError("Not implemented yet.",err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_NodeNumberSetNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_NodeNumberSetNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_NodeNumberSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_NodeNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between nodes in coupled meshes to nodes in the interface mesh
  SUBROUTINE OC_InterfaceMeshConnectivity_NodeNumberSetObj(interfaceMeshConnectivity,interfaceNodeNumbers, &
    &  firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers,secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_NodeNumberSetObj)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceNodeNumbers(:)  !<The interface mesh node numbers to which the specified coupled mesh nodes would be connected
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshIndexNumber,secondCoupledMeshIndexNumber !<The index of the coupled meshes at the interface to set the node connectivity for
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshNodeNumbers(:),secondCoupledMeshNodeNumbers(:) !<The coupled meshes nodes to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_NodeNumberSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_NodeNumbersSet(interfaceMeshConnectivity%meshConnectivity, &
      & interfaceNodeNumbers,firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers, &
      & secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_NodeNumberSetObj")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_NodeNumberSetObj",err,error)
    EXITS("OC_InterfaceMeshConnectivity_NodeNumberSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_NodeNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE OC_InterfaceMeshConnectivity_ElementXiSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceElementNumber,coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber, &
    & interfaceMeshComponentNodeNumber,xi,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_ElementXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceMeshConnectivity_ElementXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_ElementXiSet(interface%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
      & err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_ElementXiSetNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_ElementXiSetNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_ElementXiSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_ElementXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE OC_InterfaceMeshConnectivity_ElementXiSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
    &  coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_ElementXiSetObj)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_ElementXiSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_ElementXiSet(interfaceMeshConnectivity%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
      & err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_ElementXiSetObj")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_ElementXiSetObj",err,error)
    EXITS("OC_InterfaceMeshConnectivity_ElementXiSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_ElementXiSetObj

  !
  !================================================================================================================================
  !

  SUBROUTINE OC_InterfaceMeshConnectivity_BasisSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceBasisNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_BasisSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceBasisNumber !<The user number of the basis to denote the interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceMeshConnectivity_BasisSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Basis_Get(basisFunctions,interfaceBasisNumber,basis,err,error,*999)
    CALL InterfaceMeshConnectivity_BasisSet(interface%meshConnectivity,basis,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_BasisSetNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_BasisSetNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_BasisSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the basis for the mesh connectivity
  SUBROUTINE OC_InterfaceMeshConnectivity_BasisSetObj(interfaceMeshConnectivity,interfaceMappingBasis,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_BasisSetObj)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    TYPE(OC_BasisType), INTENT(INOUT) :: interfaceMappingBasis !<The interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_BasisSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_BasisSet(interfaceMeshConnectivity%meshConnectivity,interfaceMappingBasis%basis, &
      & err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_BasisSetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceMeshConnectivity_BasisSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by a user number.
  SUBROUTINE OC_InterfaceMeshConnectivity_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceMeshConnectivity_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfaceMeshConnectivity_Destroy(interface%meshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_DestroyNumber")
    RETURN
999 ERRORS("OC_InterfaceMeshConnectivity_DestroyNumber",err,error)
    EXITS("OC_InterfaceMeshConnectivity_DestroyNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by an object.
  SUBROUTINE OC_InterfaceMeshConnectivity_DestroyObj(interfaceMeshConnectivity,err)
    !DLLEXPORT(OC_InterfaceMeshConnectivity_DestroyObj)

    !Argument variables
    TYPE(OC_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceMeshConnectivity_DestroyObj",err,error,*999)

    CALL InterfaceMeshConnectivity_Destroy(interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("OC_InterfaceMeshConnectivity_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceMeshConnectivity_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceMeshConnectivity_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh points connectivity identified by a user number.
  SUBROUTINE OC_InterfacePointsConnectivity_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the points connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfacePointsConnectivity_CreateFinish(interface%pointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_CreateFinishNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_CreateFinishNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_CreateFinishNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE OC_InterfacePointsConnectivity_CreateFinishObj(interfacePointsConnectivity,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_CreateFinishObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_InterfacePointsConnectivity_CreateFinishObj",err,error,*999)

    CALL InterfacePointsConnectivity_CreateFinish(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_CreateFinishObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_CreateFinishObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_CreateFinishObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface points connectivity identified by a user number.
  SUBROUTINE OC_InterfacePointsConnectivity_CreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & meshUserNumber,dataPointsUserNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfacePointsConnectivityType), POINTER :: interfacePointsConnectivity
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfacePointsConnectivity)
    NULLIFY(mesh)
    NULLIFY(dataPoints)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_MeshGet(interface,meshUserNumber,mesh,err,error,*999)
    CALL Interface_DataPointsGet(interface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL InterfacePointsConnectivity_CreateStart(interface,mesh,dataPoints,interfacePointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_CreateStartNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_CreateStartNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_CreateStartNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface points connectivity identified by an object.
  SUBROUTINE OC_InterfacePointsConnectivity_CreateStartObj(INTERFACE,interfaceMesh,dataPoints,interfacePointsConnectivity,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_CreateStartObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(OC_MeshType), INTENT(IN) :: interfaceMesh
    TYPE(OC_DataPointsType), INTENT(IN) :: dataPoints
    TYPE(OC_InterfacePointsConnectivityType), INTENT(INOUT) :: interfacePointsConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfacePointsConnectivity_CreateStartObj",err,error,*999)

    CALL InterfacePointsConnectivity_CreateStart(INTERFACE%INTERFACE,interfaceMesh%mesh,dataPoints%dataPoints, &
      & InterfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_CreateStartObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_CreateStartObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_CreateStartObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by a user number.
  SUBROUTINE OC_InterfacePointsConnectivity_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL InterfacePointsConnectivity_Destroy(interface%pointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_DestroyNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_DestroyNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_DestroyNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by an object.
  SUBROUTINE OC_InterfacePointsConnectivity_DestroyObj(interfacePointsConnectivity,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_DestroyObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfacePointsConnectivity_DestroyObj",err,error,*999)

    CALL InterfacePointsConnectivity_Destroy(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_InterfacePointsConnectivity_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_DestroyObj

  !
  !================================================================================================================================
  !

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,meshComponentNumber,coupledElementUserNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_ElementNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledElementUserNumber !<The element user number where the data point is connected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_ElementNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(INTERFACE)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)    
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberGet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberGet(meshElements,coupledElementGlobalNumber,coupledElementUserNumber,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_ElementNumberGetNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_ElementNumberGetNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_ElementNumberGetNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
    & coupledMeshIndexNumber,meshComponentNumber,coupledElementUserNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_ElementNumberGetObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledElementUserNumber !<The element user number where the data point is projected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology

    ENTERS("OC_InterfacePointsConnectivity_ElementNumberGetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    NULLIFY(INTERFACE)
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity, &
      & dataPointGlobalNumber,coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberGet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_InterfaceGet(interfacePointsConnectivity%pointsConnectivity,INTERFACE,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberGet(meshElements,coupledElementGlobalNumber,coupledElementUserNumber,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_ElementNumberGetObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_ElementNumberGetObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_ElementNumberGetObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberGetObj

  !
  !================================================================================================================================
  !

!!TODO: why are the element number and mesh component number switched when compared to the get method?
  !>Sets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,coupledElementUserNumber,meshComponentNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_ElementNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledElementUserNumber !<The element user number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_ElementNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(INTERFACE)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,coupledElementUserNumber,coupledElementGlobalNumber,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberSet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_ElementNumberSetNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_ElementNumberSetNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberSetNumber

  !
  !================================================================================================================================
  !

!!TODO: why are the element number and mesh component number switched when compared to the get method?
  !>Sets coupled mesh element user number that the data point in the interface is connected to
  SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
    & coupledMeshIndexNumber,coupledElementUserNumber,meshComponentNumber,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_ElementNumberSetObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledElementUserNumber !<The element user number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: coupledElementGlobalNumber,dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: INTERFACE
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(MeshType), POINTER :: coupledMesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology

    ENTERS("OC_InterfacePointsConnectivity_ElementNumberSetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    NULLIFY(INTERFACE)
    NULLIFY(coupledMesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity, &
      & dataPointGlobalNumber,coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_InterfaceGet(interfacePointsConnectivity%pointsConnectivity,INTERFACE,err,error,*999)
    CALL Interface_CoupledMeshGet(interface,coupledMeshIndexNumber,coupledMesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(coupledMesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,coupledElementUserNumber,coupledElementGlobalNumber,err,error,*999)
    CALL InterfacePointConnectivity_CoupledElementNumberSet(pointConnectivity,coupledElementGlobalNumber,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_ElementNumberSetObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_ElementNumberSetObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_ElementNumberSetObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_ElementNumberSetObj

  !
  !================================================================================================================================
  !

  !>Gets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE OC_InterfacePointsConnectivity_PointXiGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_PointXiGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfXi
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_PointXiGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(INTERFACE)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiGet(pointConnectivity,numberOfXi,xi,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_PointXiGetNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_PointXiGetNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_PointXiGetNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_PointXiGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE OC_InterfacePointsConnectivity_PointXiGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
    &  coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_PointXiGetObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber,numberOfXi
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity

    ENTERS("OC_InterfacePointsConnectivity_PointXiGetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity, &
      & dataPointGlobalNumber,coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiGet(pointConnectivity,numberOfXi,xi,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_PointXiGetObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_PointXiGetObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_PointXiGetObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_PointXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE OC_InterfacePointsConnectivity_PointXiSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_PointXiSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e., user defined number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_PointXiSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(pointsConnectivity)
    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_PointsConnectivityGet(INTERFACE,pointsConnectivity,err,error,*999)
    CALL InterfacePointsConnectivity_DataPointsGet(pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(pointsConnectivity,dataPointGlobalNumber,coupledMeshIndexNumber, &
      & pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiSet(pointConnectivity,xi,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_PointXiSetNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_PointXiSetNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_PointXiSetNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_PointXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE OC_InterfacePointsConnectivity_PointXiSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
    &  coupledMeshIndexNumber,xi,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_PointXiSetObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataPointGlobalNumber
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(InterfacePointConnectivityType), POINTER :: pointConnectivity

    ENTERS("OC_InterfacePointsConnectivity_PointXiSetObj",err,error,*999)

    NULLIFY(dataPoints)
    NULLIFY(pointConnectivity)
    CALL InterfacePointsConnectivity_DataPointsGet(interfacePointsConnectivity%pointsConnectivity,dataPoints,err,error,*999)
    CALL DataPoints_GlobalNumberGet(dataPoints,interfaceDataPointIndexNumber,dataPointGlobalNumber,err,error,*999)
    CALL InterfacePointsConnectivity_CoupledPointGet(interfacePointsConnectivity%pointsConnectivity,dataPointGlobalNumber, &
      & coupledMeshIndexNumber,pointConnectivity,err,error,*999)
    CALL InterfacePointConnectivity_XiSet(pointConnectivity,xi,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_PointXiSetObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_PointXiSetObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_PointXiSetObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_PointXiSetObj

  !
  !================================================================================================================================
  !

  !>Update points connectivity with projection results, data projection identified by region user number
  SUBROUTINE OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber(contextUserNumber,regionUserNumber, &
    & interfaceUserNumber,dataPointsRegionUserNumber,dataPointsUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The region number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points .
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface
    TYPE(RegionType), POINTER :: parentRegion,dataPointsRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,ParentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Region_Get(regions,dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
    CALL Region_DataPointsGet(dataPointsRegion,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL InterfacePointsConnectivity_UpdateFromProjection(interface%PointsConnectivity, &
      & dataProjection,coupledMeshIndex,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_UpdateFromProjectionRNumber

  !
  !================================================================================================================================
  !

  !>Update points connectivity with projection results, data projection identified by interface user number
  SUBROUTINE OC_InterfacePointsConnectivity_UpdateFromProjectionINumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & dataPointsRegionUserNumber,dataPointsInterfaceUserNumber,dataPointsUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_UpdateFromProjectionINumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The parent region number of the interface for the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsInterfaceUserNumber !<The interface number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DataPointsType), POINTER :: dataPoints
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(InterfaceType), POINTER :: interface,dataPointsInterface
    TYPE(RegionType), POINTER :: parentRegion,dataPointsRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfacePointsConnectivity_UpdateFromProjectionINumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPointsInterface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Region_Get(regions,dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
    CALL Region_InterfaceGet(dataPointsRegion,dataPointsInterfaceUserNumber,dataPointsInterface,err,error,*999)
    CALL Interface_DataPointsGet(dataPointsInterface,dataPointsUserNumber,dataPoints,err,error,*999)
    CALL DataPoints_DataProjectionUserGet(dataPoints,dataProjectionUserNumber,dataProjection,err,error,*999)
    CALL InterfacePointsConnectivity_UpdateFromProjection(interface%PointsConnectivity, &
      & dataProjection,coupledMeshIndex,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_UpdateFromProjectionINumber")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_UpdateFromProjectionINumber",err,error)
    EXITS("OC_InterfacePointsConnectivity_UpdateFromProjectionINumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_UpdateFromProjectionINumber

  !
  !================================================================================================================================
  !

  !>Update points connectivity with projection results, data projection identified by object
  SUBROUTINE OC_InterfacePointsConnectivity_UpdateFromProjectionObj(pointsConnectivity,dataProjection, &
    & coupledMeshIndex,err)
    !DLLEXPORT(OC_InterfacePointsConnectivity_UpdateFromProjectionObj)

    !Argument variables
    TYPE(OC_InterfacePointsConnectivityType), INTENT(IN) :: pointsConnectivity !<A pointer to the interface points connectivity to finish creating
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The mesh index of the the points connectivity to be updated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfacePointsConnectivity_UpdateFromProjectionObj",err,error,*999)

    CALL InterfacePointsConnectivity_UpdateFromProjection(pointsConnectivity%pointsConnectivity, &
      & dataProjection%dataProjection,coupledMeshIndex,err,error,*999)

    EXITS("OC_InterfacePointsConnectivity_UpdateFromProjectionObj")
    RETURN
999 ERRORS("OC_InterfacePointsConnectivity_UpdateFromProjectionObj",err,error)
    EXITS("OC_InterfacePointsConnectivity_UpdateFromProjectionObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfacePointsConnectivity_UpdateFromProjectionObj

!!==================================================================================================================================
!!
!! InterfaceConditionRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface condition identified by an user number.
  SUBROUTINE OC_InterfaceCondition_CreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish creating for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_CreateFinish(interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_CreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_CreateFinishObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_CreateFinishObj",err,error,*999)

    CALL InterfaceCondition_CreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_CreateStartNumber(interfaceConditionUserNumber,contextUserNumber,regionUserNumber, &
    & interfaceUserNumber,geometricFieldUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The user number of the geometric field on the interface for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: geometricField
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(geometricField)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_FieldGet(interface,geometricFieldUserNumber,geometricField,err,error,*999)
    CALL InterfaceCondition_CreateStart(interfaceConditionUserNumber,interface,geometricField,interfaceCondition, &
      & err,error,*999)

    EXITS("OC_InterfaceCondition_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_CreateStartObj(interfaceConditionUserNumber,interface,geometricField,interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditon to start the creation of.
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to create the interface on.
    TYPE(OC_FieldType), INTENT(IN) :: geometricField !<The geometric field for the interface condition.
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<On return, the created interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_CreateStartObj",err,error,*999)

    CALL InterfaceCondition_CreateStart(interfaceConditionUserNumber,interface%interface,geometricField%field, &
      & interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a dependent variable to an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_DependentVariableAddNumber(contextUserNumber,interfaceRegionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,meshIndex,equationsSetRegionUserNumber,equationsSetUserNumber,variableType,err)
    !DLLEXPORT(OC_InterfaceCondition_DependentVariableAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    INTEGER(INTG), INTENT(IN) :: equationsSetRegionUserNumber !<The user number of the region containing the equations set containing the dependent field varible to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set containing the dependent field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: equationsSetRegion,interfaceRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_DependentVariableAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(interfaceRegion)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(equationsSetRegion)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,interfaceRegion,err,error,*999)
    CALL Region_InterfaceGet(interfaceRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL Region_Get(regions,EquationsSetRegionuserNumber,equationsSetRegion,err,error,*999)
    CALL Region_EquationsSetGet(equationsSetRegion,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL InterfaceCondition_DependentVariableAdd(interfaceCondition,meshIndex,equationsSet,variableType, &
      & err,error,*999)

    EXITS("OC_InterfaceCondition_DependentVariableAddNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_DependentVariableAddNumber",err,error)
    EXITS("OC_InterfaceCondition_DependentVariableAddNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_DependentVariableAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a dependent field variable to an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_DependentVariableAddObj(interfaceCondition,meshIndex,equationsSet,variableType,err)
    !DLLEXPORT(OC_InterfaceCondition_DependentVariableAddObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add the dependent variable to.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set containg the dependent variable to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_DependentVariableAddObj",err,error,*999)

    CALL InterfaceCondition_DependentVariableAdd(interfaceCondition%interfaceCondition,meshIndex,equationsSet%equationsSet, &
      & variableType,err,error,*999)

    EXITS("OC_InterfaceCondition_DependentVariableAddObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_DependentVariableAddObj",err,error)
    EXITS("OC_InterfaceCondition_DependentVariableAddObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_DependentVariableAddObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_DestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_Destroy(interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_DestroyObj(interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_DestroyObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_DestroyObj",err,error,*999)

    CALL InterfaceCondition_Destroy(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of equations for an interface condition identified by an user number.
  SUBROUTINE OC_InterfaceCondition_EquationsCreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_EquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_InterfaceConditionGet(INTERFACE,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_EquationsCreateFinish(interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_EquationsCreateFinishNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_EquationsCreateFinishNumber",err,error)
    EXITS("OC_InterfaceCondition_EquationsCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_EquationsCreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_EquationsCreateFinishObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_EquationsCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_EquationsCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_EquationsCreateFinishObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_EquationsCreateFinishObj",err,error)
    EXITS("OC_InterfaceCondition_EquationsCreateFinishObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_EquationsCreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_EquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_EquationsCreateStart(interfaceCondition,interfaceEquations,err,error,*999)

    EXITS("OC_InterfaceCondition_EquationsCreateStartNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_EquationsCreateStartNumber",err,error)
    EXITS("OC_InterfaceCondition_EquationsCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_EquationsCreateStartObj(interfaceCondition,interfaceEquations,err)
    !DLLEXPORT(OC_InterfaceCondition_EquationsCreateStartObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of interface equations for
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<On return, the created interface equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_EquationsCreateStartObj",err,error,*999)

    CALL InterfaceCondition_EquationsCreateStart(interfaceCondition%interfaceCondition,interfaceEquations% &
      & interfaceEquations,err,error,*999)

    EXITS("OC_InterfaceCondition_EquationsCreateStartObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_EquationsCreateStartObj",err,error)
    EXITS("OC_InterfaceCondition_EquationsCreateStartObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys interface equations for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_EquationsDestroyNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_EquationsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_EquationsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_EquationsDestroy(interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_EquationsDestroyNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_EquationsDestroyNumber",err,error)
    EXITS("OC_InterfaceCondition_EquationsDestroyNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the interface equations for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_EquationsDestroyObj(interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_EquationsDestroyObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_EquationsDestroyObj",err,error,*999)

    CALL InterfaceCondition_EquationsDestroy(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_EquationsDestroyObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_EquationsDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_EquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the integration type for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_IntegrationTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionIntegrationType,err)
    !DLLEXPORT(OC_InterfaceCondition_IntegrationTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_IntegrationTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)

    EXITS("OC_InterfaceCondition_IntegrationTypeGetNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_IntegrationTypeGetNumber",err,error)
    EXITS("OC_InterfaceCondition_IntegrationTypeGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_IntegrationTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the integration type for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_IntegrationTypeGetObj(interfaceCondition,interfaceConditionIntegrationType,err)
    !DLLEXPORT(OC_InterfaceCondition_IntegrationTypeGetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_IntegrationTypeGetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition%interfaceCondition,interfaceConditionIntegrationType, &
      & err,error,*999)

    EXITS("OC_InterfaceCondition_IntegrationTypeGetObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_IntegrationTypeGetObj",err,error)
    EXITS("OC_InterfaceCondition_IntegrationTypeGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_IntegrationTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_IntegrationTypeSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionIntegrationType,err)
    !DLLEXPORT(OC_InterfaceCondition_IntegrationTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_IntegrationTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)

    EXITS("OC_InterfaceCondition_IntegrationTypeSetNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_IntegrationTypeSetNumber",err,error)
    EXITS("OC_InterfaceCondition_IntegrationTypeSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_IntegrationTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_IntegrationTypeSetObj(interfaceCondition,interfaceConditionIntegrationType,err)
    !DLLEXPORT(OC_InterfaceCondition_IntegrationTypeSetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OpenCMISS_InterfaceConditionIntegrationTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_IntegrationTypeSetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition%interfaceCondition,interfaceConditionIntegrationType, &
      & err,error,*999)

    EXITS("OC_InterfaceCondition_IntegrationTypeSetObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_IntegrationTypeSetObj",err,error)
    EXITS("OC_InterfaceCondition_IntegrationTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_IntegrationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange Multiplier Field for an interface condition identified by an user number.
  SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_LagrangeFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_LagrangeFieldCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LagrangeFieldCreateFinish(interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_LagrangeFieldCreateFinishNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_LagrangeFieldCreateFinishNumber",err,error)
    EXITS("OC_InterfaceCondition_LagrangeFieldCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_LagrangeFieldCreateFinishObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_LagrangeFieldCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_LagrangeFieldCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_LagrangeFieldCreateFinishObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_LagrangeFieldCreateFinishObj",err,error)
    EXITS("OC_InterfaceCondition_LagrangeFieldCreateFinishObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,lagrangeFieldUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_LagrangeFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: lagrangeField
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_LagrangeFieldCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(lagrangeField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LagrangeFieldCreateStart(interfaceCondition,lagrangeFieldUserNumber,lagrangeField, &
      & err,error,*999)

    EXITS("OC_InterfaceCondition_LagrangeFieldCreateStartNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_LagrangeFieldCreateStartNumber",err,error)
    EXITS("OC_InterfaceCondition_LagrangeFieldCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateStartObj(interfaceCondition,lagrangeFieldUserNumber,lagrangeField,err)
    !DLLEXPORT(OC_InterfaceCondition_LagrangeFieldCreateStartObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    TYPE(OC_FieldType), INTENT(INOUT) :: lagrangeField !<If associated on entry, the user created Lagrange field which has the same user number as the specified Lagrange field user number. If not associated on entry, on return, the created Lagrange field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_LagrangeFieldCreateStartObj",err,error,*999)

    CALL InterfaceCondition_LagrangeFieldCreateStart(interfaceCondition%interfaceCondition,lagrangeFieldUserNumber, &
      & lagrangeField%field,err,error,*999)

    EXITS("OC_InterfaceCondition_LagrangeFieldCreateStartObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_LagrangeFieldCreateStartObj",err,error)
    EXITS("OC_InterfaceCondition_LagrangeFieldCreateStartObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LagrangeFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_LabelGetCNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelGet(interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_LabelGetCObj(interfaceCondition,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelGetCObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_LabelGetCObj",err,error,*999)

    CALL InterfaceCondition_LabelGet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_LabelGetVSNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface condition to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelGet(interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_LabelGetVSObj(interfaceCondition,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelGetVSObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface condition label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_LabelGetVSObj",err,error,*999)

    CALL InterfaceCondition_LabelGet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_LabelSetCNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface condition label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelSet(interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_LabelSetCObj(interfaceCondition,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelSetCObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface condition label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_LabelSetCObj",err,error,*999)

    CALL InterfaceCondition_LabelSet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_LabelSetVSNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface condition label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_LabelSet(interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_LabelSetVSObj(interfaceCondition,label,err)
    !DLLEXPORT(OC_InterfaceCondition_LabelSetVSObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface condition label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_LabelSetVSObj",err,error,*999)

    CALL InterfaceCondition_LabelSet(interfaceCondition%interfaceCondition,label,err,error,*999)

    EXITS("OC_InterfaceCondition_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Gets the output type an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_OutputTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(OC_InterfaceCondition_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the interface condition \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OutputTypeGet(interfaceCondition,outputType,err,error,*999)

    EXITS("OC_InterfaceCondition_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OutputTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_OutputTypeGetObj(interfaceCondition,outputType,err)
    !DLLEXPORT(OC_InterfaceCondition_OutputTypeGetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the interface condition \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_OutputTypeGetObj",err,error,*999)

    CALL InterfaceCondition_OutputTypeGet(interfaceCondition%interfaceCondition,outputType,err,error,*999)

    EXITS("OC_InterfaceCondition_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OutputTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_OutputTypeSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(OC_InterfaceCondition_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the interface to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the interface condition to set \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OutputTypeSet(interfaceCondition,outputType,err,error,*999)

    EXITS("OC_InterfaceCondition_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OutputTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_OutputTypeSetObj(interfaceCondition,outputType,err)
    !DLLEXPORT(OC_InterfaceCondition_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(INOUT) :: interfaceCondition !<The interface condition to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the interface condition to set \see OpenCMISS_InterfaceConditionOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_OutputTypeSetObj",err,error,*999)

    CALL InterfaceCondition_OutputTypeSet(interfaceCondition%interfaceCondition,outputType,err,error,*999)

    EXITS("OC_InterfaceCondition_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a penalty Field for an interface condition identified by an user number.
  SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateFinishNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_PenaltyFieldCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the penalty field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the penalty  field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_PenaltyFieldCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_PenaltyFieldCreateFinish(interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_PenaltyFieldCreateFinishNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_PenaltyFieldCreateFinishNumber",err,error)
    EXITS("OC_InterfaceCondition_PenaltyFieldCreateFinishNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateFinishObj(interfaceCondition,err)
    !DLLEXPORT(OC_InterfaceCondition_PenaltyFieldCreateFinishObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_PenaltyFieldCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_PenaltyFieldCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("OC_InterfaceCondition_PenaltyFieldCreateFinishObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_PenaltyFieldCreateFinishObj",err,error)
    EXITS("OC_InterfaceCondition_PenaltyFieldCreateFinishObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a penalty field for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateStartNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,penaltyFieldUserNumber,err)
    !DLLEXPORT(OC_InterfaceCondition_PenaltyFieldCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: penaltyFieldUserNumber !<The user number of the penalty field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: penaltyField
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_PenaltyFieldCreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(penaltyField)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_PenaltyFieldCreateStart(interfaceCondition,penaltyFieldUserNumber,penaltyField, &
      & Err,error,*999)

    EXITS("OC_InterfaceCondition_PenaltyFieldCreateStartNumber")
    RETURN
999 ERRORS("OC_InterfaceCondition_PenaltyFieldCreateStartNumber",err,error)
    EXITS("OC_InterfaceCondition_PenaltyFieldCreateStartNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateStartObj(interfaceCondition,penaltyFieldUserNumber,penaltyField,err)
    !DLLEXPORT(OC_InterfaceCondition_PenaltyFieldCreateStartObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: penaltyFieldUserNumber !<The user number of the penalty field.
    TYPE(OC_FieldType), INTENT(INOUT) :: penaltyField !<If associated on entry, the user created penalty field which has the same user number as the specified penalty field user number. If not associated on entry, on return, the created penalty field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_PenaltyFieldCreateStartObj",err,error,*999)

    CALL InterfaceCondition_PenaltyFieldCreateStart(interfaceCondition%interfaceCondition,penaltyFieldUserNumber, &
      & penaltyField%field,err,error,*999)

    EXITS("OC_InterfaceCondition_PenaltyFieldCreateStartObj")
    RETURN
999 ERRORS("OC_InterfaceCondition_PenaltyFieldCreateStartObj",err,error)
    EXITS("OC_InterfaceCondition_PenaltyFieldCreateStartObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_PenaltyFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the method for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_MethodGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionMethod,err)
    !DLLEXPORT(OC_InterfaceCondition_MethodGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_MethodGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_MethodGet(interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("OC_InterfaceCondition_MethodGetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_MethodGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_MethodGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the method for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_MethodGetObj(interfaceCondition,interfaceConditionMethod,err)
    !DLLEXPORT(OC_InterfaceCondition_MethodGetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_MethodGetObj",err,error,*999)

    CALL InterfaceCondition_MethodGet(interfaceCondition%interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("OC_InterfaceCondition_MethodGetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_MethodGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_MethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_MethodSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionMethod,err)
    !DLLEXPORT(OC_InterfaceCondition_MethodSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_MethodSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_MethodSet(interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("OC_InterfaceCondition_MethodSetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_MethodSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_MethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_MethodSetObj(interfaceCondition,interfaceConditionMethod,err)
    !DLLEXPORT(OC_InterfaceCondition_MethodSetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OpenCMISS_InterfaceConditionMethods,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_MethodSetObj",err,error,*999)

    CALL InterfaceCondition_MethodSet(interfaceCondition%interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("OC_InterfaceCondition_MethodSetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_MethodSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_MethodSetObj

  !
  !================================================================================================================================
  !

  !>Returns the operator for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_OperatorGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionOperator,err)
    !DLLEXPORT(OC_InterfaceCondition_OperatorGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_OperatorGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OperatorGet(interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("OC_InterfaceCondition_OperatorGetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OperatorGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OperatorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the operator for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_OperatorGetObj(interfaceCondition,interfaceConditionOperator,err)
    !DLLEXPORT(OC_InterfaceCondition_OperatorGetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OpenCMISS_InterfaceConditionOperator,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_OperatorGetObj",err,error,*999)

    CALL InterfaceCondition_OperatorGet(interfaceCondition%interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("OC_InterfaceCondition_OperatorGetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OperatorGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OperatorGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by a user number.
  SUBROUTINE OC_InterfaceCondition_OperatorSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceConditionOperator,err)
    !DLLEXPORT(OC_InterfaceCondition_OperatorSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OpenCMISS_InterfaceConditionOperators,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceCondition_OperatorSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_OperatorSet(interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("OC_InterfaceCondition_OperatorSetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OperatorSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OperatorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by an object.
  SUBROUTINE OC_InterfaceCondition_OperatorSetObj(interfaceCondition,interfaceConditionOperator,err)
    !DLLEXPORT(OC_InterfaceCondition_OperatorSetObj)

    !Argument variables
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OpenCMISS_InterfaceConditionOperator,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceCondition_OperatorSetObj",err,error,*999)

    CALL InterfaceCondition_OperatorSet(interfaceCondition%interfaceCondition,interfaceConditionOperator,err,error,*999)

    EXITS("OC_InterfaceCondition_OperatorSetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceCondition_OperatorSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceCondition_OperatorSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_LinearityTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,linearityType,err)
    !DLLEXPORT(OC_InterfaceEquations_LinearityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the interface equations linearity type. \see OpenCMISS_InterfaceEquationsLinearityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_LinearityTypeGet(interfaceEquations,linearityType,err,error,*999)

    EXITS("OC_InterfaceEquations_LinearityTypeGetNumber")
    RETURN
999 ERRORS("OC_InterfaceEquations_LinearityTypeGetNumber",err,error)
    EXITS("OC_InterfaceEquations_LinearityTypeGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_LinearityTypeGetObj(interfaceEquations,linearityType,err)
    !DLLEXPORT(OC_InterfaceEquations_LinearityTypeGetObj)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the interface equations linearity type. \see OpenCMISS_InterfaceEquationsLinearityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_LinearityTypeGetObj",err,error,*999)

    CALL InterfaceEquations_LinearityTypeGet(interfaceEquations%interfaceEquations,linearityType,err,error,*999)

    EXITS("OC_InterfaceEquations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_LinearityTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceType,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: timeDependenceTypes(1)

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0",err,error,*999)

    CALL OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
      & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceTypes,err)
    timeDependenceType=timeDependenceTypes(1)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber0
  !
  !================================================================================================================================
  !

  !>Returns the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceTypes,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_MatrixTimeDependenceTypeGet(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceType,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: timeDependenceTypes(1)

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0",err,error,*999)

    CALL OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err)
    timeDependenceType=timeDependenceTypes(1)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj0

  !
  !================================================================================================================================
  !

  !>Gets the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceTypes,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to get the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). On return, the interface matrix time dependence type. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1",err,error,*999)

    CALL InterfaceEquations_MatrixTimeDependenceTypeGet(interfaceEquations%interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceType,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0",err,error,*999)

    CALL OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
      & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,[timeDependenceType],err)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber0
  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,interfaceMatrixIdx,hasTranspose,timeDependenceTypes,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the matrix time dependence type for type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_MatrixTimeDependenceTypeSet(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceType,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0",err,error,*999)

    CALL OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & [timeDependenceType],err)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the matrix time dependence type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1(interfaceEquations,interfaceMatrixIdx,hasTranspose, &
    & timeDependenceTypes,err)
    !DLLEXPORT(OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the matrix time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIdx !<The index of the interface matrix to set the time dependence type for.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the interface matrix transpose is to be set as well, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: timeDependenceTypes(:) !<timeDependenceTypes(transposeIdx). The interface matrix time dependence type to set. If hasTranspose is .TRUE. then two timeDependenceTypes are required. The first one for the the interface matrix and the second one for the transposed matrix. \see OpenCMISS_InterfaceMatricesTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1",err,error,*999)

    CALL InterfaceEquations_MatrixTimeDependenceTypeSet(interfaceEquations%interfaceEquations,interfaceMatrixIdx,hasTranspose, &
      & timeDependenceTypes,err,error,*999)

    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1")
    RETURN
999 ERRORS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1",err,error)
    EXITS("OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_MatrixTimeDependenceTypeSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the output type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_OutputTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(OC_InterfaceEquations_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OpenCMISS_InterfaceEquationsOutputType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_OutputTypeGet(interfaceEquations,outputType,err,error,*999)

    EXITS("OC_InterfaceEquations_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_OutputTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_OutputTypeGetObj(interfaceEquations,outputType,err)
    !DLLEXPORT(OC_InterfaceEquations_OutputTypeGetObj)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OpenCMISS_EquationsOutputType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_OutputTypeGetObj",err,error,*999)

    CALL InterfaceEquations_OutputTypeGet(interfaceEquations%interfaceEquations,outputType,err,error,*999)

    EXITS("OC_InterfaceEquations_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_OutputTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_OutputTypeSetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,outputType,err)
    !DLLEXPORT(OC_InterfaceEquations_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_OutputTypeSet(interfaceEquations,outputType,err,error,*999)

    EXITS("OC_InterfaceEquations_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_OutputTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_OutputTypeSetObj(interfaceEquations,outputType,err)
    !DLLEXPORT(OC_InterfaceEquations_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OpenCMISS_EquationsOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_OutputTypeSetObj",err,error,*999)

    CALL InterfaceEquations_OutputTypeSet(interfaceEquations%interfaceEquations,outputType,err,error,*999)

    EXITS("OC_InterfaceEquations_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the sparsity type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_SparsityGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,sparsityType,err)
    !DLLEXPORT(OC_InterfaceEquations_SparsityGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OpenCMISS_EquationsSparsityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_SparsityGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_SparsityTypeGet(interfaceEquations,sparsityType,err,error,*999)

    EXITS("OC_InterfaceEquations_SparsityGetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_SparsityGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_SparsityGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_SparsityGetObj(interfaceEquations,sparsityType,err)
    !DLLEXPORT(OC_InterfaceEquations_SparsityGetObj)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OpenCMISS_EquationsSparsityType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_SparsityGetObj",err,error,*999)

    CALL InterfaceEquations_SparsityTypeGet(interfaceEquations%interfaceEquations,sparsityType,err,error,*999)

    EXITS("OC_InterfaceEquations_SparsityGetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_SparsityGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_SparsityGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_SparsitySetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,sparsityType,err)
    !DLLEXPORT(OC_InterfaceEquations_SparsitySetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_SparsitySetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_SparsityTypeSet(interfaceEquations,sparsityType,err,error,*999)

    EXITS("OC_InterfaceEquations_SparsitySetNumber")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_SparsitySetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_SparsitySetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_SparsitySetObj(interfaceEquations,sparsityType,err)
    !DLLEXPORT(OC_InterfaceEquations_SparsitySetObj)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OpenCMISS_EquationsSparsityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_SparsitySetObj",err,error,*999)

    CALL InterfaceEquations_SparsityTypeSet(interfaceEquations%interfaceEquations,sparsityType,err,error,*999)

    EXITS("OC_InterfaceEquations_SparsitySetObj")
    RETURN
999 ERRORSEXITS("OC_InterfaceEquations_SparsitySetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_SparsitySetObj

  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for an interface equations identified by a user number.
  SUBROUTINE OC_InterfaceEquations_TimeDependenceTypeGetNumber(contextUserNumber,regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,timeDependenceType,err)
    !DLLEXPORT(OC_InterfaceEquations_TimeDependenceTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface equations time dependence type. \see OpenCMISS_InterfaceEquationsTimeDependenceType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(InterfaceEquationsType), POINTER :: interfaceEquations
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_InterfaceEquations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    NULLIFY(interfaceEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_InterfaceGet(region,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL InterfaceCondition_InterfaceEquationsGet(interfaceCondition,interfaceEquations,err,error,*999)
    CALL InterfaceEquations_TimeDependenceTypeGet(interfaceEquations,timeDependenceType,err,error,*999)

    EXITS("OC_InterfaceEquations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORS("OC_InterfaceEquations_TimeDependenceTypeGetNumber",err,error)
    EXITS("OC_InterfaceEquations_TimeDependenceTypeGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for an interface equations identified by an object.
  SUBROUTINE OC_InterfaceEquations_TimeDependenceTypeGetObj(interfaceEquations,timeDependenceType,err)
    !DLLEXPORT(OC_InterfaceEquations_TimeDependenceTypeGetObj)

    !Argument variables
    TYPE(OC_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the interface equations time dependence type. \see OpenCMISS_InterfaceEquationsTimeDependenceType,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_InterfaceEquations_TimeDependenceTypeGetObj",err,error,*999)

    CALL InterfaceEquations_TimeDependenceTypeGet(interfaceEquations%interfaceEquations,timeDependenceType,err,error,*999)

    EXITS("OC_InterfaceEquations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORS("OC_InterfaceEquations_TimeDependenceTypeGetObj",err,error)
    EXITS("OC_InterfaceEquations_TimeDependenceTypeGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_InterfaceEquations_TimeDependenceTypeGetObj

!!=================================================================================================================================
!!
!! DecompositionRoutines
!!
!!=================================================================================================================================

  !>Finishes the creation of a decomposer identified by a user number.
  SUBROUTINE OC_Decomposer_CreateFinishNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,err)
    !DLLEXPORT(OC_Decomposer_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposer_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_CreateFinish(decomposer,err,error,*999)

    EXITS("OC_Decomposer_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposer_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a decomposer identified by an object.
  SUBROUTINE OC_Decomposer_CreateFinishObj(decomposer,err)
    !DLLEXPORT(OC_Decomposer_CreateFinishObj)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_CreateFinishObj",err,error,*999)

    CALL Decomposer_CreateFinish(decomposer%decomposer,err,error,*999)

    EXITS("OC_Decomposer_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Decomposer_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a decomposer identified by a user number.
  SUBROUTINE OC_Decomposer_CreateStartNumber(decomposerUserNumber,contextUserNumber,regionUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(OC_Decomposer_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to create.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the decomposer for.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to create the decomposer with.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("OC_Decomposer_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(computationEnvironment)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(workGroup)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL Decomposer_CreateStart(decomposerUserNumber,region,workGroup,decomposer,err,error,*999)

    EXITS("OC_Decomposer_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposer_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a decomposer identified by an object.
  SUBROUTINE OC_Decomposer_CreateStartObj(decomposerUserNumber,region,workGroup,decomposer,err)
    !DLLEXPORT(OC_Decomposer_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to create.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to create the decomposer for.
    TYPE(OC_WorkGroupType), INTENT(IN) :: workGroup !<The work group to create the decomposer with.
    TYPE(OC_DecomposerType), INTENT(INOUT) :: decomposer !<On return, the created decomposer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_CreateStartObj",err,error,*999)

    CALL Decomposer_CreateStart(decomposERUserNumber,region%region,workGroup%workGroup,decomposer%decomposer,err,error,*999)

    EXITS("OC_Decomposer_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Decomposer_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a decomposition to a decomposer identified by a user number.
  SUBROUTINE OC_Decomposer_DecompositionAddNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,meshUserNumber, &
    & decompositionUserNumber,decompositionIndex,err)
    !DLLEXPORT(OC_Decomposer_DecompositionAddNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to add the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh of the decomposition to add to the decomposer.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to add to the decomposer.
    INTEGER(INTG), INTENT(OUT) :: decompositionIndex !<On return, the index of the added decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposer_DecompositionAddNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposer_DecompositionAdd(decomposer,decomposition,decompositionIndex,err,error,*999)

    EXITS("OC_Decomposer_DecompositionAddNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposer_DecompositionAddNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_DecompositionAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a decomposition to a decomposer identified by an object.
  SUBROUTINE OC_Decomposer_DecompositionAddObj(decomposer,decomposition,decompositionIndex,err)
    !DLLEXPORT(OC_Decomposer_DecompositionAddObj)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to add the decomposition to.
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to add to the decomposer
    INTEGER(INTG), INTENT(OUT) :: decompositionIndex !<On return, the index of the added decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_DecompositionAddObj",err,error,*999)

    CALL Decomposer_DecompositionAdd(decomposer%decomposer,decomposition%decomposition,decompositionIndex,err,error,*999)

    EXITS("OC_Decomposer_DecompositionAddObj")
    RETURN
999 ERRORSEXITS("OC_Decomposer_DecompositionAddObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_DecompositionAddObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposer identified by a user number.
  SUBROUTINE OC_Decomposer_DestroyNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,err)
    !DLLEXPORT(OC_Decomposer_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposer_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_Destroy(decomposer,err,error,*999)

    EXITS("OC_Decomposer_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposer_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposer identified by an object.
  SUBROUTINE OC_Decomposer_DestroyObj(decomposer,err)
    !DLLEXPORT(OC_Decomposer_DestroyObj)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_DestroyObj",err,error,*999)

    CALL Decomposer_Destroy(decomposer%decomposer,err,error,*999)

    EXITS("OC_Decomposer_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Decomposer_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a decomposer identified by a user number.
  SUBROUTINE OC_Decomposer_OutputTypeGetNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,outputType,err)
    !DLLEXPORT(OC_Decomposer_OutputTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the specified decomposer \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposer_OutputTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_OutputTypeGet(decomposer,outputType,err,error,*999)

    EXITS("OC_Decomposer_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposer_OutputTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the output type for a decomposer identified by an object.
  SUBROUTINE OC_Decomposer_OutputTypeGetObj(decomposer,outputType,err)
    !DLLEXPORT(OC_Decomposer_OutputTypeGetObj)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the specified decomposer \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_OutputTypeGetObj",err,error,*999)

    CALL Decomposer_OutputTypeGet(decomposer%decomposer,outputTYpe,err,error,*999)

    EXITS("OC_Decomposer_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposer_OutputTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a decomposer identified by a user number.
  SUBROUTINE OC_Decomposer_OutputTypeSetNumber(contextUserNumber,regionUserNumber,decomposerUserNumber,outputType,err)
    !DLLEXPORT(OC_Decomposer_OutputTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposer.
    INTEGER(INTG), INTENT(IN) :: decomposerUserNumber !<The user number of the decomposer to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !The output type to set \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecomposerType), POINTER :: decomposer
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposer_OutputTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(decomposer)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_DecomposerGet(region,decomposerUserNumber,decomposer,err,error,*999)
    CALL Decomposer_OutputTypeSet(decomposer,outputType,err,error,*999)

    EXITS("OC_Decomposer_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposer_OutputTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a decomposer identified by an object.
  SUBROUTINE OC_Decomposer_OutputTypeSetObj(decomposer,outputType,err)
    !DLLEXPORT(OC_Decomposer_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_DecomposerType), INTENT(IN) :: decomposer !<The decomposer to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !The output type to set \see OpenCMISS_DecomposerOutputTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposer_OutputTypeSetObj",err,error,*999)

    CALL Decomposer_OutputTypeSet(decomposer%decomposer,outputTYpe,err,error,*999)

    EXITS("OC_Decomposer_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposer_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposer_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_CreateFinishNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber,err)
    !DLLEXPORT(OC_Decomposition_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_CreateFinish(decomposition,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    EXITS("OC_Decomposition_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_CreateFinishObj(decomposition,err)
    !DLLEXPORT(OC_Decomposition_CreateFinishObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_CreateFinishObj",err,error,*999)

    CALL Decomposition_CreateFinish(decomposition%decomposition,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('decomposition Create')
#endif

    EXITS("OC_Decomposition_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !> Calculates the decomposition  for data points
  SUBROUTINE OC_Decomposition_DataProjectionCalculateObj(decomposition,err)
    !DLLEXPORT(OC_Decomposition_DataProjectionCalculateObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_DataProjectionCalculateObj",err,error,*999)

    CALL Decomposition_DataProjectionCalculate(decomposition%decomposition,err,error,*999)

    EXITS("OC_Decomposition_DataProjectionCalculateObj")
    RETURN
999 ERRORS("OC_Decomposition_DataProjectionCalculateObj",err,error)
    EXITS("OC_Decomposition_DataProjectionCalculateObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_DataProjectionCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element user number of an element in a decomposition identified by a user number
  SUBROUTINE OC_Decomposition_ElementAdjacentElementGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,elementUserNumber,adjacentElementXi,adjacentElementIdx,adjacentUserElement,err)
    !DLLEXPORT(OC_Decomposition_ElementAdjacentElementGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposition from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of decomposition from which to get adjacent element number from.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the adjacent element number for. 
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(IN) :: adjacentElementIdx !<The adjacent element index to get the adjacent element user number for.
    INTEGER(INTG), INTENT(OUT) :: adjacentUserElement !<On return, the adjacent element user number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber,adjacentLocalElement
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementAdjacentElementGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL DecompositionElements_ElementAdjacentNumberGet(decompositionElements,adjacentElementIdx,adjacentElementXi, &
      & localElementNumber,adjacentLocalElement,err,error,*999)
    IF(adjacentLocalElement==0) THEN
      adjacentUserElement=0
    ELSE
      CALL DecompositionElements_ElementUserNumberGet(decompositionElements,adjacentLocalElement,adjacentUserElement, &
        & err,error,*999)
    ENDIF

    EXITS("OC_Decomposition_ElementAdjacentElementGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementAdjacentElementGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementAdjacentElementGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element user number of an element in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_ElementAdjacentElementGetObj(decomposition,elementUserNumber, &
    & adjacentElementXi,adjacentElementIdx,adjacentUserElement,err)
    !DLLEXPORT(OC_Decomposition_ElementAdjacentElementGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the adjacent element number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the adjacent element number for. 
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(IN) :: adjacentElementIdx !<The adjacent element index to get the adjacent element user number for.
    INTEGER(INTG), INTENT(OUT) :: adjacentUserElement !<On return, the adjacent element user number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber,adjacentLocalElement
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_Decomposition_ElementAdjacentElementGetObj",err,error,*999)

    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL DecompositionElements_ElementAdjacentNumberGet(decompositionElements,adjacentElementIdx,adjacentElementXi, &
      & localElementNumber,adjacentLocalElement,err,error,*999)
    IF(adjacentLocalElement==0) THEN
      adjacentUserElement=0
    ELSE
      CALL DecompositionElements_ElementUserNumberGet(decompositionElements,adjacentLocalElement,adjacentUserElement, &
        & err,error,*999)
    ENDIF

    EXITS("OC_Decomposition_ElementAdjacentElementGetObj")
    RETURN
999 ERRORS("OC_Decomposition_ElementAdjacentElementGetObj",err,error)
    EXITS("OC_Decomposition_ElementAdjacentElementGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementAdjacentElementGetObj

  !
  !================================================================================================================================
  !

  !>Returns the basis user number of an element in a decomposition identified by a user number
  SUBROUTINE OC_Decomposition_ElementBasisGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,elementUserNumber,basisUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementBasisGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the decomposition from which to get the element basis from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the element basis from.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of decomposition from which to get element basis number from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element basis for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the adjacent element number for. 
    INTEGER(INTG), INTENT(OUT) :: basisUserNumber !<On return, the user number of the basis of the element in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber
    TYPE(BasisType), POINTER :: basis
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementBasisGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainElements)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    CALL DomainElements_ElementBasisGet(domainElements,localElementNumber,basis,err,error,*999)
    CALL Basis_UserNumberGet(basis,basisUserNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementBasisGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementBasisGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementBasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis user number of an element in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_ElementBasisGetObj(decomposition,meshComponentNumber,elementUserNumber,basis,err)
    !DLLEXPORT(OC_Decomposition_ElementBasisGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the  element basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element basis for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the element basis for.
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<On return, the basis of the element in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_ElementBasisGetObj",err,error,*999)

    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    CALL DomainElements_ElementBasisGet(domainElements,localElementNumber,basis%basis,err,error,*999)
 
    EXITS("OC_Decomposition_ElementBasisGetObj")
    RETURN
999 ERRORS("OC_Decomposition_ElementBasisGetObj",err,error)
    EXITS("OC_Decomposition_ElementBasisGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementBasisGetObj

  !
  !================================================================================================================================
  !

  !>Gets the local data point number for data points projected on an element
  SUBROUTINE OC_Decomposition_ElementDataPointLocalNumberGetObj(decomposition,elementUserNumber,dataPointIndex, &
    & dataPointLocalNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementDataPointLocalNumberGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointLocalNumber !<The data point local number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_ElementDataPointLocalNumberGetObj",err,error,*999)

    CALL Decomposition_ElementDataPointLocalNumberGet(decomposition%decomposition,elementUserNumber, &
      & dataPointIndex,dataPointLocalNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementDataPointLocalNumberGetObj")
    RETURN
999 ERRORS("OC_Decomposition_ElementDataPointLocalNumberGetObj",err,error)
    EXITS("OC_Decomposition_ElementDataPointLocalNumberGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementDataPointLocalNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the user data point number for data points projected on an element
  SUBROUTINE OC_Decomposition_ElementDataPointUserNumberGetObj(decomposition,elementUserNumber,dataPointIndex, &
    & dataPointUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementDataPointUserNumberGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<The data point user number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_ElementDataPointUserNumberGetObj",err,error,*999)

    CALL Decomposition_ElementDataPointUserNumberGet(decomposition%decomposition,elementUserNumber, &
      & dataPointIndex,dataPointUserNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementDataPointUserNumberGetObj")
    RETURN
999 ERRORS("OC_Decomposition_ElementDataPointUserNumberGetObj",err,error)
    EXITS("OC_Decomposition_ElementDataPointUserNumberGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementDataPointUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_CreateStartNumber(decompositionUserNumber,contextUserNumber,regionUserNumber,meshUserNumber,err)
    !DLLEXPORT(OC_Decomposition_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Decomposition_CreateStart(decompositionUserNumber,mesh,decomposition,err,error,*999)

    EXITS("OC_Decomposition_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_CreateStartObj(decompositionUserNumber,mesh,decomposition,err)
    !DLLEXPORT(OC_Decomposition_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to create the decomposition for.
    TYPE(OC_DecompositionType), INTENT(INOUT) :: decomposition !<On return, the created decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('decomposition Create')
#endif

    CALL Decomposition_CreateStart(decompositionUserNumber,mesh%mesh,decomposition%decomposition,err,error,*999)

    EXITS("OC_Decomposition_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_DestroyNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber,err)
    !DLLEXPORT(OC_Decomposition_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_Destroy(decomposition,err,error,*999)

    EXITS("OC_Decomposition_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_DestroyObj(decomposition,err)
    !DLLEXPORT(OC_Decomposition_DestroyObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_DestroyObj",err,error,*999)

    CALL Decomposition_Destroy(decomposition%decomposition,err,error,*999)

    EXITS("OC_Decomposition_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a decomposition domain for a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_DomainGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_DomainGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the domain to get
    TYPE(OC_DomainType), INTENT(INOUT) :: domain !<On return, the decomposition domain object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_DomainGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain%domain,err,error,*999)

    EXITS("OC_Decomposition_DomainGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_DomainGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_DomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a decomposition domain for a mesh component number for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_DomainGetObj(decomposition,meshComponentNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_DestroyObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component to get the domain for.
    TYPE(OC_DomainType), INTENT(INOUT) :: domain !<On return the specfied domain for the decomposition
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_DomainGetObj",err,error,*999)

    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain%domain,err,error,*999)

    EXITS("OC_Decomposition_DomainGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_DomainGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_DomainGetObj

  !
  !================================================================================================================================
  !

  !   !>Calculates the element domains for a decomposition identified by a user number.
  !   SUBROUTINE OC_Decomposition_ElementDomainCalculateNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
  !     & decompositionUserNumber,err)
  !     !DLLEXPORT(OC_Decomposition_ElementDomainCalculateNumber)

  !     !Argument variables
  !     INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
  !     INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to calculate the element domains for.
  !     INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to calculate the element domains for.
  !     INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to calculate the element domains for.
  !     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
  !     !Local variables
  !     TYPE(ContextType), POINTER :: context
  !     TYPE(DecompositionType), POINTER :: decomposition
  !     TYPE(MeshType), POINTER :: mesh
  !     TYPE(RegionType), POINTER :: region
  !     TYPE(RegionsType), POINTER :: regions

  !     ENTERS("OC_Decomposition_ElementDomainCalculateNumber",err,error,*999)

  !     NULLIFY(context)
  !     NULLIFY(regions)
  !     NULLIFY(region)
  !     NULLIFY(mesh)
  !     NULLIFY(decomposition)
  !     CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
  !     CALL Context_RegionsGet(context,regions,err,error,*999)
  !     CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
  !     CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
  !     CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
  !     CALL Decomposition_ElementDomainCalculate(decomposition,err,error,*999)

  !     EXITS("OC_Decomposition_ElementDomainCalculateNumber")
  !     RETURN
  ! 999 ERRORS("OC_Decomposition_ElementDomainCalculateNumber",err,error)
  !     EXITS("OC_Decomposition_ElementDomainCalculateNumber")
  !     CALL OC_HandleError(err,error)
  !     RETURN

  !   END SUBROUTINE OC_Decomposition_ElementDomainCalculateNumber

  !
  !================================================================================================================================
  !

  !   !>Calculates the element domains for a decomposition identified by an object.
  !   SUBROUTINE OC_Decomposition_ElementDomainCalculateObj(decomposition,err)
  !     !DLLEXPORT(OC_Decomposition_ElementDomainCalculateObj)

  !     !Argument variables
  !     TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to calcualte the element domains for.
  !     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
  !     !Local variables

  !     ENTERS("OC_Decomposition_ElementDomainCalculateObj",err,error,*999)

  !     CALL Decomposition_ElementDomainCalculate(decomposition%decomposition,err,error,*999)

  !     EXITS("OC_Decomposition_ElementDomainCalculateObj")
  !     RETURN
  ! 999 ERRORS("OC_Decomposition_ElementDomainCalculateObj",err,error)
  !     EXITS("OC_Decomposition_ElementDomainCalculateObj")
  !     CALL OC_HandleError(err,error)
  !     RETURN

  !   END SUBROUTINE OC_Decomposition_ElementDomainCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_ElementDomainGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_ElementDomainGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementDomainGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_ElementDomainGet(decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("OC_Decomposition_ElementDomainGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementDomainGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_ElementDomainGetObj(decomposition,elementUserNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_ElementDomainGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_ElementDomainGetObj",err,error,*999)

    CALL Decomposition_ElementDomainGet(decomposition%decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("OC_Decomposition_ElementDomainGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementDomainGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementDomainGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_ElementDomainSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_ElementDomainSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computation domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementDomainSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_ElementDomainSet(decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("OC_Decomposition_ElementDomainSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementDomainSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementDomainSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_ElementDomainSetObj(decomposition,elementUserNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_ElementDomainSetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computation domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_ElementDomainSetObj",err,error,*999)

    CALL Decomposition_ElementDomainSet(decomposition%decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("OC_Decomposition_ElementDomainSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementDomainSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementDomainSetObj

  !
  !================================================================================================================================
  !

  !>Returns the element local number for a user element number in a decomposition component identified by a user number.
  SUBROUTINE OC_Decomposition_ElementLocalNumberGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,elementUserNumber,elementLocalNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementLocalNumberGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element number for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number to get the local element in the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: elementLocalNumber !<On return, the local number of the element corresponding to the specified user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementLocalNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,elementLocalNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementLocalNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementLocalNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementLocalNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element local number for an user element number in a decomposition component identified by an object.
  SUBROUTINE OC_Decomposition_ElementLocalNumberGetObj(decomposition,elementUserNumber,elementLocalNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementLocalNumberGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the local element node for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number to get local element in the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: elementLocalNumber !<On return, the local number of the specified user element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
 
    ENTERS("OC_Decomposition_ElementLocalNumberGetObj",err,error,*999)

    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,elementLocalNumber,err,error,*999)
 
    EXITS("OC_Decomposition_ElementLocalNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementLocalNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementLocalNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the node user number for a given local node index in an element in a decomposition component identified by a user number.
  SUBROUTINE OC_Decomposition_ElementNodeGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,elementUserNumber,localNodeIndex,nodeUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementNodeGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element node for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element node for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the element to get the node for. 
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the node for.
    INTEGER(INTG), INTENT(IN) :: localNodeIndex !<The local element node index to the node for
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number of the specified local node in the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: elementLocalNumber,nodeLocalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementNodeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainElements)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,elementLocalNumber,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainElements_ElementNodeGet(domainElements,localNodeIndex,elementLocalNumber,nodelocalNumber,err,error,*999)
    CALL DomainNodes_NodeUserNumberGet(domainNodes,nodeLocalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementNodeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementNodeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNodeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the node user number for a given local node index in an element in a decomposition component identified by a user number.
  SUBROUTINE OC_Decomposition_ElementNodeGetObj(decomposition,meshComponentNumber,elementUserNumber,localNodeIndex, &
    & nodeUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementNodeGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the local element node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the element to get the node for. 
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the node for.
    INTEGER(INTG), INTENT(IN) :: localNodeIndex !<The local element node index to the node for
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number of the specified local node in the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: elementLocalNumber,nodeLocalNumber
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_ElementNodeGetObj",err,error,*999)

    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainElements)
    NULLIFY(domainNodes)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,elementLocalNumber,err,error,*999)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainElements_ElementNodeGet(domainElements,localNodeIndex,elementLocalNumber,nodeLocalNumber,err,error,*999)
    CALL DomainNodes_NodeUserNumberGet(domainNodes,nodeLocalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementNodeGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementNodeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNodeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the element user number for a local element number in a decomposition component identified by a user number.
  SUBROUTINE OC_Decomposition_ElementNumberGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementLocalNumber,elementUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementNumberGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element number for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element number for.
    INTEGER(INTG), INTENT(IN) :: elementLocalNumber !<The local number of the element to get the user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the user number of the specified local element in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementUserNumberGet(decompositionElements,elementLocalNumber,elementUserNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element user number for a local element number in a decomposition component identified by a user number.
  SUBROUTINE OC_Decomposition_ElementNumberGetObj(decomposition,elementLocalNumber,elementUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementNumberGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the local element node for.
    INTEGER(INTG), INTENT(IN) :: elementLocalNumber !<The local number of the element to get the user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the user number of the specified local element in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
 
    ENTERS("OC_Decomposition_ElementNumberGetObj",err,error,*999)

    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementUserNumberGet(decompositionElements,elementLocalNumber,elementUserNumber,err,error,*999)
 
    EXITS("OC_Decomposition_ElementNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of adjacent elements in a xi direction for an element in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_ElementNumberOfAdjacentGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,elementUserNumber,adjacentElementXi,numberOfAdjacent,err)
    !DLLEXPORT(OC_Decomposition_ElementNumberOfAdjacentGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of adjacent elements for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the number of adjacent elements for.
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
   INTEGER(INTG), INTENT(OUT) :: numberOfAdjacent !<On return, the number of adjacent elements in the specified adjacentElementXi direction in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: elementLocalNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementNumberOfAdjacentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,elementLocalNumber,err,error,*999)
    CALL DecompositionElements_ElementNumberAdjacentGet(decompositionElements,adjacentElementXi,elementLocalNumber, &
      & numberOfAdjacent,err,error,*999)
    
    EXITS("OC_Decomposition_ElementNumberOfAdjacentGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementNumberOfAdjacentGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNumberOfAdjacentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of adjacent elements in a xi direction for an element in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_ElementNumberOfAdjacentGetObj(decomposition,elementUserNumber,adjacentElementXi,numberOfAdjacent,err)
    !DLLEXPORT(OC_Decomposition_NumberOfElementsGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the total number of elements for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the number of adjacent elements for.
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: numberOfAdjacent !<On return, the number of adjacent elements in the specified adjacentElementXi direction in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: elementLocalNumber
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_Decomposition_ElementNumberOfAdjacentGetObj",err,error,*999)
 
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,elementLocalNumber,err,error,*999)
    CALL DecompositionElements_ElementNumberAdjacentGet(decompositionElements,adjacentElementXi,elementLocalNumber, &
      & numberOfAdjacent,err,error,*999)

    EXITS("OC_Decomposition_ElementNumberOfAdjacentGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementNumberOfAdjacentGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNumberOfAdjacentGetObj

  !
  !================================================================================================================================
  !

  !>Gets the number of data points projected on an element
  SUBROUTINE OC_Decomposition_ElementNumberOfDataPointsGetObj(decomposition,elementUserNumber,numberOfDataPoints,err)
    !DLLEXPORT(OC_Decomposition_ElementNumberOfDataPointsGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The data point local number to return
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_ElementNumberOfDataPointsGetObj",err,error,*999)

    CALL Decomposition_NumberOfElementDataPointsGet(decomposition%decomposition,elementUserNumber, &
      & numberOfDataPoints,err,error,*999)

    EXITS("OC_Decomposition_ElementNumberOfDataPointsGetObj")
    RETURN
999 ERRORS("OC_Decomposition_ElementNumberOfDataPointsGetObj",err,error)
    EXITS("OC_Decomposition_ElementNumberOfDataPointsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementNumberOfDataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Returns whether or not an element is on a boundary in a decomposition identified by a user number
  SUBROUTINE OC_Decomposition_ElementOnBoundaryGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,elementUserNumber,onBoundary,err)
    !DLLEXPORT(OC_Decomposition_ElementOnBoundaryGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh containing the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of decomposition from which to get the element boundary status from.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the boundary status for. 
    LOGICAL, INTENT(OUT) :: onBoundary !<On return, .TRUE. if the specified element is on the boundary of the mesh, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementOnBoundaryGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL DecompositionElements_ElementBoundaryElementGet(decompositionElements,localElementNumber,onBoundary,err,error,*999)

    EXITS("OC_Decomposition_ElementOnBoundaryGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementOnBoundaryGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementOnBoundaryGetNumber

  !
  !================================================================================================================================
  !

  !>Returns whether or not an element is on a boundary in a decomposition identified by a user number
  SUBROUTINE OC_Decomposition_ElementOnBoundaryGetObj(decomposition,elementUserNumber,onBoundary,err)
    !DLLEXPORT(OC_Decomposition_ElementOnBoundaryGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the element boundary status for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user element number to get the boundary status for. 
    LOGICAL, INTENT(OUT) :: onBoundary !<On return, .TRUE. if the specified element is on the boundary of the mesh, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_Decomposition_ElementOnBoundaryGetObj",err,error,*999)

    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL DecompositionElements_ElementBoundaryElementGet(decompositionElements,localElementNumber,onBoundary,err,error,*999)

    EXITS("OC_Decomposition_ElementOnBoundaryGetObj")
    RETURN
999 ERRORS("OC_Decomposition_ElementOnBoundaryGetObj",err,error)
    EXITS("OC_Decomposition_ElementOnBoundaryGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementOnBoundaryGetObj

  !
  !================================================================================================================================
  !

  !>Returns the version user number used at a local node derivative in an element in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_ElementVersionGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,elementUserNumber,derivativeIndex,localNodeNumber,versionUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementVersionGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh containing the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the version number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the version number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component containing the node to get the version number for.
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The derivative index at the local node of the element to get the version number for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the node to get the version number for.
    INTEGER(INTG), INTENT(OUT) :: versionUserNumber !<On return, the version number used at the local node derivative in the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_ElementVersionGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    CALL DomainElements_ElementVersionGet(domainElements,derivativeIndex,localNodeNumber,localElementNumber, &
      & versionUserNumber,err,error,*999)

    EXITS("OC_Decomposition_ElementVersionGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementVersionGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementVersionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the version user number used at a local node derivative in an element in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_ElementVersionGetObj(decomposition,elementUserNumber,meshComponentNumber,derivativeIndex, &
    & localNodeNumber,versionUserNumber,err)
    !DLLEXPORT(OC_Decomposition_ElementVersionGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the element version for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the version number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the version number for.
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The index of the derivative of the local node to get the version number for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number in the elmeent to get the version number for.
    INTEGER(INTG), INTENT(OUT) :: versionUserNumber !<On return, the user number version used at the local node derivative in the element of the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainElementsType), POINTER :: domainElements
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_ElementVersionGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domainTopology)
    NULLIFY(domainElements)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_ElementDoesExist(decompositionElements,elementUserNumber,localElementNumber,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements,err,error,*999)
    CALL DomainElements_ElementVersionGet(domainElements,derivativeIndex,localNodeNumber,localElementNumber, &
      & versionUserNumber,err,error,*999)
 
    EXITS("OC_Decomposition_ElementVersionGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_ElementVersionGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_ElementVersionGetObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_MeshComponentGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)
    !DLLEXPORT(OC_Decomposition_MeshComponentGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_MeshComponentGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_MeshComponentNumberGet(decomposition,meshComponentNumber,err,error,*999)

    EXITS("OC_Decomposition_MeshComponentGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_MeshComponentGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_MeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_MeshComponentGetObj(decomposition,meshComponentNumber,err)
    !DLLEXPORT(OC_Decomposition_MeshComponentGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_MeshComponentGetObj",err,error,*999)

    CALL Decomposition_MeshComponentNumberGet(decomposition%decomposition,meshComponentNumber,err,error,*999)

    EXITS("OC_Decomposition_MeshComponentGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_MeshComponentGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_MeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_MeshComponentSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,err)
    !DLLEXPORT(OC_Decomposition_MeshComponentSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_MeshComponentSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_MeshComponentNumberSet(decomposition,meshComponentNumber,err,error,*999)

    EXITS("OC_Decomposition_MeshComponentSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_MeshComponentSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_MeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_MeshComponentSetObj(decomposition,meshComponentNumber,err)
    !DLLEXPORT(OC_Decomposition_MeshComponentSetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_MeshComponentSetObj",err,error,*999)

    CALL Decomposition_MeshComponentNumberSet(decomposition%decomposition,meshComponentNumber,err,error,*999)

    EXITS("OC_Decomposition_MeshComponentSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_MeshComponentSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_MeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology for a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_TopologyGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & decompositionTopology,err)
    !DLLEXPORT(OC_Decomposition_TopologyGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition topology for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition topology for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the topology for.
    TYPE(OC_DecompositionTopologyType), INTENT(OUT) :: decompositionTopology !<On return, the decomposition topology object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_TopologyGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology%decompositionTopology,err,error,*999)

    EXITS("OC_Decomposition_TopologyGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_TopologyGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_TopologyGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology for a mesh component number for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_TopologyGetObj(decomposition,decompositionTopology,err)
    !DLLEXPORT(OC_Decomposition_TopologyGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the topology for.
    TYPE(OC_DecompositionTopologyType), INTENT(INOUT) :: decompositionTopology !<On return the specfied topology for the decomposition
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_TopologyGetObj",err,error,*999)

    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology%decompositionTopology, &
      & err,error,*999)

    EXITS("OC_Decomposition_TopologyGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_TopologyGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_TopologyGetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_TypeGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & domainDecompositionType,err)
    !DLLEXPORT(OC_Decomposition_TypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the decomposition type for.
    INTEGER(INTG), INTENT(OUT) :: domainDecompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_TypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_TypeGet(decomposition,domainDecompositionType,err,error,*999)

    EXITS("OC_Decomposition_TypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_TypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_TypeGetObj(decomposition,domainDecompositionType,err)
    !DLLEXPORT(OC_Decomposition_TypeGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the type for.
    INTEGER(INTG), INTENT(OUT) :: domainDecompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_TypeGetObj",err,error,*999)

    CALL Decomposition_TypeGet(decomposition%decomposition,domainDecompositionType,err,error,*999)

    EXITS("OC_Decomposition_TypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_TypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_TypeSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & domainDecompositionType,err)
    !DLLEXPORT(OC_Decomposition_TypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: domainDecompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_TypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_TypeSet(decomposition,domainDecompositionType,err,error,*999)

    EXITS("OC_Decomposition_TypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_TypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_TypeSetObj(decomposition,domainDecompositionType,err)
    !DLLEXPORT(OC_Decomposition_TypeSetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the type for.
    INTEGER(INTG), INTENT(IN) :: domainDecompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_TypeSetObj",err,error,*999)

    CALL Decomposition_TypeSet(decomposition%decomposition,domainDecompositionType,err,error,*999)

    EXITS("OC_Decomposition_TypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_TypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group of a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_WorkGroupSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & workGroupUserNumber,err)
    !DLLEXPORT(OC_Decomposition_WorkGroupSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition work group for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the work group for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the work group for.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("OC_Decomposition_WorkGroupSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(computationEnvironment)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL Decomposition_WorkGroupSet(decomposition,workGroup,err,error,*999)

    EXITS("OC_Decomposition_WorkGroupSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_WorkGroupSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_WorkGroupSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group for a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_WorkGroupSetObj(decomposition,workGroup,err)
    !DLLEXPORT(OC_Decomposition_WorkGroupSetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the work group for.
    TYPE(OC_WorkGroupType), INTENT(IN) :: workGroup !<The work group to set for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_WorkGroupSetObj",err,error,*999)

    CALL Decomposition_WorkGroupSet(decomposition%decomposition,workGroup%workGroup,err,error,*999)

    EXITS("OC_Decomposition_WorkGroupSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_WorkGroupSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_WorkGroupSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE OC_Decomposition_CalculateLinesSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,&
    & decompositionUserNumber,calculateLinesFlag,err)
    !DLLEXPORT(OC_Decomposition_CalculateLinesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_CalculateLinesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_CalculateLinesSet(decomposition,calculateLinesFlag,err,error,*999)

    EXITS("OC_Decomposition_CalculateLinesSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CalculateLinesSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CalculateLinesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE OC_Decomposition_CalculateLinesSetObj(decomposition,calculateLinesFlag,err)
    !DLLEXPORT(OC_Decomposition_CalculateLinesSetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_CalculateLinesSetObj",err,error,*999)

    CALL Decomposition_CalculateLinesSet(decomposition%decomposition,calculateLinesFlag,err,error,*999)

    EXITS("OC_Decomposition_CalculateLinesSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CalculateLinesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CalculateLinesSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE OC_Decomposition_CalculateFacesSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,calculateFacesFlag,err)
    !DLLEXPORT(OC_Decomposition_CalculateFacesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_CalculateFacesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_CalculateFacesSet(decomposition,calculateFacesFlag,err,error,*999)

    EXITS("OC_Decomposition_CalculateFacesSetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CalculateFacesSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CalculateFacesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE OC_Decomposition_CalculateFacesSetObj(decomposition,calculateFacesFlag,err)
    !DLLEXPORT(OC_Decomposition_CalculateFacesSetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate faces flag for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_CalculateFacesSetObj",err,error,*999)

    CALL Decomposition_CalculateFacesSet(decomposition%decomposition,calculateFacesFlag,err,error,*999)

    EXITS("OC_Decomposition_CalculateFacesSetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_CalculateFacesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_CalculateFacesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_NodeDomainGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,nodeUserNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_NodeDomainGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeDomainGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_NodeDomainGet(decomposition,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    EXITS("OC_Decomposition_NodeDomainGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeDomainGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_NodeDomainGetObj(decomposition,meshComponentNumber,nodeUserNumber,domain,err)
    !DLLEXPORT(OC_Decomposition_NodeDomainGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computation domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Decomposition_NodeDomainGetObj",err,error,*999)

    CALL Decomposition_NodeDomainGet(decomposition%decomposition,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    EXITS("OC_Decomposition_NodeDomainGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeDomainGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeDomainGetObj

  !
  !================================================================================================================================
  !

  !>Returns the global derivative indes for a given local node derivative in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeGlobalDerivativeGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,derivativeIndex,nodeUserNumber,globalDerivativeIndex,err)
    !DLLEXPORT(OC_Decomposition_NodeGlobalDerivativeGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh containing the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node global derivative for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the node global derivative for for.
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The local node derivative to get the global derivative for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the global derivative for.
    INTEGER(INTG), INTENT(OUT) :: globalDerivativeIndex !<On return, the global derivative index of the node local derivative.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeGlobalDerivativeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_DerivativeGlobalIndexGet(domainNodes,derivativeIndex,localNodeNumber,globalDerivativeIndex, &
      & err,error,*999)
    
    EXITS("OC_Decomposition_NodeGlobalDerivativeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeGlobalDerivativeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeGlobalDerivativeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the global derivative indes for a given local node derivative in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NodeGlobalDerivativeGetObj(decomposition,meshComponentNumber,derivativeIndex,nodeUserNumber, &
    & globalDerivativeIndex,err)
    !DLLEXPORT(OC_Decomposition_NodeGlobalDerivativeGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the node global derivative for for.
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The local node derivative to get the global derivative for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the global derivative for.
    INTEGER(INTG), INTENT(OUT) :: globalDerivativeIndex !<On return, the global derivative index of the node local derivative.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
 
    ENTERS("OC_Decomposition_NodeGlobalDerivativeGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_DerivativeGlobalIndexGet(domainNodes,derivativeIndex,localNodeNumber,globalDerivativeIndex, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodeGlobalDerivativeGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeGlobalDerivativeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeGlobalDerivativeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the node local number for an user node number in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeLocalNumberGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,nodeUserNumber,nodeLocalNumber,err)
    !DLLEXPORT(OC_Decomposition_NodeLocalNumberGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node number for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node number for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user node number to get the local node in the decomposition mesh component for.
    INTEGER(INTG), INTENT(OUT) :: nodeLocalNumber !<On exit, the local number of the node corresponding to the user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeLocalNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,nodeLocalNumber,err,error,*999)

    EXITS("OC_Decomposition_NodeLocalNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeLocalNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeLocalNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the node local number for an user node number in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NodeLocalNumberGetObj(decomposition,meshComponentNumber,nodeUserNumber,nodeLocalNumber,err)
    !DLLEXPORT(OC_Decomposition_NodeLocalNumberGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the local node user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node number for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: nodeLocalNumber !<On return, the local node number of the specified user node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
   
    ENTERS("OC_Decomposition_NodeLocalNumberGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,nodeLocalNumber,err,error,*999)
    
    EXITS("OC_Decomposition_NodeLocalNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeLocalNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN
    
  END SUBROUTINE OC_Decomposition_NodeLocalNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the node user number for a local node number in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeNumberGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,nodeLocalNumber,nodeUserNumber,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node number for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node number for
    INTEGER(INTG), INTENT(IN) :: nodeLocalNumber !<The local number of the node to get the user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number of the specified local node in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeUserNumberGet(domainNodes,nodeLocalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Decomposition_NodeNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the node user number for a local node number in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NodeNumberGetObj(decomposition,meshComponentNumber,nodeLocalNumber,nodeUserNumber,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the local node user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node number for
    INTEGER(INTG), INTENT(IN) :: nodeLocalNumber !<The local number of the node to get the user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number of the specified local node in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
   
    ENTERS("OC_Decomposition_NodeNumberGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeUserNumberGet(domainNodes,nodeLocalNumber,nodeUserNumber,err,error,*999)
 
    EXITS("OC_Decomposition_NodeNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives at given node in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeNumberOfDerivativesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,nodeUserNumber,numberOfDerivatives,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberOfDerivativesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node number of derivatives for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the number of derivatives for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives !<On return, the number of derivatives for the node in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeNumberOfDerivativesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeNumberOfDerivativesGet(domainNodes,localNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("OC_Decomposition_NodeNumberOfDerivativesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberOfDerivativesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberOfDerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives at given node in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeNumberOfDerivativesGetObj(decomposition,meshComponentNumber,nodeUserNumber, &
    & numberOfDerivatives,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberOfDerivativesGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the node number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node number of derivatives for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the number of derivatives for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives !<On return, the number of derivatives for the node in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NodeNumberOfDerivativesGetObj",err,error,*999)
 
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeNumberOfDerivativesGet(domainNodes,localNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("OC_Decomposition_NodeNumberOfDerivativesGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberOfDerivativesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberOfDerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements surrounding a given node in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,nodeUserNumber,numberOfSurroundingElements,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node number of surrounding for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node number of surrounding for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node number of surrounding for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component containing the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the number of surrounding elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSurroundingElements !<On return, the number of elements surrounding the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeNumberOfSurroundingElementsGet(domainNodes,localNodeNumber,numberOfSurroundingElements,err,error,*999)

    EXITS("OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberOfSurroundingElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements surrounding a node in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_NodeNumberOfSurroundingElementsGetObj(decomposition,meshComponentNumber,nodeUserNumber, &
    & numberOfSurroundingElements,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberOfSurroundingElementsGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSurroundingElements !<On return, the number of elements surrounding the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NodeNumberOfSurroundingElementsGetObj",err,error,*999)

 
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeNumberOfSurroundingElementsGet(domainNodes,localNodeNumber,numberOfSurroundingElements,err,error,*999)

    EXITS("OC_Decomposition_NodeNumberOfSurroundingElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberOfSurroundingElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberOfSurroundingElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of versions at given node derivative in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeNumberOfVersionsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,derivativeIndex,nodeUserNumber,numberOfVersions,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberOfVersionsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node derivative number of versions for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node derivative number of versions for
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The derivative index to get the node derivative number of versions for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the number of versions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of versions for the node derivative in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeNumberOfVersionsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_DerivativeNumberOfVersionsGet(domainNodes,derivativeIndex,localNodeNumber,numberOfVersions, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodeNumberOfVersionsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberOfVersionsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeNumberOfVersionsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of versions at given node derivative in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeNumberOfVersionsGetObj(decomposition,meshComponentNumber,derivativeIndex,nodeUserNumber, &
    & numberOfVersions,err)
    !DLLEXPORT(OC_Decomposition_NodeNumberOfVersionsGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the node derivative number of versions for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node derivative number of versions for
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The derivative index to get the node derivative number of versions for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the number of versions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of versions for the node derivative in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NodeNumberOfVersionsGetObj",err,error,*999)
 
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_DerivativeNumberOfVersionsGet(domainNodes,derivativeIndex,localNodeNumber,numberOfVersions, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodeNumberOfVersionsGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeNumberOfVersionsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN
    

  END SUBROUTINE OC_Decomposition_NodeNumberOfVersionsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the boundary status of a given node in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeOnBoundaryGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,nodeUserNumber,onBoundary,err)
    !DLLEXPORT(OC_Decomposition_NodeOnBoundaryGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node boundary status for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node boundary status for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the boundary status for.
    LOGICAL, INTENT(OUT) :: onBoundary !<On return, .TRUE. if the specified node is on the boundary of the decomposition mesh component, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeOnBoundaryGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeBoundaryNodeGet(domainNodes,localNodeNumber,onBoundary,err,error,*999)
    
    EXITS("OC_Decomposition_NodeOnBoundaryGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeOnBoundaryGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeOnBoundaryGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the boundary status of a given node in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodeOnBoundaryGetObj(decomposition,meshComponentNumber,nodeUserNumber, &
    & onBoundary,err)
    !DLLEXPORT(OC_Decomposition_NodeOnBoundaryGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the node boundary status for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the node boundary status for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the boundary status for.
    LOGICAL, INTENT(OUT) :: onBoundary !<On return, .TRUE. if the specified node is on the boundary of the decomposition mesh component, .FALSE. if not.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NodeOnBoundaryGetObj",err,error,*999)
 
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeBoundaryNodeGet(domainNodes,localNodeNumber,onBoundary,err,error,*999)

    EXITS("OC_Decomposition_NodeOnBoundaryGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeOnBoundaryGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeOnBoundaryGetObj

  !
  !================================================================================================================================
  !

  !>Returns the partial derivative indes for a given local node derivative in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NodePartialDerivativeGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,derivativeIndex,nodeUserNumber,partialDerivativeIndex,err)
    !DLLEXPORT(OC_Decomposition_NodePartialDerivativeGetNumber)
    
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh containing the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node partial derivative for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the node partial derivative for for.
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The local node derivative to get the partial derivative for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the partial derivative for.
    INTEGER(INTG), INTENT(OUT) :: partialDerivativeIndex !<On return, the partial derivative index of the node local derivative.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodePartialDerivativeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_DerivativePartialIndexGet(domainNodes,derivativeIndex,localNodeNumber,partialDerivativeIndex, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodePartialDerivativeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodePartialDerivativeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodePartialDerivativeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the partial derivative index for a given local node derivative in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NodePartialDerivativeGetObj(decomposition,meshComponentNumber,derivativeIndex,nodeUserNumber, &
    & partialDerivativeIndex,err)
    !DLLEXPORT(OC_Decomposition_NodePartialDerivativeGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the node partial derivative for for.
    INTEGER(INTG), INTENT(IN) :: derivativeIndex !<The local node derivative to get the partial derivative for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the partial derivative for.
    INTEGER(INTG), INTENT(OUT) :: partialDerivativeIndex !<On return, the partial derivative index of the node local derivative.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
 
    ENTERS("OC_Decomposition_NodePartialDerivativeGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_DerivativePartialIndexGet(domainNodes,derivativeIndex,localNodeNumber,partialDerivativeIndex, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodePartialDerivativeGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodePartialDerivativeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodePartialDerivativeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the user number of an element surrounding a given node in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_NodeSurroundingElementGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,nodeUserNumber,surroundingElementIdx,surroundingElementUserNumber,err)
    !DLLEXPORT(OC_Decomposition_NodeSurroundingElementGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node surrounding element for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node number of surrounding for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node number of surrounding for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component containing the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the number of surrounding elements for.
    INTEGER(INTG), INTENT(IN) :: surroundingElementIdx !<The surrounding element index to get the surrounding element ofr
    INTEGER(INTG), INTENT(OUT) :: surroundingElementUserNumber !<On return, the element user number that is surrounding the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber,localNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NodeSurroundingElementGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeSurroundingElementGet(domainNodes,surroundingElementIdx,localNodeNumber,localElementNumber, &
      & err,error,*999)
    CALL DecompositionElements_ElementUserNumberGet(decompositionElements,localElementNumber,surroundingElementUserNumber, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodeSurroundingElementGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeSurroundingElementGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeSurroundingElementGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number of an element surrounding a given node in a decomposition identified by an object. \todo Maybe swap Node and MeshComponent?
  SUBROUTINE OC_Decomposition_NodeSurroundingElementGetObj(decomposition,meshComponentNumber,nodeUserNumber,surroundingElementIdx, &
    & surroundingElementUserNumber,err)
    !DLLEXPORT(OC_Decomposition_NodeSurroundingElementGetObj)

    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: surroundingElementIdx !<The index of the surrounding element to get.
    INTEGER(INTG), INTENT(OUT) :: surroundingElementUserNumber !<On return, the user number of the element surrounding the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber,localNodeNumber
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NodeSurroundingElementGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NodeDoesExist(domainNodes,nodeUserNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeSurroundingElementGet(domainNodes,surroundingElementIdx,localNodeNumber,localElementNumber,err,error,*999)
    CALL DecompositionElements_ElementUserNumberGet(decompositionElements,localElementNumber,surroundingElementUserNumber, &
      & err,error,*999)

    EXITS("OC_Decomposition_NodeSurroundingElementGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NodeSurroundingElementGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NodeSurroundingElementGetObj

  !
  !================================================================================================================================
  !

  !>Returns the total (local+ghost) number of elements in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_NumberOfElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,numberOfElements,err)
    !DLLEXPORT(OC_Decomposition_NumberOfElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the total (local+ghost) number of elements in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_TotalNumberOfElementsGet(decompositionElements,numberOfElements,err,error,*999)
    
    EXITS("OC_Decomposition_NumberOfElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the total (local+ghost) number of elements in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_NumberOfElementsGetObj(decomposition,numberOfElements,err)
    !DLLEXPORT(OC_Decomposition_NumberOfElementsGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the total number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the total (local+ghost) number of elements in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology

    ENTERS("OC_Decomposition_NumberOfElementsGetObj",err,error,*999)
 
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_TotalNumberOfElementsGet(decompositionElements,numberOfElements,err,error,*999)

    EXITS("OC_Decomposition_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of ghost elements in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_NumberOfGhostElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,numberOfGhostElements,err)
    !DLLEXPORT(OC_Decomposition_NumberOfGhostElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of ghost elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGhostElements !<On return, the number of ghost elements in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: numberOfElements,totalNumberOfElements
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NumberOfGhostElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_TotalNumberOfElementsGet(decompositionElements,totalNumberOfElements,err,error,*999)
    CALL DecompositionElements_NumberOfElementsGet(decompositionElements,numberOfElements,err,error,*999)
    numberOfGhostElements=totalNumberOfElements-numberOfElements
    
    EXITS("OC_Decomposition_NumberOfGhostElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfGhostElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfGhostElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of ghost elements in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_NumberOfGhostElementsGetObj(decomposition,numberOfGhostElements,err)
    !DLLEXPORT(OC_Decomposition_NumberOfGhostElementsGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of ghost elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGhostElements !<On return, the number of ghost elements in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: numberOfElements,totalNumberOfElements
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    
    ENTERS("OC_Decomposition_NumberOfGhostElementsGetObj",err,error,*999)
 
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_TotalNumberOfElementsGet(decompositionElements,totalNumberOfElements,err,error,*999)
    CALL DecompositionElements_NumberOfElementsGet(decompositionElements,numberOfElements,err,error,*999)
    numberOfGhostElements=totalNumberOfElements-numberOfElements

    EXITS("OC_Decomposition_NumberOfGhostElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfGhostElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfGhostElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of ghost nodes in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NumberOfGhostNodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,numberOfGhostNodes,err)
    !DLLEXPORT(OC_Decomposition_NumberOfGhostNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of ghost nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the decomposition to get the number of ghost nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGhostNodes !<On return, the number of ghost nodes in the decomposition mesh component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: numberOfNodes,totalNumberOfNodes
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NumberOfGhostNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_TotalNumberOfNodesGet(domainNodes,totalNumberOfNodes,err,error,*999)
    CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
    numberOfGhostNodes=totalNumberOfNodes-numberOfNodes
    
    EXITS("OC_Decomposition_NumberOfGhostNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfGhostNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfGhostNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of ghost nodes in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NumberOfGhostNodesGetObj(decomposition,meshComponentNumber,numberOfGhostNodes,err)
    !DLLEXPORT(OC_Decomposition_NumberOfGhostNodesGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of ghost nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the decomposition to get the number of ghost nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGhostNodes !<On return, the number of ghost nodes in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: numberOfNodes,totalNumberOfNodes
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NumberOfGhostNodesGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_TotalNumberOfNodesGet(domainNodes,totalNumberOfNodes,err,error,*999)
    CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
    numberOfGhostNodes=totalNumberOfNodes-numberOfNodes

    EXITS("OC_Decomposition_NumberOfGhostNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfGhostNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfGhostNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of local elements in a decomposition identified by a user number.
  SUBROUTINE OC_Decomposition_NumberOfLocalElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,numberOfLocalElements,err)
    !DLLEXPORT(OC_Decomposition_NumberOfLocalElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of local elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalElements !<On return, the number of local elements in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NumberOfLocalElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_NumberOfElementsGet(decompositionElements,numberOfLocalElements,err,error,*999)
    
    EXITS("OC_Decomposition_NumberOfLocalElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfLocalElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfLocalElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local elements in a decomposition identified by an object.
  SUBROUTINE OC_Decomposition_NumberOfLocalElementsGetObj(decomposition,numberOfLocalElements,err)
    !DLLEXPORT(OC_Decomposition_NumberOfLocalElementsGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of ghost elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalElements !<On return, the number of local elements in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DecompositionElementsType), POINTER :: decompositionElements
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    
    ENTERS("OC_Decomposition_NumberOfLocalElementsGetObj",err,error,*999)
 
    NULLIFY(decompositionTopology)
    NULLIFY(decompositionElements)
    CALL Decomposition_DecompositionTopologyGet(decomposition%decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements,err,error,*999)
    CALL DecompositionElements_NumberOfElementsGet(decompositionElements,numberOfLocalElements,err,error,*999)

    EXITS("OC_Decomposition_NumberOfLocalElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfLocalElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfLocalElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NumberOfLocalNodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,numberOfLocalNodes,err)
    !DLLEXPORT(OC_Decomposition_NumberOfLocalNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of local nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the decomposition to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the decomposition mesh component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NumberOfLocalNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfLocalNodes,err,error,*999)
    
    EXITS("OC_Decomposition_NumberOfLocalNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfLocalNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfLocalNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NumberOfLocalNodesGetObj(decomposition,meshComponentNumber,numberOfLocalNodes,err)
    !DLLEXPORT(OC_Decomposition_NumberOfLocalNodesGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of local nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the decomposition to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NumberOfLocalNodesGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_NumberOfNodesGet(domainNodes,numberOfLocalNodes,err,error,*999)

    EXITS("OC_Decomposition_NumberOfLocalNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfLocalNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfLocalNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the total (local+ghost) number of nodes in a decomposition mesh component identified by a user number.
  SUBROUTINE OC_Decomposition_NumberOfNodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & decompositionUserNumber,meshComponentNumber,numberOfNodes,err)
    !DLLEXPORT(OC_Decomposition_NumberOfNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh with the decomposition.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the decomposition to get the number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the total (local+ghost) number of nodes in the decomposition mesh component
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Decomposition_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainNodes_TotalNumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
    
    EXITS("OC_Decomposition_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Decomposition_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the total (local+ghost) number of nodes in a decomposition mesh component identified by an object.
  SUBROUTINE OC_Decomposition_NumberOfNodesGetObj(decomposition,meshComponentNumber,numberOfNodes,err)
    !DLLEXPORT(OC_Decomposition_NumberOfNodesGetObj)
    
    !Argument variables
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the decomposition to get the number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the total (local+ghost) number of nodes in the decomposition mesh component.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainNodesType), POINTER :: domainNodes
    TYPE(DomainTopologyType), POINTER :: domainTopology

    ENTERS("OC_Decomposition_NumberOfNodesGetObj",err,error,*999)

    NULLIFY(domain)
    NULLIFY(domainTopology)
    NULLIFY(domainNodes)
    CALL Decomposition_DomainGet(decomposition%decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes,err,error,*999)
    CALL DomainNodes_TotalNumberOfNodesGet(domainNodes,numberOfNodes,err,error,*999)
    
    EXITS("OC_Decomposition_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Decomposition_NumberOfNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN
    
  END SUBROUTINE OC_Decomposition_NumberOfNodesGetObj

!!==================================================================================================================================
!!
!! Decomposition Element Routines
!!
!!==================================================================================================================================
 
  !>Returns a decomposition element for a decomposition elements identified by an object.
  SUBROUTINE OC_DecompositionElements_ElementGetObj(decompositionElements,userElementNumber,decompositionElement,err)
    !DLLEXPORT(OC_DecompositionElements_ElementGetObj)

    !Argument variables
    TYPE(OC_DecompositionElementsType), INTENT(IN) :: decompositionElements !<The decomposition elements to get the element for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get
    TYPE(OC_DecompositionElementType), INTENT(INOUT) :: decompositionElement !<On return, the decomposition specified decomposition element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber

    ENTERS("OC_DecompositionElements_ElementGetObj",err,error,*999)

    !Given that the decomposition elements are "read only" always nullify? or rely on user? For now, rely on user.
    !NULLIFY(decompositionElement%decompositionElement)
    CALL DecompositionElements_ElementDoesExist(decompositionElements%decompositionElements,userElementNumber,localElementNumber, &
      & err,error,*999)
    CALL DecompositionElements_ElementGet(decompositionElements%decompositionElements,localElementNumber,&
      & decompositionElement%decompositionElement,err,error,*999)

    EXITS("OC_DecompositionElements_ElementGetObj")
    RETURN
999 ERRORSEXITS("OC_DecompositionElements_ElementGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionElements_ElementGetObj

!!==================================================================================================================================
!!
!! Decomposition Face Routines
!!
!!==================================================================================================================================
 

!!==================================================================================================================================
!!
!! Decomposition Line Routines
!!
!!==================================================================================================================================
 

!!==================================================================================================================================
!!
!! Decomposition Topology Routines
!!
!!==================================================================================================================================

  !>Returns a decomposition topology elements for a decomposition topology identified by a user number.
  SUBROUTINE OC_DecompositionTopology_ElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & decompositionElements,err)
    !DLLEXPORT(OC_DecompositionTopology_ElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition topology elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition topology elements for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the topology elements for.
    TYPE(OC_DecompositionElementsType), INTENT(OUT) :: decompositionElements !<On return, the decomposition elements object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DecompositionTopology_ElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology,decompositionElements%decompositionElements, &
      & err,error,*999)

    EXITS("OC_DecompositionTopology_ElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_ElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_ElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology elements for a decomposition topology identified by an object.
  SUBROUTINE OC_DecompositionTopology_ElementsGetObj(decompositionTopology,decompositionElements,err)
    !DLLEXPORT(OC_DecompositionTopology_ElementsGetObj)

    !Argument variables
    TYPE(OC_DecompositionTopologyType), INTENT(IN) :: decompositionTopology !<The decomposition topology to get the elements for.
    TYPE(OC_DecompositionElementsType), INTENT(INOUT) :: decompositionElements !<On return the specfied decomposition elements for the decomposition topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionTopology_ElementsGetObj",err,error,*999)

    CALL DecompositionTopology_DecompositionElementsGet(decompositionTopology%decompositionTopology, &
      & decompositionElements%decompositionElements,err,error,*999)

    EXITS("OC_DecompositionTopology_ElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_ElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_ElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology faces for a decomposition topology identified by a user number.
  SUBROUTINE OC_DecompositionTopology_FacesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & decompositionFaces,err)
    !DLLEXPORT(OC_DecompositionTopology_FacesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition topology faces for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition topology faces for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the topology faces for.
    TYPE(OC_DecompositionFacesType), INTENT(OUT) :: decompositionFaces !<On return, the decomposition faces object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DecompositionTopology_FacesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionFacesGet(decompositionTopology,decompositionFaces%decompositionFaces, &
      & err,error,*999)

    EXITS("OC_DecompositionTopology_FacesGetNumber")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_FacesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_FacesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology faces for a decomposition topology identified by an object.
  SUBROUTINE OC_DecompositionTopology_FacesGetObj(decompositionTopology,decompositionFaces,err)
    !DLLEXPORT(OC_DecompositionTopology_FacesGetObj)

    !Argument variables
    TYPE(OC_DecompositionTopologyType), INTENT(IN) :: decompositionTopology !<The decomposition topology to get the faces for.
    TYPE(OC_DecompositionFacesType), INTENT(INOUT) :: decompositionFaces !<On return the specfied decomposition faces for the decomposition topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionTopology_FacesGetObj",err,error,*999)

    CALL DecompositionTopology_DecompositionFacesGet(decompositionTopology%decompositionTopology, &
      & decompositionFaces%decompositionFaces,err,error,*999)

    EXITS("OC_DecompositionTopology_FacesGetObj")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_FacesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_FacesGetObj

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology lines for a decomposition topology identified by a user number.
  SUBROUTINE OC_DecompositionTopology_LinesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & decompositionLines,err)
    !DLLEXPORT(OC_DecompositionTopology_LinesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition topology lines for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition topology lines for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the topology lines for.
    TYPE(OC_DecompositionLinesType), INTENT(OUT) :: decompositionLines !<On return, the decomposition lines object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DecompositionTopologyType), POINTER :: decompositionTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DecompositionTopology_LinesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(decompositionTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DecompositionTopologyGet(decomposition,decompositionTopology,err,error,*999)
    CALL DecompositionTopology_DecompositionLinesGet(decompositionTopology,decompositionLines%decompositionLines, &
      & err,error,*999)

    EXITS("OC_DecompositionTopology_LinesGetNumber")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_LinesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_LinesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a decomposition topology lines for a decomposition topology identified by an object.
  SUBROUTINE OC_DecompositionTopology_LinesGetObj(decompositionTopology,decompositionLines,err)
    !DLLEXPORT(OC_DecompositionTopology_LinesGetObj)

    !Argument variables
    TYPE(OC_DecompositionTopologyType), INTENT(IN) :: decompositionTopology !<The decomposition topology to get the lines for.
    TYPE(OC_DecompositionLinesType), INTENT(INOUT) :: decompositionLines !<On return the specfied decomposition lines for the decomposition topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DecompositionTopology_LinesGetObj",err,error,*999)

    CALL DecompositionTopology_DecompositionLinesGet(decompositionTopology%decompositionTopology, &
      & decompositionLines%decompositionLines,err,error,*999)

    EXITS("OC_DecompositionTopology_LinesGetObj")
    RETURN
999 ERRORSEXITS("OC_DecompositionTopology_LinesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DecompositionTopology_LinesGetObj


!!==================================================================================================================================
!!
!! Domain Routines
!!
!!==================================================================================================================================

  !>Returns a domain topology for a decomposition domain identified by a user number.
  SUBROUTINE OC_Domain_TopologyGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,domainTopology,err)
    !DLLEXPORT(OC_Domain_TopologyGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the domain topology for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the domain topology for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the domain topology for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the domain topology
    TYPE(OC_DomainTopologyType), INTENT(OUT) :: domainTopology !<On return, the domain topology object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Domain_TopologyGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)    
    CALL Domain_DomainTopologyGet(domain,domainTopology%domainTopology,err,error,*999)

    EXITS("OC_Domain_TopologyGetNumber")
    RETURN
999 ERRORSEXITS("OC_Domain_TopologyGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Domain_TopologyGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a domain topology for a domain identified by an object.
  SUBROUTINE OC_Domain_TopologyGetObj(domain,domainTopology,err)
    !DLLEXPORT(OC_Domain_TopologyGetObj)

    !Argument variables
    TYPE(OC_DomainType), INTENT(IN) :: domain !<The domain to get the topology for.
    TYPE(OC_DomainTopologyType), INTENT(INOUT) :: domainTopology !<On return the specfied topology for the domain
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Domain_TopologyGetObj",err,error,*999)

    CALL Domain_DomainTopologyGet(domain%domain,domainTopology%domainTopology,err,error,*999)

    EXITS("OC_Domain_TopologyGetObj")
    RETURN
999 ERRORSEXITS("OC_Domain_TopologyGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Domain_TopologyGetObj


!!==================================================================================================================================
!!
!! Domain Element Routines
!!
!!==================================================================================================================================
 
  !>Returns a domain element for a domain elements identified by an object.
  SUBROUTINE OC_DomainElements_ElementGetObj(domainElements,userElementNumber,domainElement,err)
    !DLLEXPORT(OC_DomainElements_ElementGetObj)

    !Argument variables
    TYPE(OC_DomainElementsType), INTENT(IN) :: domainElements !<The domain elements to get the element for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get
    TYPE(OC_DomainElementType), INTENT(INOUT) :: domainElement !<On return, the specified domain element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localElementNumber

    ENTERS("OC_DomainElements_ElementGetObj",err,error,*999)

    !Given that the domain elements are "read only" always nullify? or rely on user? For now, rely on user.
    !NULLIFY(domainElement%domainElement)
    CALL DomainElements_ElementDoesExist(domainElements%domainElements,userElementNumber,localElementNumber,err,error,*999)
    CALL DomainElements_ElementGet(domainElements%domainElements,localElementNumber,domainElement%domainElement,err,error,*999)

    EXITS("OC_DomainElements_ElementGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainElements_ElementGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainElements_ElementGetObj

!!==================================================================================================================================
!!
!! Domain Face Routines
!!
!!==================================================================================================================================
 

!!==================================================================================================================================
!!
!! Domain Line Routines
!!
!!==================================================================================================================================
 

!!==================================================================================================================================
!!
!! Domain Node Routines
!!
!!==================================================================================================================================
 
  !>Returns a domain node for a domain nodes identified by an object.
  SUBROUTINE OC_DomainNodes_NodeGetObj(domainNodes,userNodeNumber,domainNode,err)
    !DLLEXPORT(OC_DomainNodes_NodeGetObj)

    !Argument variables
    TYPE(OC_DomainNodesType), INTENT(IN) :: domainNodes !<The domain nodes to get the node for
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get
    TYPE(OC_DomainNodeType), INTENT(INOUT) :: domainNode !<On return, the specified domain node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: localNodeNumber

    ENTERS("OC_DomainNodes_NodeGetObj",err,error,*999)

    !Given that the domain nodes are "read only" always nullify? or rely on user? For now, rely on user.
    !NULLIFY(domainNode%domainNode)
    CALL DomainNodes_NodeDoesExist(domainNodes%domainNodes,userNodeNumber,localNodeNumber,err,error,*999)
    CALL DomainNodes_NodeGet(domainNodes%domainNodes,localNodeNumber,domainNode%domainNode,err,error,*999)

    EXITS("OC_DomainNodes_NodeGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainNodes_NodeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN
    
  END SUBROUTINE OC_DomainNodes_NodeGetObj
  
  !
  !================================================================================================================================
  !

  !>Returns the number of elements surrounding a domain nodes identified by an object.
  SUBROUTINE OC_DomainNode_NumberOfSurroundingElementsGetObj(domainNode,numberOfSurroundingElements,err)
    !DLLEXPORT(OC_DomainNode_NumberOfSurroundingElementsGetObj)

    !Argument variables
    TYPE(OC_DomainNodeType), INTENT(IN) :: domainNode !<The domain node to get the number of surrounding elements for
    INTEGER(INTG), INTENT(OUT) :: numberOfSurroundingElements !<On return, the number of elements surrounding the node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("OC_DomainNode_NumberOfSurroundingElementsGetObj",err,error,*999)
    
    CALL DomainNode_NumberOfSurroundingElementsGet(domainNode%domainNode,numberOfSurroundingElements,err,error,*999)
    
    EXITS("OC_DomainNode_NumberOfSurroundingElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainNode_NumberOfSurroundingElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN
    
  END SUBROUTINE OC_DomainNode_NumberOfSurroundingElementsGetObj
  
  !
  !================================================================================================================================
  !

  !>Returns the user number of an element surrounding a domain nodes identified by an object.
  SUBROUTINE OC_DomainNode_SurroundingElementGetObj(domainNode,surroundingElementIdx,surroundingElementUserNumber,err)
    !DLLEXPORT(OC_DomainNode_SurroundingElementGetObj)

    !Argument variables
    TYPE(OC_DomainNodeType), INTENT(IN) :: domainNode !<The domain node to get the number of surrounding element for
    INTEGER(INTG), INTENT(IN) :: surroundingElementIdx !<The surrounding element index
    INTEGER(INTG), INTENT(OUT) :: surroundingElementUserNumber !<On return, the number of elements surrounding the node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("OC_DomainNode_SurroundingElementGetObj",err,error,*999)

    surroundingElementUserNumber=0
    
    EXITS("OC_DomainNode_SurroundingElementGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainNode_SurroundingElementGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN
    
  END SUBROUTINE OC_DomainNode_SurroundingElementGetObj
  
!!==================================================================================================================================
!!
!! Domain Topology Routines
!!
!!==================================================================================================================================
 
  !>Returns a domain topology elements for a domain topology identified by a user number.
  SUBROUTINE OC_DomainTopology_ElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,domainElements,err)
    !DLLEXPORT(OC_DomainTopology_ElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the domain topology elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the domain topology elements for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the topology elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the domain to get the topology elements for.
    TYPE(OC_DomainElementsType), INTENT(INOUT) :: domainElements !<On return, the domain elements object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DomainTopology_ElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainElementsGet(domainTopology,domainElements%domainElements,err,error,*999)

    EXITS("OC_DomainTopology_ElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_ElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_ElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a domain topology elements for a domain topology identified by an object.
  SUBROUTINE OC_DomainTopology_ElementsGetObj(domainTopology,domainElements,err)
    !DLLEXPORT(OC_DomainTopology_ElementsGetObj)

    !Argument variables
    TYPE(OC_DomainTopologyType), INTENT(IN) :: domainTopology !<The domain topology to get the elements for.
    TYPE(OC_DomainElementsType), INTENT(INOUT) :: domainElements !<On return the specfied domain elements for the domain topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainTopology_ElementsGetObj",err,error,*999)

    CALL DomainTopology_DomainElementsGet(domainTopology%domainTopology,domainElements%domainElements,err,error,*999)

    EXITS("OC_DomainTopology_ElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_ElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_ElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns a domain topology faces for a domain topology identified by a user number.
  SUBROUTINE OC_DomainTopology_FacesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,domainFaces,err)
    !DLLEXPORT(OC_DomainTopology_FacesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the domain topology faces for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the domain topology faces for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the topology faces for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the domain topology faces for
    TYPE(OC_DomainFacesType), INTENT(OUT) :: domainFaces !<On return, the domain faces object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DomainTopology_FacesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainFacesGet(domainTopology,domainFaces%domainFaces,err,error,*999)

    EXITS("OC_DomainTopology_FacesGetNumber")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_FacesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_FacesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a domain topology faces for a domain topology identified by an object.
  SUBROUTINE OC_DomainTopology_FacesGetObj(domainTopology,domainFaces,err)
    !DLLEXPORT(OC_DomainTopology_FacesGetObj)

    !Argument variables
    TYPE(OC_DomainTopologyType), INTENT(IN) :: domainTopology !<The domain topology to get the faces for.
    TYPE(OC_DomainFacesType), INTENT(INOUT) :: domainFaces !<On return the specfied domain faces for the domain topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainTopology_FacesGetObj",err,error,*999)

    CALL DomainTopology_DomainFacesGet(domainTopology%domainTopology,domainFaces%domainFaces,err,error,*999)

    EXITS("OC_DomainTopology_FacesGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_FacesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_FacesGetObj

  !
  !================================================================================================================================
  !

  !>Returns a domain topology lines for a domain topology identified by a user number.
  SUBROUTINE OC_DomainTopology_LinesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,domainLines,err)
    !DLLEXPORT(OC_DomainTopology_LinesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the domain topology lines for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the domain topology lines for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the domain topology lines for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the domain topology lines for.
    TYPE(OC_DomainLinesType), INTENT(OUT) :: domainLines !<On return, the domain lines object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DomainTopology_LinesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainLinesGet(domainTopology,domainLines%domainLines,err,error,*999)

    EXITS("OC_DomainTopology_LinesGetNumber")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_LinesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_LinesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a domain topology lines for a domain topology identified by an object.
  SUBROUTINE OC_DomainTopology_LinesGetObj(domainTopology,domainLines,err)
    !DLLEXPORT(OC_DomainTopology_LinesGetObj)

    !Argument variables
    TYPE(OC_DomainTopologyType), INTENT(IN) :: domainTopology !<The domain topology to get the lines for.
    TYPE(OC_DomainLinesType), INTENT(INOUT) :: domainLines !<On return the specfied domain lines for the domain topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainTopology_LinesGetObj",err,error,*999)

    CALL DomainTopology_DomainLinesGet(domainTopology%domainTopology,domainLines%domainLines,err,error,*999)

    EXITS("OC_DomainTopology_LinesGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_LinesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_LinesGetObj

  !
  !================================================================================================================================
  !

  !>Returns a domain topology nodes for a domain topology identified by a user number.
  SUBROUTINE OC_DomainTopology_NodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,domainNodes,err)
    !DLLEXPORT(OC_DomainTopology_NodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the domain topology nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the domain topology nodes for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the domain topology nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the domain topology nodes for.
    TYPE(OC_DomainNodesType), INTENT(OUT) :: domainNodes !<On return, the domain nodes object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(DomainType), POINTER :: domain
    TYPE(DomainTopologyType), POINTER :: domainTopology
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_DomainTopology_NodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(domain)
    NULLIFY(domainTopology)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_DecompositionGet(mesh,decompositionUserNumber,decomposition,err,error,*999)
    CALL Decomposition_DomainGet(decomposition,meshComponentNumber,domain,err,error,*999)
    CALL Domain_DomainTopologyGet(domain,domainTopology,err,error,*999)
    CALL DomainTopology_DomainNodesGet(domainTopology,domainNodes%domainNodes,err,error,*999)

    EXITS("OC_DomainTopology_NodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_NodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_NodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns a domain topology nodes for a domain topology identified by an object.
  SUBROUTINE OC_DomainTopology_NodesGetObj(domainTopology,domainNodes,err)
    !DLLEXPORT(OC_DomainTopology_NodesGetObj)

    !Argument variables
    TYPE(OC_DomainTopologyType), INTENT(IN) :: domainTopology !<The domain topology to get the nodes for.
    TYPE(OC_DomainNodesType), INTENT(INOUT) :: domainNodes !<On return the specfied domain nodes for the domain topology
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_DomainTopology_NodesGetObj",err,error,*999)

    CALL DomainTopology_DomainNodesGet(domainTopology%domainTopology,domainNodes%domainNodes,err,error,*999)

    EXITS("OC_DomainTopology_NodesGetObj")
    RETURN
999 ERRORSEXITS("OC_DomainTopology_NodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DomainTopology_NodesGetObj


!!==================================================================================================================================
!!
!! MeshRoutines
!!
!!==================================================================================================================================

  !>Finishes the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE OC_Mesh_CreateFinishNumber(contextUserNumber,regionUserNumber,meshUserNumber,err)
    !DLLEXPORT(OC_Mesh_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_CreateFinish(mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    EXITS("OC_Mesh_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by an object.
  SUBROUTINE OC_Mesh_CreateFinishObj(mesh,err)
    !DLLEXPORT(OC_Mesh_CreateFinishObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_CreateFinishObj",err,error,*999)

    CALL Mesh_CreateFinish(mesh%mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('mesh Create')
#endif

    EXITS("OC_Mesh_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE OC_Mesh_CreateStartNumber(meshUserNumber,contextUserNumber,regionUserNumber,numberOfDimensions,err)
    !DLLEXPORT(OC_Mesh_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Mesh_CreateStart(meshUserNumber,region,numberOfDimensions,mesh,err,error,*999)

    EXITS("OC_Mesh_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE OC_Mesh_CreateStartObj(meshUserNumber,region,numberOfDimensions,mesh,err)
    !DLLEXPORT(OC_Mesh_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(OC_MeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL Mesh_CreateStart(meshUserNumber,region%region,numberOfDimensions,mesh%mesh,err,error,*999)

    EXITS("OC_Mesh_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE OC_Mesh_CreateStartInterfaceObj(meshUserNumber,interface,numberOfDimensions,mesh,err)
    !DLLEXPORT(OC_Mesh_CreateStartInterfaceObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(OC_MeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL Mesh_CreateStart(meshUserNumber,interface%interface,numberOfDimensions,mesh%mesh,err,error,*999)

    EXITS("OC_Mesh_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_CreateStartInterfaceObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by a user number.
  SUBROUTINE OC_Mesh_DestroyNumber(contextUserNumber,regionUserNumber,meshUserNumber,err)
    !DLLEXPORT(OC_Mesh_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL MESH_DESTROY(mesh,err,error,*999)

    EXITS("OC_Mesh_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by an object.
  SUBROUTINE OC_Mesh_DestroyObj(mesh,err)
    !DLLEXPORT(OC_Mesh_DestroyObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_DestroyObj",err,error,*999)

    CALL MESH_DESTROY(mesh%mesh,err,error,*999)

    EXITS("OC_Mesh_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by a user number.
  SUBROUTINE OC_Mesh_NumberOfComponentsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfComponents,err)
    !DLLEXPORT(OC_Mesh_NumberOfComponentsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfComponentsGet(mesh,numberOfComponents,err,error,*999)

    EXITS("OC_Mesh_NumberOfComponentsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfComponentsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by an object.
  SUBROUTINE OC_Mesh_NumberOfComponentsGetObj(mesh,numberOfComponents,err)
    !DLLEXPORT(OC_Mesh_NumberOfComponentsGetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_NumberOfComponentsGetObj",err,error,*999)

    CALL Mesh_NumberOfComponentsGet(mesh%mesh,numberOfComponents,err,error,*999)

    EXITS("OC_Mesh_NumberOfComponentsGetObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfComponentsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by a user number.
  SUBROUTINE OC_Mesh_NumberOfComponentsSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfComponents,err)
    !DLLEXPORT(OC_Mesh_NumberOfComponentsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfComponentsSet(mesh,numberOfComponents,err,error,*999)

    EXITS("OC_Mesh_NumberOfComponentsSetNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfComponentsSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by an object.
  SUBROUTINE OC_Mesh_NumberOfComponentsSetObj(mesh,numberOfComponents,err)
    !DLLEXPORT(OC_Mesh_NumberOfComponentsSetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_NumberOfComponentsSetObj",err,error,*999)

    CALL Mesh_NumberOfComponentsSet(mesh%mesh,numberOfComponents,err,error,*999)

    EXITS("OC_Mesh_NumberOfComponentsSetObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfComponentsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE OC_Mesh_SurroundingElementsCalculateSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & surroundingElementsCalculateFlag,err)
    !DLLEXPORT(OC_Mesh_SurroundingElementsCalculateSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the surrounding elements calculate flag for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_SurroundingElementsCalculateSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_SurroundingElementsCalculateSet(mesh,surroundingElementsCalculateFlag,err,error,*999)

    EXITS("OC_Mesh_SurroundingElementsCalculateSetNumber")
    RETURN
999 ERRORS("OC_Mesh_SurroundingElementsCalculateSetNumber",err,error)
    EXITS("OC_Mesh_SurroundingElementsCalculateSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_SurroundingElementsCalculateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE OC_Mesh_SurroundingElementsCalculateSetObj(mesh,surroundingElementsCalculateFlag,err)
    !DLLEXPORT(OC_Mesh_SurroundingElementsCalculateSetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_SurroundingElementsCalculateSetObj",err,error,*999)

    CALL Mesh_SurroundingElementsCalculateSet(mesh%mesh,surroundingElementsCalculateFlag,err,error,*999)

    EXITS("OC_Mesh_SurroundingElementsCalculateSetObj")
    RETURN
999 ERRORS("OC_Mesh_SurroundingElementsCalculateSetObj",err,error)
    EXITS("OC_Mesh_SurroundingElementsCalculateSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_SurroundingElementsCalculateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by a user number.
  SUBROUTINE OC_Mesh_NumberOfElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfElements,err)
    !DLLEXPORT(OC_Mesh_NumberOfElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfElementsGet(mesh,numberOfElements,err,error,*999)

    EXITS("OC_Mesh_NumberOfElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by an object.
  SUBROUTINE OC_Mesh_NumberOfElementsGetObj(mesh,numberOfElements,err)
    !DLLEXPORT(OC_Mesh_NumberOfElementsGetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_NumberOfElementsGetObj",err,error,*999)

    CALL Mesh_NumberOfElementsGet(mesh%mesh,numberOfElements,err,error,*999)

    EXITS("OC_Mesh_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by a user number.
  SUBROUTINE OC_Mesh_NumberOfElementsSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,numberOfElements,err)
    !DLLEXPORT(OC_Mesh_NumberOfElementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_NumberOfElementsSet(mesh,numberOfElements,err,error,*999)

    EXITS("OC_Mesh_NumberOfElementsSetNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfElementsSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by an object.
  SUBROUTINE OC_Mesh_NumberOfElementsSetObj(mesh,numberOfElements,err)
    !DLLEXPORT(OC_Mesh_NumberOfElementsSetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_NumberOfElementsSetObj",err,error,*999)

    CALL Mesh_NumberOfElementsSet(mesh%mesh,numberOfElements,err,error,*999)

    EXITS("OC_Mesh_NumberOfElementsSetObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_NumberOfElementsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Calculate mesh data points topology in a region identified by a user number based on projection
  SUBROUTINE OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & dataProjection,err)
    !DLLEXPORT(OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL MeshTopology_DataPointsCalculateProjection(mesh,dataProjection%dataProjection,err,error,*999)

    EXITS("OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber")
    RETURN
999 ERRORS("OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber",err,error)
    EXITS("OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_Mesh_TopologyDataPointsCalculateProjectionRegionNumber

  !
  !================================================================================================================================
  !

  !>Calculate mesh data points topology in an interface identified by a user number based on projection
  SUBROUTINE OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber(contextUserNumber,parentRegionUserNumber, &
    & interfaceUserNumber,meshUserNumber,dataProjection,err)
    !DLLEXPORT(OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: parentregionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: parentRegion
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(interface)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentregionUserNumber,parentRegion,err,error,*999)
    CALL Region_InterfaceGet(parentRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_MeshGet(interface,meshUserNumber,mesh,err,error,*999)
    CALL MeshTopology_DataPointsCalculateProjection(mesh,dataProjection%dataProjection,err,error,*999)

    EXITS("OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    RETURN
999 ERRORS("OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber",err,error)
    EXITS("OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Calculate mesh data points topology identified by object based on projection
  SUBROUTINE OC_Mesh_TopologyDataPointsCalculateProjectionObj(mesh,dataProjection,err)
    !DLLEXPORT(OC_Mesh_TopologyDataPointsCalculateProjectionObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to calculate data points topology for
    TYPE(OC_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_TopologyDataPointsCalculateProjectionObj",err,error,*999)

    CALL MeshTopology_DataPointsCalculateProjection(mesh%mesh,dataProjection%dataProjection,err,error,*999)

    EXITS("OC_Mesh_TopologyDataPointsCalculateProjectionObj")
    RETURN
999 ERRORS("OC_Mesh_TopologyDataPointsCalculateProjectionObj",err,error)
    EXITS("OC_Mesh_TopologyDataPointsCalculateProjectionObj")
    CALL OC_HandleError(Err,error)
    RETURN

  END SUBROUTINE OC_Mesh_TopologyDataPointsCalculateProjectionObj

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE OC_MeshElements_CreateFinishNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,err)
    !DLLEXPORT(OC_MeshElements_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_CreateFinish(meshElements,err,error,*999)

    EXITS("OC_MeshElements_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE OC_MeshElements_CreateFinishObj(meshElements,err)
    !DLLEXPORT(OC_MeshElements_CreateFinishObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_CreateFinishObj",err,error,*999)

    CALL MeshElements_CreateFinish(meshElements%meshElements,err,error,*999)

    EXITS("OC_MeshElements_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE OC_MeshElements_CreateStartNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & basisUserNumber,err)
    !DLLEXPORT(OC_MeshElements_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the default basis to use for the elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_CreateStartNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(basis)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL MeshElements_CreateStart(mesh,meshComponentNumber,basis,meshElements,err,error,*999)

    EXITS("OC_MeshElements_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE OC_MeshElements_CreateStartObj(mesh,meshComponentNumber,basis,meshElements,err)
    !DLLEXPORT(OC_MeshElements_CreateStartObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(INOUT) :: mesh !<The mesh to start the creation of elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The default basis to use for the elements.
    TYPE(OC_MeshElementsType), INTENT(INOUT) :: meshElements !<On return, the created mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_CreateStartObj",err,error,*999)

    CALL MeshElements_CreateStart(mesh%mesh,meshComponentNumber,basis%basis,meshElements%meshElements,err,error,*999)

    EXITS("OC_MeshElements_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an user number.
  SUBROUTINE OC_Mesh_ElementsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,meshElements,err)
    !DLLEXPORT(OC_Mesh_ElementsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(OC_MeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_ElementsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements%meshElements,err,error,*999)

    EXITS("OC_Mesh_ElementsGetNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_ElementsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_ElementsGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an
  !user number.
  SUBROUTINE OC_Mesh_ElementsGetObj(mesh,meshComponentNumber,meshElements,err)
    !DLLEXPORT(OC_Mesh_ElementsGetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(OC_MeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables

    ENTERS("OC_Mesh_ElementsGetObj",err,error,*999)

    CALL Mesh_MeshElementsGet(mesh%mesh,meshComponentNumber,meshElements%meshElements,err,error,*999)

    EXITS("OC_Mesh_ElementsGetObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_ElementsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_ElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an user number.
  SUBROUTINE OC_MeshElements_BasisGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,basisUserNumber,err)
    !DLLEXPORT(OC_MeshElements_BasisGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: basisUserNumber !<On return, the user number of the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(BasisType), POINTER :: basis
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_BasisGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementBasisGet(meshElements,globalElementNumber,basis,err,error,*999)
    CALL Basis_UserNumberGet(basis,basisUserNumber,err,error,*999)

    EXITS("OC_MeshElements_BasisGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_BasisGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an object.
  SUBROUTINE OC_MeshElements_BasisGetObj(meshElements,userElementNumber,basis,err)
    !DLLEXPORT(OC_MeshElements_BasisGetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the basis for.
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<On return, the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber

    ENTERS("OC_MeshElements_BasisGetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementBasisGet(meshElements%meshElements,globalElementNumber,basis%basis,err,error,*999)

    EXITS("OC_MeshElements_BasisGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_BasisGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an user number. 
  SUBROUTINE OC_MeshElements_BasisSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,basisUserNumber,err)
    !DLLEXPORT(OC_MeshElements_BasisSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The global element number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_BasisSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(basisFunctions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    NULLIFY(basis)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL Basis_Get(basisFunctions,basisUserNumber,basis,err,error,*999)
    CALL MeshElements_ElementBasisSet(meshElements,globalElementNumber,basis,err,error,*999)

    EXITS("OC_MeshElements_BasisSetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_BasisSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an object. 
  SUBROUTINE OC_MeshElements_BasisSetObj(meshElements,userElementNumber,basis,err)
    !DLLEXPORT(OC_MeshElements_BasisSetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the basis for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the basis for.
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber

    ENTERS("OC_MeshElements_BasisSetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementBasisSet(meshElements%meshElements,globalElementNumber,basis%basis,err,error,*999)

    EXITS("OC_MeshElements_BasisSetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_BasisSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by a user number
  SUBROUTINE OC_MeshElements_AdjacentElementGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,adjacentElementXi,adjacentUserElement,err)
    !DLLEXPORT(OC_MeshElements_AdjacentElementGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get adjacent element number from.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the adjacent element number for. !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentUserElement !<On return, the adjacent element user number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber,adjacentGlobalElement
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_AdjacentElementGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementAdjacentElementGet(meshElements,globalElementNumber,adjacentElementXi,adjacentGlobalElement, &
      & err,error,*999)
    IF(adjacentGlobalElement==0) THEN
      adjacentUserElement=0
    ELSE
      CALL MeshElements_ElementUserNumberGet(meshElements,adjacentGlobalElement,adjacentUserElement,err,error,*999)
    ENDIF

    EXITS("OC_MeshElements_AdjacentElementGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_AdjacentElementGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_AdjacentElementGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by an object.
  SUBROUTINE OC_MeshElements_AdjacentElementGetObj(meshElements,userElementNumber,adjacentElementXi,adjacentUserElement,err)
    !DLLEXPORT(OC_MeshElements_AdjacentElementGetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements from which to get the adjacent element for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the adjacent element for !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for  Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentUserElement !<On return, the adjacent element user number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber,adjacentGlobalElement

    ENTERS("OC_MeshElements_AdjacentElementGetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementAdjacentElementGet(meshElements%meshElements,globalElementNumber,adjacentElementXi, &
      & adjacentGlobalElement,err,error,*999)
    IF(adjacentGlobalElement==0) THEN
      adjacentUserElement=0
    ELSE
      CALL MeshElements_ElementUserNumberGet(meshElements%meshElements,adjacentGlobalElement,adjacentUserElement,err,error,*999)
    ENDIF

    EXITS("OC_MeshElements_AdjacentElementGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_AdjacentElementGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_AdjacentElementGetObj

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user element of a mesh identified by a user number
  SUBROUTINE OC_MeshElements_ElementOnBoundaryGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,onBoundary,err)
    !DLLEXPORT(OC_MeshElements_ElementOnBoundaryGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user element. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_ElementOnBoundaryGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_GlobalNumberGet(meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementOnBoundaryGet(meshElements,globalElementNumber,onBoundary,err,error,*999)

    EXITS("OC_MeshElements_ElementOnBoundaryGetNumber")
    RETURN
999 ERRORS("OC_MeshElements_ElementOnBoundaryGetNumber",err,error)
    EXITS("OC_MeshElements_ElementOnBoundaryGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_ElementOnBoundaryGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user element of a mesh identified by an object
  SUBROUTINE OC_MeshElements_ElementOnBoundaryGetObj(meshElements,userElementNumber,onBoundary,err)
    !DLLEXPORT(OC_MeshElements_ElementOnBoundaryGetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements from which to get the boundary type for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user element. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber

    ENTERS("OC_MeshElements_ElementOnBoundaryGetObj",err,error,*999)

    CALL MeshElements_GlobalNumberGet(meshElements%meshElements,userElementNumber,globalElementNumber,err,error,*999)
    CALL MeshElements_ElementOnBoundaryGet(meshElements%meshElements,globalElementNumber,onBoundary,err,error,*999)

    EXITS("OC_MeshElements_ElementOnBoundaryGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_ElementOnBoundaryGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_ElementOnBoundaryGetObj

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE OC_MeshElements_NodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,elementUserNodes,err)
    !DLLEXPORT(OC_MeshElements_NodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_NodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementNodesGet(meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("OC_MeshElements_NodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_NodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_NodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE OC_MeshElements_NodesGetObj(meshElements,userElementNumber,elementUserNodes,err)
    !DLLEXPORT(OC_MeshElements_NodesGetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_NodesGetObj",err,error,*999)

    CALL MeshElements_ElementNodesGet(meshElements%meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("OC_MeshElements_NodesGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_NodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE OC_MeshElements_NodesSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userElementNumber,elementUserNodes,err)
    !DLLEXPORT(OC_MeshElements_NodesSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_NodesSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementNodesSet(meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("OC_MeshElements_NodesSetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_NodesSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_NodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE OC_MeshElements_NodesSetObj(meshElements,userElementNumber,elementUserNodes,err)
    !DLLEXPORT(OC_MeshElements_NodesSetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_NodesSetObj",err,error,*999)

    CALL MeshElements_ElementNodesSet(meshElements%meshElements,userElementNumber,elementUserNodes,err,error,*999)

    EXITS("OC_MeshElements_NodesSetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_NodesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_NodesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE OC_MeshElements_UserNodeVersionSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,userElementNumber, &
    & versionNumber,derivativeNumber,userNodeNumber,meshComponentNumber,err)
    !DLLEXPORT(OC_MeshElements_UserNodeVersionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_UserNodeVersionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_UserNodeVersionSet(meshElements,userElementNumber,versionNumber,derivativeNumber,userNodeNumber, &
      & err,error,*999)

    EXITS("OC_MeshElements_UserNodeVersionSetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNodeVersionSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNodeVersionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE OC_MeshElements_UserNodeVersionSetObj(meshElements,userElementNumber,versionNumber,derivativeNumber, &
    & userNodeNumber,err)
    !DLLEXPORT(OC_MeshElements_UserNodeVersionSetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_UserNodeVersionSetObj",err,error,*999)

    CALL MeshElements_UserNodeVersionSet(meshElements%meshElements,userElementNumber,versionNumber, &
      & derivativeNumber,userNodeNumber,err,error,*999)

    EXITS("OC_MeshElements_UserNodeVersionSetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNodeVersionSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. 
  SUBROUTINE OC_MeshElements_LocalElementNodeVersionSetNumber(contextUserNumber,regionUserNumber,meshUserNumber, &
    & userElementNumber,versionNumber,derivativeNumber,localElementNodeNumber,meshComponentNumber,err)
    !DLLEXPORT(OC_MeshElements_LocalElementNodeVersionSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_LocalElementNodeVersionSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementNodeVersionSet(meshElements,userElementNumber,versionNumber,derivativeNumber, &
      & localElementNodeNumber,err,error,*999)

    EXITS("OC_MeshElements_LocalElementNodeVersionSetNumber")
    RETURN
999 ERRORS("OC_MeshElements_LocalElementNodeVersionSetNumber",err,error)
    EXITS("OC_MeshElements_LocalElementNodeVersionSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_LocalElementNodeVersionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. 
  SUBROUTINE OC_MeshElements_LocalElementNodeVersionSetObj(meshElements,userElementNumber,versionNumber,derivativeNumber, &
    & localElementNodeNumber,err)
    !DLLEXPORT(OC_MeshElements_LocalElementNodeVersionSetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_LocalElementNodeVersionSetObj",err,error,*999)

    CALL MeshElements_ElementNodeVersionSet(meshElements%meshElements,userElementNumber,versionNumber, &
      & derivativeNumber,localElementNodeNumber,err,error,*999)

    EXITS("OC_MeshElements_LocalElementNodeVersionSetObj")
    RETURN
999 ERRORS("OC_MeshElements_LocalElementNodeVersionSetObj",err,error)
    EXITS("OC_MeshElements_LocalElementNodeVersionSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_LocalElementNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for an element in a mesh identified by an user number.
  SUBROUTINE OC_MeshElements_UserNumberGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(OC_MeshElements_UserNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_UserNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberGet(meshElements,elementGlobalNumber,elementUserNumber,err,error,*999)

    EXITS("OC_MeshElements_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element user number for an element in a mesh identified by an object.
  SUBROUTINE OC_MeshElements_UserNumberGetObj(meshElements,elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(OC_MeshElements_UserNumberGetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_UserNumberGetObj",err,error,*999)

    CALL MeshElements_ElementUserNumberGet(meshElements%meshElements,elementGlobalNumber,elementUserNumber, &
      & err,error,*999)

    EXITS("OC_MeshElements_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for an element in a mesh identified by an user number.
  SUBROUTINE OC_MeshElements_UserNumberSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(OC_MeshElements_UserNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_UserNumberSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementUserNumberSet(meshElements,elementGlobalNumber,elementUserNumber,err,error,*999)

    EXITS("OC_MeshElements_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNumberSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user number for an element in a mesh identified by an object.
  SUBROUTINE OC_MeshElements_UserNumberSetObj(meshElements,elementGlobalNumber,elementUserNumber,err)
    !DLLEXPORT(OC_MeshElements_UserNumberSetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_UserNumberSetObj",err,error,*999)

    CALL MeshElements_ElementUserNumberSet(meshElements%meshElements,elementGlobalNumber,elementUserNumber, &
      & err,error,*999)

    EXITS("OC_MeshElements_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNumberSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for all elements in a mesh identified by an user number.
  SUBROUTINE OC_MeshElements_UserNumbersAllSetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementUserNumbers,err)
    !DLLEXPORT(OC_MeshElements_UserNumbersAllSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshElements_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshElementsGet(mesh,meshComponentNumber,meshElements,err,error,*999)
    CALL MeshElements_ElementsUserNumbersAllSet(meshElements,elementUserNumbers,err,error,*999)

    EXITS("OC_MeshElements_UserNumbersAllSetNumber")
    RETURN
999 ERRORS("OC_MeshElements_UserNumbersAllSetNumber",err,error)
    EXITS("OC_MeshElements_UserNumbersAllSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user numbers for all elements in a mesh identified by an object.
  SUBROUTINE OC_MeshElements_UserNumbersAllSetObj(meshElements,elementUserNumbers,err)
    !DLLEXPORT(OC_MeshElements_UserNumbersAllSetObj)

    !Argument variables
    TYPE(OC_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element user numbers for
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshElements_UserNumbersAllSetObj",err,error,*999)

    CALL MeshElements_ElementsUserNumbersAllSet(meshElements%meshElements,elementUserNumbers,err,error,*999)

    EXITS("OC_MeshElements_UserNumbersAllSetObj")
    RETURN
999 ERRORSEXITS("OC_MeshElements_UserNumbersAllSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshElements_UserNumbersAllSetObj

  !
  !================================================================================================================================
  !


  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE OC_Mesh_NodeExistsNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,nodeUserNumber, &
    & nodeExists,err)
    !DLLEXPORT(OC_Mesh_NodeExistsNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh tocheck the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalNodeNumber,meshNodeNumber
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_NodeExistsNumber",err,error,*999)

    nodeExists = .FALSE.

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshTopology)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(mesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshNodesGet(meshTopology,meshNodes,err,error,*999)
    CALL MeshNodes_NodeCheckExists(meshNodes,nodeUserNumber,nodeExists,globalNodeNumber,meshNodeNumber,err,error,*999)

    EXITS("OC_Mesh_NodeExistsNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_NodeExistsNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NodeExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE OC_Mesh_NodeExistsObj( mesh, meshComponentNumber, nodeUserNumber, nodeExists, err )
    !DLLEXPORT(OC_Mesh_NodeExistsObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalNodeNumber,meshNodeNumber
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(MeshTopologyType), POINTER :: meshTopology

    nodeExists = .FALSE.

    ENTERS("OC_Mesh_NodeExistsObj",err,error,*999)

    NULLIFY(meshTopology)
    NULLIFY(meshNodes)
    CALL Mesh_MeshTopologyGet(mesh%mesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshNodesGet(meshTopology,meshNodes,err,error,*999)
    CALL MeshNodes_NodeCheckExists(meshNodes,nodeUserNumber,nodeExists,globalNodeNumber,meshNodeNumber,err,error,*999)

    EXITS("OC_Mesh_NodeExistsObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_NodeExistsObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NodeExistsObj

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE OC_Mesh_ElementExistsNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementUserNumber,elementExists,err)
    !DLLEXPORT(OC_Mesh_ElementExistsNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_ElementExistsNumber",err,error,*999)

    elementExists = .FALSE.

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshTopology)
    NULLIFY(meshElements)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshTopologyGet(mesh,meshComponentNumber,meshTopology,err,error,*999)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)
    CALL MeshElements_ElementCheckExists(meshElements,elementUserNumber,elementExists,globalElementNumber,err,error,*999)

    EXITS("OC_Mesh_ElementExistsNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_ElementExistsNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_ElementExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE OC_Mesh_ElementExistsObj( mesh, meshComponentNumber, elementUserNumber, elementExists, err )
    !DLLEXPORT(OC_Mesh_ElementExistsObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    INTEGER(INTG) :: globalElementNumber
    TYPE(MeshElementsType), POINTER :: meshElements
    TYPE(MeshTopologyType), POINTER :: meshTopology

    ENTERS("OC_Mesh_ElementExistsObj",err,error,*999)

    elementExists = .FALSE.
    NULLIFY(meshTopology)
    CALL Mesh_MeshTopologyGet(mesh%mesh,meshComponentNumber,meshTopology,err,error,*999)
    NULLIFY(meshElements)
    CALL MeshTopology_MeshElementsGet(meshTopology,meshElements,err,error,*999)

    CALL MeshElements_ElementCheckExists(meshElements,elementUserNumber,elementExists,globalElementNumber,err,error,*999)

    EXITS("OC_Mesh_ElementExistsObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_ElementExistsObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_ElementExistsObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an user number.
  SUBROUTINE OC_Mesh_NodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber,meshNodes,err)
    !DLLEXPORT(OC_Mesh_NodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(OC_MeshNodesType), INTENT(INOUT) :: meshNodes !<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Mesh_NodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)

    EXITS("OC_Mesh_NodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Mesh_NodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NodesGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an object.
  SUBROUTINE OC_Mesh_NodesGetObj(mesh,meshComponentNumber,meshNodes,err)
    !DLLEXPORT(OC_Mesh_NodesGetObj)

    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(OC_MeshNodesType), INTENT(INOUT) :: meshNodes!<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Mesh_NodesGetObj",err,error,*999)

    CALL Mesh_MeshNodesGet(mesh%mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)

    EXITS("OC_Mesh_NodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Mesh_NodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user node of a mesh identified by a user number
  SUBROUTINE OC_MeshNodes_NodeOnBoundaryGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userNodeNumber,onBoundary,err)
    !DLLEXPORT(OC_MeshNodes_NodeOnBoundaryGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get the boundary type from.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user node. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshNodes_NodeOnBoundaryGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeOnBoundaryGet(meshNodes,userNodeNumber,onBoundary,err,error,*999)

    EXITS("OC_MeshNodes_NodeOnBoundaryGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NodeOnBoundaryGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NodeOnBoundaryGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the boundary type for an user node of a mesh identified by an object
  SUBROUTINE OC_MeshNodes_NodeOnBoundaryGetObj(meshNodes,userNodeNumber,onBoundary,err)
    !DLLEXPORT(OC_MeshNodes_NodeOnBoundaryGetObj)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(IN) :: meshNodes !<The mesh nodes from which to get the boundary type for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the boundary type for.
    INTEGER(INTG), INTENT(OUT) :: onBoundary !<On return, the boundary type for the specified user node. \see OpenCMISS_MeshBoundaryTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_NodeOnBoundaryGetObj",err,error,*999)

    CALL MeshNodes_NodeOnBoundaryGet(meshNodes%meshNodes,userNodeNumber,onBoundary,err,error,*999)

    EXITS("OC_MeshNodes_NodeOnBoundaryGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NodeOnBoundaryGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NodeOnBoundaryGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes at a node in a mesh identified by an user number.
  SUBROUTINE OC_MeshNodes_NumberOfNodesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & numberOfNodes,err)
    !DLLEXPORT(OC_MeshNodes_NumberOfNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshNodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NumberOfNodesGet(meshNodes,numberOfNodes,err,error,*999)

    EXITS("OC_MeshNodes_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NumberOfNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE OC_MeshNodes_NumberOfNodesGetObj(meshNodes,numberOfNodes,err)
    !DLLEXPORT(OC_MeshNodes_NumberOfNodesGetObj)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes!<On return, the number of nodes in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_NumberOfNodesGetObj",err,error,*999)

    CALL MeshNodes_NumberOfNodesGet(meshNodes%meshNodes,numberOfNodes,err,error,*999)

    EXITS("OC_MeshNodes_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NumberOfNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !
  !>Returns the number of derivatives at a node in a mesh identified by an user number.
  SUBROUTINE OC_MeshNodes_NumberOfDerivativesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userNodeNumber,numberOfDerivatives,err)
    !DLLEXPORT(OC_MeshNodes_NumberOfDerivativesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives !<On return, the number of derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshNodes_NumberOfDerivativesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeNumberOfDerivativesGet(meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("OC_MeshNodes_NumberOfDerivativesGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NumberOfDerivativesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NumberOfDerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE OC_MeshNodes_NumberOfDerivativesGetObj(meshNodes,userNodeNumber,numberOfDerivatives,err)
    !DLLEXPORT(OC_MeshNodes_NumberOfDerivativesGetObj)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives!<On return, the number of derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_NumberOfDerivativesGetObj",err,error,*999)

    CALL MeshNodes_NodeNumberOfDerivativesGet(meshNodes%meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("OC_MeshNodes_NumberOfDerivativesGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NumberOfDerivativesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NumberOfDerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the derivatives at a node in a mesh identified by an user number.
  SUBROUTINE OC_MeshNodes_DerivativesGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & userNodeNumber,derivatives,err)
    !DLLEXPORT(OC_MeshNodes_DerivativesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshNodes_DerivativesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeDerivativesGet(meshNodes,userNodeNumber,derivatives,err,error,*999)

    EXITS("OC_MeshNodes_DerivativesGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_DerivativesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_DerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the derivatives for a node in a mesh identified by an object.
  SUBROUTINE OC_MeshNodes_DerivativesGetObj(meshNodes,userNodeNumber,derivatives,err)
    !DLLEXPORT(OC_MeshNodes_DerivativesGetObj)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_DerivativesGetObj",err,error,*999)

    CALL MeshNodes_NodeDerivativesGet(meshNodes%meshNodes,userNodeNumber,derivatives,err,error,*999)

    EXITS("OC_MeshNodes_DerivativesGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_DerivativesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_DerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of version at a derivative for a node in a mesh identified by an user number.
  SUBROUTINE OC_MeshNodes_NumberOfVersionsGetNumber(contextUserNumber,regionUserNumber,meshUserNumber,meshComponentNumber, &
    & derivativeNumber,userNodeNumber,numberOfVersions,err)
    !DLLEXPORT(OC_MeshNodes_NumberOfVersionsGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of versions.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of versions in the mesh for the derivative index of the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_MeshNodes_NumberOfVersionsGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_MeshGet(region,meshUserNumber,mesh,err,error,*999)
    CALL Mesh_MeshNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
    CALL MeshNodes_NodeNumberOfVersionsGet(meshnodes,derivativeNumber,userNodeNumber,numberOfVersions,err,error,*999)

    EXITS("OC_MeshNodes_NumberOfVersionsGetNumber")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NumberOfVersionsGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NumberOfVersionsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of versions for an node in a mesh identified by an object.
  SUBROUTINE OC_MeshNodes_NumberOfVersionsGetObj(meshNodes,derivativeNumber,userNodeNumber,numberOfVersions,err)
    !DLLEXPORT(OC_MeshNodes_NumberOfVersionsGetObj)

    !Argument variables
    TYPE(OC_MeshNodesType), INTENT(IN) :: meshNodes !<The mesh nodes to get the number of versions at a node for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of a node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of derivatives at the specified node and derivative in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_MeshNodes_NumberOfVersionsGetObj",err,error,*999)

    CALL MeshNodes_NodeNumberOfVersionsGet(meshNodes%meshNodes,derivativeNumber,userNodeNumber, &
      & numberOfVersions,err,error,*999)

    EXITS("OC_MeshNodes_NumberOfVersionsGetObj")
    RETURN
999 ERRORSEXITS("OC_MeshNodes_NumberOfVersionsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_MeshNodes_NumberOfVersionsGetObj

!!==================================================================================================================================
!!
!! DISTRIBUTED_MATRIX_VECTOR
!!
!!==================================================================================================================================

  !>Get the storage type for a distributed matrix
  SUBROUTINE OC_DistributedMatrix_StorageTypeGetObj(matrix,storageType,err)
    !DLLEXPORT(OC_DistributedMatrix_StorageTypeGetObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage type for
    INTEGER(INTG), INTENT(OUT) :: storageType !<On return, the matrix storage type. \see OpenCMISS_MatrixStorageTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_StorageTypeGetObj",err,error,*999)

    CALL DistributedMatrix_StorageTypeGet(matrix%distributedMatrix,storageType,err,error,*999)

    EXITS("OC_DistributedMatrix_StorageTypeGetObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_StorageTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_StorageTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed matrix
  SUBROUTINE OC_DistributedMatrix_DataTypeGetObj(matrix,dataType,err)
    !DLLEXPORT(OC_DistributedMatrix_DataTypeGetObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the matrix data type. \see OpenCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataTypeGetObj",err,error,*999)

    CALL DistributedMatrix_DataTypeGet(matrix%distributedMatrix,dataType,err,error,*999)

    EXITS("OC_DistributedMatrix_DataTypeGetObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the dimensions of a distributed matrix on this computation node
  SUBROUTINE OC_DistributedMatrix_DimensionsGetObj(matrix,m,n,err)
    !DLLEXPORT(OC_DistributedMatrix_DimensionsGetObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: m !<On return, the number of rows for this computation node
    INTEGER(INTG), INTENT(OUT) :: n !<On return, the number of columns
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DimensionsGetObj",err,error,*999)

    CALL DistributedMatrix_DimensionsGet(matrix%distributedMatrix,m,n,err,error,*999)

    EXITS("OC_DistributedMatrix_DimensionsGetObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DimensionsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DimensionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the row indices and column indices for a sparse matrix
  SUBROUTINE OC_DistributedMatrix_StorageLocationsGetObj(matrix,rowIndices,columnIndices,err)
    !DLLEXPORT(OC_DistributedMatrix_StorageLocationsGetObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage locations for
    INTEGER(INTG), POINTER, INTENT(OUT) :: rowIndices(:) !<On return, the matrix storage row indices
    INTEGER(INTG), POINTER, INTENT(OUT) :: columnIndices(:) !<On return, the matrix storage column indices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_StorageLocationsGetObj",err,error,*999)

    CALL DistributedMatrix_StorageLocationsGet(matrix%distributedMatrix,rowIndices,columnIndices,err,error,*999)

    EXITS("OC_DistributedMatrix_StorageLocationsGetObj")

    RETURN
999 ERRORS("OC_DistributedMatrix_StorageLocationsGetObj",err,error)
    EXITS("OC_DistributedMatrix_StorageLocationsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_StorageLocationsGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE OC_DistributedMatrix_DataGetIntgObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataGetIntgObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataGetIntgObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataGetIntgObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataGetIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE OC_DistributedMatrix_DataRestoreIntgObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataRestoreIntgObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataRestoreIntgObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataRestoreIntgObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataRestoreIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE OC_DistributedMatrix_DataGetDPObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataGetDPObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataGetDPObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataGetDPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataGetDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE OC_DistributedMatrix_DataRestoreDPObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataRestoreDPObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataRestoreDPObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataRestoreDPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataRestoreDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE OC_DistributedMatrix_DataGetSPObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataGetSPObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataGetSPObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataGetSPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataGetSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE OC_DistributedMatrix_DataRestoreSPObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataRestoreSPObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataRestoreSPObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataRestoreSPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataRestoreSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computation node
  SUBROUTINE OC_DistributedMatrix_DataGetLObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataGetLObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataGetLObj",err,error,*999)

    CALL DistributedMatrix_DataGet(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataGetLObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataGetLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE OC_DistributedMatrix_DataRestoreLObj(matrix,data,err)
    !DLLEXPORT(OC_DistributedMatrix_DataRestoreLObj)

    !Argument variables
    TYPE(OC_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedMatrix_DataRestoreLObj",err,error,*999)

    CALL DistributedMatrix_DataRestore(matrix%distributedMatrix,data,err,error,*999)

    EXITS("OC_DistributedMatrix_DataRestoreLObj")

    RETURN
999 ERRORSEXITS("OC_DistributedMatrix_DataRestoreLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedMatrix_DataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed vector
  SUBROUTINE OC_DistributedVector_DataTypeGetObj(vector,dataType,err)
    !DLLEXPORT(OC_DistributedVector_DataTypeGetObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the vector data type. \see OpenCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataTypeGetObj",err,error,*999)

    CALL DistributedVector_DataTypeGet(vector%distributedVector,dataType,err,error,*999)

    EXITS("OC_DistributedVector_DataTypeGetObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE OC_DistributedVector_DataGetIntgObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataGetIntgObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataGetIntgObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataGetIntgObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataGetIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE OC_DistributedVector_DataRestoreIntgObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataRestoreIntgObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataRestoreIntgObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataRestoreIntgObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataRestoreIntgObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE OC_DistributedVector_DataGetDPObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataGetDPObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataGetDPObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataGetDPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataGetDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE OC_DistributedVector_DataRestoreDPObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataRestoreDPObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataRestoreDPObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataRestoreDPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataRestoreDPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE OC_DistributedVector_DataGetSPObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataGetSPObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataGetSPObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataGetSPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataGetSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE OC_DistributedVector_DataRestoreSPObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataRestoreSPObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataRestoreSPObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataRestoreSPObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataRestoreSPObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computation node
  SUBROUTINE OC_DistributedVector_DataGetLObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataGetLObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataGetLObj",err,error,*999)

    CALL DistributedVector_DataGet(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataGetLObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataGetLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE OC_DistributedVector_DataRestoreLObj(vector,data,err)
    !DLLEXPORT(OC_DistributedVector_DataRestoreLObj)

    !Argument variables
    TYPE(OC_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_DistributedVector_DataRestoreLObj",err,error,*999)

    CALL DistributedVector_DataRestore(vector%distributedVector,data,err,error,*999)

    EXITS("OC_DistributedVector_DataRestoreLObj")

    RETURN
999 ERRORSEXITS("OC_DistributedVector_DataRestoreLObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_DistributedVector_DataRestoreLObj

!!==================================================================================================================================
!!
!! NodeRoutines
!!
!!==================================================================================================================================

  !>Finishes the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE OC_Nodes_CreateFinishNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_Nodes_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_CreateFinish(nodes,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    EXITS("OC_Nodes_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE OC_Nodes_CreateFinishObj(nodes,err)
    !DLLEXPORT(OC_Nodes_CreateFinishObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_CreateFinishObj",err,error,*999)

    CALL Nodes_CreateFinish(nodes%nodes,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('nodes Create')
#endif

    EXITS("OC_Nodes_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE OC_Nodes_CreateStartNumber(contextUserNumber,regionUserNumber,numberOfNodes,err)
    !DLLEXPORT(OC_Nodes_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Nodes_CreateStart(region,numberOfNodes,nodes,err,error,*999)

    EXITS("OC_Nodes_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE OC_Nodes_CreateStartObj(region,numberOfNodes,nodes,err)
    !DLLEXPORT(OC_Nodes_CreateStartObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL Nodes_CreateStart(region%region,numberOfNodes,nodes%nodes,err,error,*999)

    EXITS("OC_Nodes_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE OC_Nodes_CreateStartInterfaceObj(interface,numberOfNodes,nodes,err)
    !DLLEXPORT(OC_Nodes_CreateStartInterfaceObj)

    !Argument variables
    TYPE(OC_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL Nodes_CreateStart(interface%interface,numberOfNodes,nodes%nodes,err,error,*999)

    EXITS("OC_Nodes_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_CreateStartInterfaceObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by user number.
  SUBROUTINE OC_Nodes_DestroyNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_Nodes_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_Destroy(nodes,err,error,*999)

    EXITS("OC_Nodes_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by an object.
  SUBROUTINE OC_Nodes_DestroyObj(nodes,err)
    !DLLEXPORT(OC_Nodes_DestroyObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_DestroyObj",err,error,*999)

    CALL Nodes_Destroy(nodes%nodes,err,error,*999)

    EXITS("OC_Nodes_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE OC_Nodes_NumberOfNodesGetNumber(contextUserNumber,regionUserNumber,numberOfNodes,err)
    !DLLEXPORT(OC_Nodes_NumberOfNodesGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_NumberOfNodesGet(nodes,numberOfNodes,err,error,*999)

    EXITS("OC_Nodes_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_NumberOfNodesGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE OC_Nodes_NumberOfNodesGetObj(nodes,numberOfNodes,err)
    !DLLEXPORT(OC_Nodes_NumberOfNodesGetObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<The number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_NumberOfNodesGetObj",err,error,*999)

    CALL Nodes_NumberOfNodesGet(nodes%nodes,numberOfNodes,err,error,*999)

    EXITS("OC_Nodes_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_NumberOfNodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelGetCNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelGet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelGetCObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelGetCObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_LabelGetCObj",err,error,*999)

    CALL Nodes_LabelGet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelGetVSNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelGet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelGetVSObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelGetVSObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_LabelGetVSObj",err,error,*999)

    CALL Nodes_LabelGet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelSetCNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelSet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelSetCObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelSetCObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_LabelSetCObj",err,error,*999)

    CALL Nodes_LabelSet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelSetVSNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_LabelSet(nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE OC_Nodes_LabelSetVSObj(nodes,nodeGlobalNumber,label,err)
    !DLLEXPORT(OC_Nodes_LabelSetVSObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_LabelSetVSObj",err,error,*999)

    CALL Nodes_LabelSet(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("OC_Nodes_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by user number.
  SUBROUTINE OC_Nodes_UserNumberGetNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(OC_Nodes_UserNumberGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_UserNumberGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_UserNumberGet(nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Nodes_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_UserNumberGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE OC_Nodes_UserNumberGetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(OC_Nodes_UserNumberGetObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_UserNumberGetObj",err,error,*999)

    CALL Nodes_UserNumberGet(nodes%nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Nodes_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_UserNumberGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by user number.
  SUBROUTINE OC_Nodes_UserNumberSetNumber(contextUserNumber,regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(OC_Nodes_UserNumberSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_UserNumberSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_UserNumberSet(nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Nodes_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_UserNumberSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE OC_Nodes_UserNumberSetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)
    !DLLEXPORT(OC_Nodes_UserNumberSetObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_UserNumberSetObj",err,error,*999)

    CALL Nodes_UserNumberSet(nodes%nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("OC_Nodes_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_UserNumberSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by user number.
  SUBROUTINE OC_Nodes_UserNumbersAllSetNumber(contextUserNumber,regionUserNumber,nodeUserNumbers,err)
    !DLLEXPORT(OC_Nodes_UserNumbersAllSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user numbers for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(NodesType), POINTER :: nodes
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Nodes_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(nodes)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_NodesGet(region,nodes,err,error,*999)
    CALL Nodes_UserNumbersAllSet(nodes,nodeUserNumbers,err,error,*999)

    EXITS("OC_Nodes_UserNumbersAllSetNumber")
    RETURN
999 ERRORSEXITS("OC_Nodes_UserNumbersAllSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by an object.
  SUBROUTINE OC_Nodes_UserNumbersAllSetObj(nodes,nodeUserNumbers,err)
    !DLLEXPORT(OC_Nodes_UserNumbersAllSetObj)

    !Argument variables
    TYPE(OC_NodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Nodes_UserNumbersAllSetObj",err,error,*999)

    CALL Nodes_UserNumbersAllSet(nodes%nodes,nodeUserNumbers,err,error,*999)

    EXITS("OC_Nodes_UserNumbersAllSetObj")
    RETURN
999 ERRORSEXITS("OC_Nodes_UserNumbersAllSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Nodes_UserNumbersAllSetObj

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE OC_Problem_CellMLEquationsCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CellMLEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    EXITS("OC_Problem_CellMLEquationsCreateFinishNumber")
    RETURN
999 ERRORS("OC_Problem_CellMLEquationsCreateFinishNumber",err,error)
    EXITS("OC_Problem_CellMLEquationsCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML equations for problem identified by an object.
  SUBROUTINE OC_Problem_CellMLEquationsCreateFinishObj(problem,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsCreateFinishObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_CellMLEquationsCreateFinishObj",err,error,*999)

    CALL Problem_CellMLEquationsCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    EXITS("OC_Problem_CellMLEquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Problem_CellMLEquationsCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE OC_Problem_CellMLEquationsCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CellMLEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsCreateStart(problem,err,error,*999)

    EXITS("OC_Problem_CellMLEquationsCreateStartNumber")
    RETURN
999 ERRORS("OC_Problem_CellMLEquationsCreateStartNumber",err,error)
    EXITS("OC_Problem_CellMLEquationsCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML equations for problem identified by an object.
  SUBROUTINE OC_Problem_CellMLEquationsCreateStartObj(problem,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsCreateStartObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to start creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_CellMLEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    CALL Problem_CellMLEquationsCreateStart(problem%problem,err,error,*999)

    EXITS("OC_Problem_CellMLEquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Problem_CellMLEquationsCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE OC_Problem_CellMLEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsGet(problem,controlLoopIdentifier,solverIndex,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("OC_Problem_CellMLEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Problem_CellMLEquationsGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE OC_Problem_CellMLEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CellMLEquationsGet(problem,controlLoopIdentifiers,solverIndex,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("OC_Problem_CellMLEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Problem_CellMLEquationsGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE OC_Problem_CellMLEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,cellMLEquations,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsGetObj0)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_CellMLEquationsGetObj0",err,error,*999)

    CALL Problem_CellMLEquationsGet(problem%problem,controlLoopIdentifier,solverIndex,cellMLEquations%cellmlEquations, &
      & err,error,*999)

    EXITS("OC_Problem_CellMLEquationsGetObj0")
    RETURN
999 ERRORSEXITS("OC_Problem_CellMLEquationsGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE OC_Problem_CellMLEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,cellMLEquations,err)
    !DLLEXPORT(OC_Problem_CellMLEquationsGetObj1)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_CellMLEquationsGetObj1",err,error,*999)

    CALL Problem_CellMLEquationsGet(problem%problem,controlLoopIdentifiers,solverIndex,cellMLEquations%cellmlEquations, &
      & err,error,*999)

    EXITS("OC_Problem_CellMLEquationsGetObj1")
    RETURN
999 ERRORSEXITS("OC_Problem_CellMLEquationsGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CellMLEquationsGetObj1

  !
  !================================================================================================================================
  !

  !>Finishes the process of a problem identified by user number.
  SUBROUTINE OC_Problem_CreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_CreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    EXITS("OC_Problem_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a problem identified by an object.
  SUBROUTINE OC_Problem_CreateFinishObj(problem,err)
    !DLLEXPORT(OC_Problem_CreateFinishObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_CreateFinishObj",err,error,*999)

    CALL Problem_CreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Create')
#endif

    EXITS("OC_Problem_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Problem_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of a problem identified by user number.
  SUBROUTINE OC_Problem_CreateStartNumber(problemUserNumber,contextUserNumber,problemSpecification,err)
    !DLLEXPORT(OC_Problem_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification array, containt the problem class, type etc
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_CreateStart(problemUserNumber,problems,problemSpecification,problem,err,error,*999)

    EXITS("OC_Problem_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a problem identified by an object.
  SUBROUTINE OC_Problem_CreateStartObj(problemUserNumber,context,problemSpecification,problem,err)
    !DLLEXPORT(OC_Problem_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context in which to create the problem. 
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification array, containt the problem class, type etc
    TYPE(OC_ProblemType), INTENT(INOUT) :: problem !<On return, the created problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Create')
#endif

    NULLIFY(problems)
    CALL Context_ProblemsGet(context%context,problems,err,error,*999)
    CALL Problem_CreateStart(problemUserNumber,problems,problemSpecification,problem%problem,err,error,*999)

    EXITS("OC_Problem_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Problem_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a control loop for a problem identified by user number.
  SUBROUTINE OC_Problem_ControlLoopCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_ControlLoopCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_ControlLoopCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    EXITS("OC_Problem_ControlLoopCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a control loop on a problem identified by an object.
  SUBROUTINE OC_Problem_ControlLoopCreateFinishObj(problem,err)
    !DLLEXPORT(OC_Problem_ControlLoopCreateFinishObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_ControlLoopCreateFinishObj",err,error,*999)

    CALL Problem_ControlLoopCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Control Loop Create')
#endif

    EXITS("OC_Problem_ControlLoopCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating a control loop for a problem identified by user number.
  SUBROUTINE OC_Problem_ControlLoopCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_ControlLoopCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_ControlLoopCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopCreateStart(problem,err,error,*999)

    EXITS("OC_Problem_ControlLoopCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a control loop on a problem identified by an object.
  SUBROUTINE OC_Problem_ControlLoopCreateStartObj(problem,err)
    !DLLEXPORT(OC_Problem_ControlLoopCreateStartObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_ControlLoopCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Control Loop Create')
#endif

    CALL Problem_ControlLoopCreateStart(problem%problem,err,error,*999)

    EXITS("OC_Problem_ControlLoopCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the control loops for a problem identified by user number.
  SUBROUTINE OC_Problem_ControlLoopDestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_ControlLoopDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_ControlLoopDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopDestroy(problem,err,error,*999)

    EXITS("OC_Problem_ControlLoopDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the control loops on a problem identified by an object.
  SUBROUTINE OC_Problem_ControlLoopDestroyObj(problem,err)
    !DLLEXPORT(OC_Problem_ControlLoopDestroyObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_ControlLoopDestroyObj",err,error,*999)

    CALL Problem_ControlLoopDestroy(problem%problem,err,error,*999)

    EXITS("OC_Problem_ControlLoopDestroyObj")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE OC_Problem_ControlLoopGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(OC_Problem_ControlLoopGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_ControlLoopGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_Problem_ControlLoopGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE OC_Problem_ControlLoopGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(OC_Problem_ControlLoopGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_ControlLoopGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_ControlLoopGet(problem,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_Problem_ControlLoopGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE OC_Problem_ControlLoopGetObj0(problem,controlLoopIdentifier,controlLoop,err)
    !DLLEXPORT(OC_Problem_ControlLoopGetObj0)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_ControlLoopGetObj0",err,error,*999)

    CALL Problem_ControlLoopGet(problem%problem,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_Problem_ControlLoopGetObj0")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE OC_Problem_ControlLoopGetObj1(problem,controlLoopIdentifiers,controlLoop,err)
    !DLLEXPORT(OC_Problem_ControlLoopGetObj1)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_ControlLoopGetObj1",err,error,*999)

    CALL Problem_ControlLoopGet(problem%problem,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("OC_Problem_ControlLoopGetObj1")
    RETURN
999 ERRORSEXITS("OC_Problem_ControlLoopGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an user number.
  SUBROUTINE OC_Problem_DestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_Destroy(problem,err,error,*999)

    EXITS("OC_Problem_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an object.
  SUBROUTINE OC_Problem_DestroyObj(problem,err)
    !DLLEXPORT(OC_Problem_DestroyObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_DestroyObj",err,error,*999)

    CALL Problem_Destroy(problem%problem,err,error,*999)

    EXITS("OC_Problem_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Problem_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an user number.
  SUBROUTINE OC_Problem_SolveNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolveNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolveNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_Solve(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    EXITS("OC_Problem_SolveNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_SolveNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolveNumber

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an object.
  SUBROUTINE OC_Problem_SolveObj(problem,err)
    !DLLEXPORT(OC_Problem_SolveObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolveObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solve')
#endif

    CALL Problem_Solve(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solve')
#endif

    EXITS("OC_Problem_SolveObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolveObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolveObj

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE OC_Problem_SolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,solver,err)
    !DLLEXPORT(OC_Problem_SolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver%solver,err,error,*999)

    EXITS("OC_Problem_SolverGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE OC_Problem_SolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,solver,err)
    !DLLEXPORT(OC_Problem_SolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver%solver,err,error,*999)

    EXITS("OC_Problem_SolverGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE OC_Problem_SolverGetObj0(problem,controlLoopIdentifier,solverIndex,solver,err)
    !DLLEXPORT(OC_Problem_SolverGetObj0)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverGetObj0",err,error,*999)

    CALL Problem_SolverGet(problem%problem,controlLoopIdentifier,solverIndex,solver%solver,err,error,*999)

    EXITS("OC_Problem_SolverGetObj0")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE OC_Problem_SolverGetObj1(problem,controlLoopIdentifiers,solverIndex,solver,err)
    !DLLEXPORT(OC_Problem_SolverGetObj1)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverGetObj1",err,error,*999)

    CALL Problem_SolverGet(problem%problem,controlLoopIdentifiers,solverIndex,solver%solver,err,error,*999)

    EXITS("OC_Problem_SolverGetObj1")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverGetObj1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE OC_SolverEquations_BoundaryConditionsAnalyticNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsAnalyticNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_BoundaryConditionsAnalyticNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsAnalyticNumber0")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsAnalyticNumber0",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsAnalyticNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsAnalyticNumber0

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE OC_SolverEquations_BoundaryConditionsAnalyticNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsAnalyticNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions

    ENTERS("OC_SolverEquations_BoundaryConditionsAnalyticNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsAnalyticNumber1")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsAnalyticNumber1",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsAnalyticNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsAnalyticNumber1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations.
  SUBROUTINE OC_SolverEquations_BoundaryConditionsAnalyticObj(solverEquations,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsAnalyticObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_SolverEquations_BoundaryConditionsAnalyticObj",err,error,*999)

    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations%solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsAnalyticObj")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsAnalyticObj",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsAnalyticObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsAnalyticObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solver equations for a problem identified by user number.
  SUBROUTINE OC_Problem_SolverEquationsCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolverEquationsCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    EXITS("OC_Problem_SolverEquationsCreateFinishNumber")
    RETURN
999 ERRORS("OC_Problem_SolverEquationsCreateFinishNumber",err,error)
    EXITS("OC_Problem_SolverEquationsCreateFinishNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solver equations for problem identified by an object.
  SUBROUTINE OC_Problem_SolverEquationsCreateFinishObj(problem,err)
    !DLLEXPORT(OC_Problem_SolverEquationsCreateFinishObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverEquationsCreateFinishObj",err,error,*999)

    CALL Problem_SolverEquationsCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    EXITS("OC_Problem_SolverEquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solver equations for a problem identified by user number.
  SUBROUTINE OC_Problem_SolverEquationsCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolverEquationsCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsCreateStart(problem,err,error,*999)

    EXITS("OC_Problem_SolverEquationsCreateStartNumber")
    RETURN
999 ERRORS("OC_Problem_SolverEquationsCreateStartNumber",err,error)
    EXITS("OC_Problem_SolverEquationsCreateStartNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solver equations for problem identified by an object.
  SUBROUTINE OC_Problem_SolverEquationsCreateStartObj(problem,err)
    !DLLEXPORT(OC_Problem_SolverEquationsCreateStartObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to start creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    CALL Problem_SolverEquationsCreateStart(problem%problem,err,error,*999)

    EXITS("OC_Problem_SolverEquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for a problem identified by an user number.
  SUBROUTINE OC_Problem_SolverEquationsDestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolverEquationsDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverEquationsDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsDestroy(problem,err,error,*999)

    EXITS("OC_Problem_SolverEquationsDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for problem identified by an object.
  SUBROUTINE OC_Problem_SolverEquationsDestroyObj(problem,err)
    !DLLEXPORT(OC_Problem_SolverEquationsDestroyObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to destroy the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverEquationsDestroyObj",err,error,*999)

    CALL Problem_SolverEquationsDestroy(problem%problem,err,error,*999)

    EXITS("OC_Problem_SolverEquationsDestroyObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE OC_Problem_SolverEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(OC_Problem_SolverEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations%solverEquations,err,error,*999)

    EXITS("OC_Problem_SolverEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE OC_Problem_SolverEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(OC_Problem_SolverEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations%solverEquations,err,error,*999)

    EXITS("OC_Problem_SolverEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE OC_Problem_SolverEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,solverEquations,err)
    !DLLEXPORT(OC_Problem_SolverEquationsGetObj0)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverEquationsGetObj0",err,error,*999)

    CALL Problem_SolverEquationsGet(problem%problem,controlLoopIdentifier,solverIndex,solverEquations%solverEquations, &
      & err,error,*999)

    EXITS("OC_Problem_SolverEquationsGetObj0")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsGetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE OC_Problem_SolverEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,solverEquations,err)
    !DLLEXPORT(OC_Problem_SolverEquationsGetObj1)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolverEquationsGetObj1",err,error,*999)

    CALL Problem_SolverEquationsGet(problem%problem,controlLoopIdentifiers,solverIndex,solverEquations%solverEquations, &
      & err,error,*999)

    EXITS("OC_Problem_SolverEquationsGetObj1")
    RETURN
999 ERRORSEXITS("OC_Problem_SolverEquationsGetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolverEquationsGetObj1

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solvers for a problem identified by user number.
  SUBROUTINE OC_Problem_SolversCreateFinishNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolversCreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolversCreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolversCreateFinish(problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    EXITS("OC_Problem_SolversCreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_SolversCreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolversCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solvers for problem identified by an object.
  SUBROUTINE OC_Problem_SolversCreateFinishObj(problem,err)
    !DLLEXPORT(OC_Problem_SolversCreateFinishObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolversCreateFinishObj",err,error,*999)

    CALL Problem_SolversCreateFinish(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solvers Create')
#endif

    EXITS("OC_Problem_SolversCreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolversCreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolversCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solvers for a problem identified by user number.
  SUBROUTINE OC_Problem_SolversCreateStartNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolversCreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolversCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolversCreateStart(problem,err,error,*999)

    EXITS("OC_Problem_SolversCreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_SolversCreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolversCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solvers for problem identified by an object.
  SUBROUTINE OC_Problem_SolversCreateStartObj(problem,err)
    !DLLEXPORT(OC_Problem_SolversCreateStartObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to start creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolversCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solvers Create')
#endif

    CALL Problem_SolversCreateStart(problem%problem,err,error,*999)

    EXITS("OC_Problem_SolversCreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolversCreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolversCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for a problem identified by an user number.
  SUBROUTINE OC_Problem_SolversDestroyNumber(contextUserNumber,problemUserNumber,err)
    !DLLEXPORT(OC_Problem_SolversDestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SolversDestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolversDestroy(problem,err,error,*999)

    EXITS("OC_Problem_SolversDestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_SolversDestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolversDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for problem identified by an object.
  SUBROUTINE OC_Problem_SolversDestroyObj(problem,err)
    !DLLEXPORT(OC_Problem_SolversDestroyObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SolversDestroyObj",err,error,*999)

    CALL Problem_SolversDestroy(problem%problem,err,error,*999)

    EXITS("OC_Problem_SolversDestroyObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SolversDestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SolversDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specification array for a problem identified by a user number.
  SUBROUTINE OC_Problem_SpecificationGetNumber(contextUserNumber,problemUserNumber,problemSpecification,err)
    !DLLEXPORT(OC_Problem_SpecificationGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: problemSpecification(:) !<On return, the problem specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SpecificationGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SpecificationGet(problem,SIZE(problemSpecification,1),problemSpecification,err,error,*999)

    EXITS("OC_Problem_SpecificationGetNumber")
    RETURN
999 ERRORS("OC_Problem_SpecificationGetNumber",err,error)
    EXITS("OC_Problem_SpecificationGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the specification array for a problem identified by an object.
  SUBROUTINE OC_Problem_SpecificationGetObj(problem,problemSpecification,err)
    !DLLEXPORT(OC_Problem_SpecificationGetObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: problemSpecification(:) !<On return, the problem specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SpecificationGetObj",err,error,*999)

    CALL Problem_SpecificationGet(problem%problem,SIZE(problemSpecification,1),problemSpecification,err,error,*999)

    EXITS("OC_Problem_SpecificationGetObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SpecificationGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Returns the size of the specification array for a problem identified by a user number.
  SUBROUTINE OC_Problem_SpecificationSizeGetNumber(contextUserNumber,problemUserNumber,specificationSize,err)
    !DLLEXPORT(OC_Problem_SpecificationSizeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the size of the specification for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the problem specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems

    ENTERS("OC_Problem_SpecificationSizeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SpecificationSizeGet(problem,specificationSize,err,error,*999)

    EXITS("OC_Problem_SpecificationSizeGetNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_SpecificationSizeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SpecificationSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the specification array for a problem identified by an object.
  SUBROUTINE OC_Problem_SpecificationSizeGetObj(problem,specificationSize,err)
    !DLLEXPORT(OC_Problem_SpecificationSizeGetObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(IN) :: problem !<The problem to get the size of the specification for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the problem specification array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_SpecificationSizeGetObj",err,error,*999)

    CALL Problem_SpecificationSizeGet(problem%problem,specificationSize,err,error,*999)

    EXITS("OC_Problem_SpecificationSizeGetObj")
    RETURN
999 ERRORSEXITS("OC_Problem_SpecificationSizeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_SpecificationSizeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group of a problem identified by a user number.
  SUBROUTINE OC_Problem_WorkGroupSetNumber(contextUserNumber,problemUserNumber,workGroupUserNumber,err)
    !DLLEXPORT(OC_Problem_WorkGroupSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the work group for.
    INTEGER(INTG), INTENT(IN) :: workGroupUserNumber !<The user number of the work group to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ComputationEnvironmentType), POINTER :: computationEnvironment
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(WorkGroupType), POINTER :: workGroup

    ENTERS("OC_Problem_WorkGroupSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(computationEnvironment)
    NULLIFY(problem)
    NULLIFY(workGroup)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_ComputationEnvironmentGet(context,computationEnvironment,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL WorkGroup_Get(computationEnvironment,workGroupUserNumber,workGroup,err,error,*999)
    CALL Problem_WorkGroupSet(problem,workGroup,err,error,*999)

    EXITS("OC_Problem_WorkGroupSetNumber")
    RETURN
999 ERRORSEXITS("OC_Problem_WorkGroupSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_WorkGroupSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the work group for a problem identified by an object.
  SUBROUTINE OC_Problem_WorkGroupSetObj(problem,workGroup,err)
    !DLLEXPORT(OC_Problem_WorkGroupSetObj)

    !Argument variables
    TYPE(OC_ProblemType), INTENT(INOUT) :: problem !<The problem to set the work group for.
    TYPE(OC_WorkGroupType), INTENT(IN) :: workGroup !<The work group to set for the problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Problem_WorkGroupSetObj",err,error,*999)

    CALL Problem_WorkGroupSet(problem%problem,workGroup%workGroup,err,error,*999)

    EXITS("OC_Problem_WorkGroupSetObj")
    RETURN
999 ERRORSEXITS("OC_Problem_WorkGroupSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Problem_WorkGroupSetObj


!!==================================================================================================================================
!!
!! RegionRoutines
!!
!!==================================================================================================================================

  !>Returns the coordinate system for a region identified by an user number.
  SUBROUTINE OC_Region_CoordinateSystemGetNumber(contextUserNumber,regionUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(OC_Region_CoordinateSystemGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_CoordinateSystemGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(region)
    NULLIFY(regions)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CoordinateSystemGet(region,coordinateSystem,err,error,*999)
    coordinateSystemUserNumber = coordinateSystem%userNumber

    EXITS("OC_Region_CoordinateSystemGetNumber")
    RETURN
999 ERRORSEXITS("OC_Region_CoordinateSystemGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for a region identified by an object.
  SUBROUTINE OC_Region_CoordinateSystemGetObj(region,coordinateSystem,err)
    !DLLEXPORT(OC_Region_CoordinateSystemGetObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the coordinate system for.
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the regions coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_CoordinateSystemGetObj",err,error,*999)

    CALL Region_CoordinateSystemGet(region%region,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("OC_Region_CoordinateSystemGetObj")
    RETURN
999 ERRORSEXITS("OC_Region_CoordinateSystemGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an user number.
  SUBROUTINE OC_Region_CoordinateSystemSetNumber(contextUserNumber,regionUserNumber,coordinateSystemUserNumber,err)
    !DLLEXPORT(OC_Region_CoordinateSystemSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_CoordinateSystemSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(coordinateSystems)
    NULLIFY(region)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL CoordinateSystem_Get(coordinateSystems,coordinateSystemUserNumber,coordinateSystem,err,error,*999)
    CALL Region_CoordinateSystemSet(region,coordinateSystem,err,error,*999)

    EXITS("OC_Region_CoordinateSystemSetNumber")
    RETURN
999 ERRORSEXITS("OC_Region_CoordinateSystemSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an object.
  SUBROUTINE OC_Region_CoordinateSystemSetObj(region,coordinateSystem,err)
    !DLLEXPORT(OC_Region_CoordinateSystemSetObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to set the coordinate system for.
    TYPE(OC_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_CoordinateSystemSetObj",err,error,*999)

    CALL Region_CoordinateSystemSet(region%region,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("OC_Region_CoordinateSystemSetObj")
    RETURN
999 ERRORSEXITS("OC_Region_CoordinateSystemSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a region identified by user number.
  SUBROUTINE OC_Region_CreateFinishNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_Region_CreateFinishNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_CreateFinishNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CreateFinish(region,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    EXITS("OC_Region_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("OC_Region_CreateFinishNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a region identified by an object.
  SUBROUTINE OC_Region_CreateFinishObj(region,err)
    !DLLEXPORT(OC_Region_CreateFinishObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_CreateFinishObj",err,error,*999)

    CALL Region_CreateFinish(region%region,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('region Create')
#endif

    EXITS("OC_Region_CreateFinishObj")
    RETURN
999 ERRORSEXITS("OC_Region_CreateFinishObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process creating a region identified by user number.
  SUBROUTINE OC_Region_CreateStartNumber(regionUserNumber,contextUserNumber,parentRegionUserNumber,err)
    !DLLEXPORT(OC_Region_CreateStartNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region to start the creation of the region in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: parentRegion,region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(parentRegion)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,parentRegionUserNumber,parentRegion,err,error,*999)
    CALL Region_CreateStart(regionUserNumber,parentRegion,region,err,error,*999)

    EXITS("OC_Region_CreateStartNumber")
    RETURN
999 ERRORSEXITS("OC_Region_CreateStartNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a region identified by an object.
  SUBROUTINE OC_Region_CreateStartObj(regionUserNumber,parentRegion,region,err)
    !DLLEXPORT(OC_Region_CreateStartObj)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    TYPE(OC_RegionType), INTENT(IN) :: parentRegion !<The parent region to  to start the creation of the region in.
    TYPE(OC_RegionType), INTENT(INOUT) :: region !<On return, the created region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('region Create')
#endif

    CALL Region_CreateStart(regionUserNumber,parentRegion%region,region%region,err,error,*999)

    EXITS("OC_Region_CreateStartObj")
    RETURN
999 ERRORSEXITS("OC_Region_CreateStartObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the data points for a region identified by an object.
  SUBROUTINE OC_Region_DataPointsGetObj(region,dataPointsUserNumber,dataPoints,err)
    !DLLEXPORT(OC_Region_DataPointsGetObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the data points for.
    INTEGER(INTG), INTENT(IN) :: dataPointsUserNumber !<The user number of the data points to get.
    TYPE(OC_DataPointsType), INTENT(INOUT) :: dataPoints !<On return, the regions data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_DataPointsGetObj",err,error,*999)

    CALL Region_DataPointsGet(region%region,dataPointsUserNumber,dataPoints%dataPoints,err,error,*999)

    EXITS("OC_Region_DataPointsGetObj")
    RETURN
999 ERRORSEXITS("OC_Region_DataPointsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_DataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an user number.
  SUBROUTINE OC_Region_DestroyNumber(contextUserNumber,regionUserNumber,err)
    !DLLEXPORT(OC_Region_DestroyNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_DestroyNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_Destroy(region,err,error,*999)

    EXITS("OC_Region_DestroyNumber")
    RETURN
999 ERRORSEXITS("OC_Region_DestroyNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an object.
  SUBROUTINE OC_Region_DestroyObj(region,err)
    !DLLEXPORT(OC_Region_DestroyObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(INOUT) :: region !<The region to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_DestroyObj",err,error,*999)

    CALL Region_Destroy(region%region,err,error,*999)

    EXITS("OC_Region_DestroyObj")
    RETURN
999 ERRORSEXITS("OC_Region_DestroyObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an user number.
  SUBROUTINE OC_Region_LabelGetCNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(OC_Region_LabelGetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_LabelGetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelGet(region,label,err,error,*999)

    EXITS("OC_Region_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("OC_Region_LabelGetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an object.
  SUBROUTINE OC_Region_LabelGetCObj(region,label,err)
    !DLLEXPORT(OC_Region_LabelGetCObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_LabelGetCObj",err,error,*999)

    CALL Region_LabelGet(region%region,label,err,error,*999)

    EXITS("OC_Region_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Region_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an user number.
  SUBROUTINE OC_Region_LabelGetVSNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(OC_Region_LabelGetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_LabelGetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelGet(region,label,err,error,*999)

    EXITS("OC_Region_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Region_LabelGetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an object.
  SUBROUTINE OC_Region_LabelGetVSObj(region,label,err)
    !DLLEXPORT(OC_Region_LabelGetVSObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_LabelGetVSObj",err,error,*999)

    CALL Region_LabelGet(region%region,label,err,error,*999)

    EXITS("OC_Region_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Region_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an user number.
  SUBROUTINE OC_Region_LabelSetCNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(OC_Region_LabelSetCNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_LabelSetCNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelSet(region,label,err,error,*999)

    EXITS("OC_Region_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("OC_Region_LabelSetCNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an object.
  SUBROUTINE OC_Region_LabelSetCObj(region,label,err)
    !DLLEXPORT(OC_Region_LabelSetCObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_LabelSetCObj",err,error,*999)

    CALL Region_LabelSet(region%region,label,err,error,*999)

    EXITS("OC_Region_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Region_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a region identified by an user number.
  SUBROUTINE OC_Region_LabelSetVSNumber(contextUserNumber,regionUserNumber,label,err)
    !DLLEXPORT(OC_Region_LabelSetVSNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_Region_LabelSetVSNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_LabelSet(region,CHAR(label),err,error,*999)

    EXITS("OC_Region_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("OC_Region_LabelSetVSNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a region identified by an object.
  SUBROUTINE OC_Region_LabelSetVSObj(region,label,err)
    !DLLEXPORT(OC_Region_LabelSetVSObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_LabelSetVSObj",err,error,*999)

    CALL Region_LabelSet(region%region,CHAR(label),err,error,*999)

    EXITS("OC_Region_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Region_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a region identified by an object.
  SUBROUTINE OC_Region_NodesGetObj(region,nodes,err)
    !DLLEXPORT(OC_Region_NodesGetObj)

    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the nodes for.
    TYPE(OC_NodesType), INTENT(INOUT) :: nodes !<On return, the regions nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Region_NodesGetObj",err,error,*999)

    CALL Region_NodesGet(region%region,nodes%nodes,err,error,*999)

    EXITS("OC_Region_NodesGetObj")
    RETURN
999 ERRORSEXITS("OC_Region_NodesGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_NodesGetObj

!!==================================================================================================================================
!!
!! SolverRoutines
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE OC_CellMLEquations_CellMLAddNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,cellMLUserNumber,cellMLIndex,err)
    !DLLEXPORT(OC_CellMLEquations_CellMLAddNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: cellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLType), POINTER :: cellml
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_CellMLEquations_CellMLAddNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellMLEquations_CellMLAdd(cellMLEquations,cellml,cellMLIndex,err,error,*999)

    EXITS("OC_CellMLEquations_CellMLAddNumber0")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_CellMLAddNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_CellMLAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE OC_CellMLEquations_CellMLAddNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,cellMLUserNumber,cellMLIndex,err)
    !DLLEXPORT(OC_CellMLEquations_CellMLAddNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: cellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: cellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLType), POINTER :: cellml
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_CellMLEquations_CellMLAddNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    NULLIFY(region)
    NULLIFY(cellml)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_CellMLGet(region,cellMLUserNumber,cellml,err,error,*999)
    CALL CellMLEquations_CellMLAdd(cellMLEquations,cellml,cellMLIndex,err,error,*999)

    EXITS("OC_CellMLEquations_CellMLAddNumber1")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_CellMLAddNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_CellMLAddNumber1

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an object.
  SUBROUTINE OC_CellMLEquations_CellMLAddObj(cellMLEquations,CellML,cellMLIndex,err)
    !DLLEXPORT(OC_CellMLEquations_CellMLAddObj)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to add the CellML environment for.
    TYPE(OC_CellMLType), INTENT(IN) :: CellML !<The CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: cellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_CellMLAddObj",err,error,*999)

    CALL CellMLEquations_CellMLAdd(cellMLEquations%cellmlEquations,CellML%cellML,cellMLIndex,err,error,*999)

    EXITS("OC_CellMLEquations_CellMLAddObj")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_CellMLAddObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_CellMLAddObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for CellML equations identified by an user number.
  SUBROUTINE OC_CellMLEquations_LinearityTypeGetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(OC_CellMLEquations_LinearityTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to get the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get CellML equations linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On exit, the linearity type of the specified CellML equations. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_CellMLEquations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_LinearityTypeGet(cellMLEquations,linearityType,err,error,*999)

    EXITS("OC_CellMLEquations_LinearityTypeGetNumber")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_LinearityTypeGetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for CellML equations identified by an object.
  SUBROUTINE OC_CellMLEquations_LinearityTypeGetObj(cellMLEquations,linearityType,err)
    !DLLEXPORT(OC_CellMLEquations_LinearityTypeGetObj)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On exit, the linearity type of the specified CellML equations. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_LinearityTypeGetObj",err,error,*999)

    CALL CellMLEquations_LinearityTypeGet(cellMLEquations%cellMLEquations,linearityType,err,error,*999)

    EXITS("OC_CellMLEquations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_LinearityTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for CellML equations identified by an user number.
  SUBROUTINE OC_CellMLEquations_LinearityTypeSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(OC_CellMLEquations_LinearityTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to set the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set CellML equations linearity type for.
    INTEGER(INTG), INTENT(IN) :: linearityType !<The linearity type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_CellMLEquations_LinearityTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_LinearityTypeSet(cellMLEquations,linearityType,err,error,*999)

    EXITS("OC_CellMLEquations_LinearityTypeSetNumber")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_LinearityTypeSetNumber",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_LinearityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for CellML equations identified by an object.
  SUBROUTINE OC_CellMLEquations_LinearityTypeSetObj(cellMLEquations,linearityType,err)
    !DLLEXPORT(OC_CellMLEquations_LinearityTypeSetObj)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to set the linearity type for.
    INTEGER(INTG), INTENT(IN) :: linearityType !<The linearity type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_LinearityTypeSetObj",err,error,*999)

    CALL CellMLEquations_LinearityTypeSet(cellMLEquations%cellMLEquations,linearityType,err,error,*999)

    EXITS("OC_CellMLEquations_LinearityTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_CellMLEquations_LinearityTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_LinearityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for CellML equations identified by an user number.
  SUBROUTINE OC_CellMLEquations_TimeDependenceTypeGetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,timeDependenceType,err)
    !DLLEXPORT(OC_CellMLEquations_TimeDependenceTypeGetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to get the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get CellML equations time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On exit, the time dependence type of the specified CellML equations. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_CellMLEquations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_TimeDependenceTypeGet(cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("OC_CellMLEquations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORS("OC_CellMLEquations_TimeDependenceTypeGetNumber",err,error)
    EXITS("OC_CellMLEquations_TimeDependenceTypeGetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the time dependence type for CellML equations identified by an object.
  SUBROUTINE OC_CellMLEquations_TimeDependenceTypeGetObj(cellMLEquations,timeDependenceType,err)
    !DLLEXPORT(OC_CellMLEquations_TimeDependenceTypeGetObj)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On exit, the time dependence type of the specified CellML equations. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_TimeDependenceTypeGetObj",err,error,*999)

    CALL CellMLEquations_TimeDependenceTypeGet(cellMLEquations%cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("OC_CellMLEquations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORS("OC_CellMLEquations_TimeDependenceTypeGetObj",err,error)
    EXITS("OC_CellMLEquations_TimeDependenceTypeGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_TimeDependenceTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for CellML equations identified by an user number.
  SUBROUTINE OC_CellMLEquations_TimeDependenceTypeSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,timeDependenceType,err)
    !DLLEXPORT(OC_CellMLEquations_TimeDependenceTypeSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to set the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set CellML equations time dependence type for.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The time dependence type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CellMLEquationsType), POINTER :: cellMLEquations
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_CellMLEquations_TimeDependenceTypeSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations,err,error,*999)
    CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("OC_CellMLEquations_TimeDependenceTypeSetNumber")
    RETURN
999 ERRORS("OC_CellMLEquations_TimeDependenceTypeSetNumber",err,error)
    EXITS("OC_CellMLEquations_TimeDependenceTypeSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_TimeDependenceTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for CellML equations identified by an object.
  SUBROUTINE OC_CellMLEquations_TimeDependenceTypeSetObj(cellMLEquations,timeDependenceType,err)
    !DLLEXPORT(OC_CellMLEquations_TimeDependenceTypeSetObj)

    !Argument variables
    TYPE(OC_CellMLEquationsType), INTENT(IN) :: cellMLEquations !<The CellML equations to set the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: timeDependenceType !<The time dependence type of the specified CellML equations to set. \see OpenCMISS_CellMLEquationsTimeDependenceTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_CellMLEquations_TimeDependenceTypeSetObj",err,error,*999)

    CALL CellMLEquations_TimeDependenceTypeSet(cellMLEquations%cellMLEquations,timeDependenceType,err,error,*999)

    EXITS("OC_CellMLEquations_TimeDependenceTypeSetObj")
    RETURN
999 ERRORS("OC_CellMLEquations_TimeDependenceTypeSetObj",err,error)
    EXITS("OC_CellMLEquations_TimeDependenceTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_CellMLEquations_TimeDependenceTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE OC_Solver_CellMLEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(OC_Solver_CellMLEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("OC_Solver_CellMLEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_CellMLEquationsGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE OC_Solver_CellMLEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & cellMLEquations,err)
    !DLLEXPORT(OC_Solver_CellMLEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the CelllML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_CellMLEquationsGet(solver,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("OC_Solver_CellMLEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_CellMLEquationsGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_CellMLEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an object.
  SUBROUTINE OC_Solver_CellMLEquationsGetObj(solver,cellMLEquations,err)
    !DLLEXPORT(OC_Solver_CellMLEquationsGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the CellML equations for.
    TYPE(OC_CellMLEquationsType), INTENT(INOUT) :: cellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_CellMLEquationsGetObj",err,error,*999)

    CALL Solver_CellMLEquationsGet(solver%solver,cellMLEquations%cellmlEquations,err,error,*999)

    EXITS("OC_Solver_CellMLEquationsGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_CellMLEquationsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_CellMLEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAEEulerSolverTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(OC_Solver_DAEEulerSolverTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAEEulerSolverTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeGet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("OC_Solver_DAEEulerSolverTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DAEEulerSolverTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAEEulerSolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAEEulerSolverTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(OC_Solver_DAEEulerSolverTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAEEulerSolverTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeGet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("OC_Solver_DAEEulerSolverTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DAEEulerSolverTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAEEulerSolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE OC_Solver_DAEEulerSolverTypeGetObj(solver,DAEEulerSolverType,err)
    !DLLEXPORT(OC_Solver_DAEEulerSolverTypeGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DAEEulerSolverTypeGetObj",err,error,*999)

    CALL Solver_DAEEulerSolverTypeGet(solver%solver,DAEEulerSolverType,err,error,*999)

    EXITS("OC_Solver_DAEEulerSolverTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DAEEulerSolverTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAEEulerSolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAEEulerSolverTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(OC_Solver_DAEEulerSolverTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAEEulerSolverTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeSet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("OC_Solver_DAEEulerSolverTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DAEEulerSolverTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAEEulerSolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAEEulerSolverTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAEEulerSolverType,err)
    !DLLEXPORT(OC_Solver_DAEEulerSolverTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAEEulerSolverTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAEEulerSolverTypeSet(solver,DAEEulerSolverType,err,error,*999)

    EXITS("OC_Solver_DAEEulerSolverTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DAEEulerSolverTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAEEulerSolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE OC_Solver_DAEEulerSolverTypeSetObj(solver,DAEEulerSolverType,err)
    !DLLEXPORT(OC_Solver_DAEEulerSolverTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OpenCMISS_EulerDAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DAEEulerSolverTypeSetObj",err,error,*999)

    CALL Solver_DAEEulerSolverTypeSet(solver%solver,DAEEulerSolverType,err,error,*999)

    EXITS("OC_Solver_DAEEulerSolverTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DAEEulerSolverTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAEEulerSolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAESolverTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(OC_Solver_DAESolverTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAESolverTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeGet(solver,DAESolverType,err,error,*999)

    EXITS("OC_Solver_DAESolverTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DAESolverTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAESolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAESolverTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(OC_Solver_DAESolverTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAESolverTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeGet(solver,DAESolverType,err,error,*999)

    EXITS("OC_Solver_DAESolverTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DAESolverTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAESolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE OC_Solver_DAESolverTypeGetObj(solver,DAESolverType,err)
    !DLLEXPORT(OC_Solver_DAESolverTypeGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DAESolverTypeGetObj",err,error,*999)

    CALL Solver_DAESolverTypeGet(solver%solver,DAESolverType,err,error,*999)

    EXITS("OC_Solver_DAESolverTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DAESolverTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAESolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAESolverTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(OC_Solver_DAESolverTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAESolverTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeSet(solver,DAESolverType,err,error,*999)

    EXITS("OC_Solver_DAESolverTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DAESolverTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAESolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAESolverTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & DAESolverType,err)
    !DLLEXPORT(OC_Solver_DAESolverTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAESolverTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAESolverTypeSet(solver,DAESolverType,err,error,*999)

    EXITS("OC_Solver_DAESolverTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DAESolverTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAESolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE OC_Solver_DAESolverTypeSetObj(solver,DAESolverType,err)
    !DLLEXPORT(OC_Solver_DAESolverTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OpenCMISS_DAESolverTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DAESolverTypeSetObj",err,error,*999)

    CALL Solver_DAESolverTypeSet(solver%solver,DAESolverType,err,error,*999)

    EXITS("OC_Solver_DAESolverTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DAESolverTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAESolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAETimesSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & startTime,endTime,err)
    !DLLEXPORT(OC_Solver_DAETimesSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAETimesSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimesSet(solver,startTime,endTime,err,error,*999)

    EXITS("OC_Solver_DAETimesSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DAETimesSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAETimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAETimesSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & startTime,endTime,err)
    !DLLEXPORT(OC_Solver_DAETimesSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAETimesSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimesSet(solver,startTime,endTime,err,error,*999)

    EXITS("OC_Solver_DAETimesSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DAETimesSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAETimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an object.
  SUBROUTINE OC_Solver_DAETimesSetObj(solver,startTime,endTime,err)
    !DLLEXPORT(OC_Solver_DAETimesSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DAETimesSetObj",err,error,*999)

    CALL Solver_DAETimesSet(solver%solver,startTime,endTime,err,error,*999)

    EXITS("OC_Solver_DAETimesSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DAETimesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAETimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAETimeStepSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & timeStep,err)
    !DLLEXPORT(OC_Solver_DAETimeStepSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAETimeStepSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimeStepSet(solver,timeStep,err,error,*999)

    EXITS("OC_Solver_DAETimeStepSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DAETimeStepSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAETimeStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE OC_Solver_DAETimeStepSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & timeStep,err)
    !DLLEXPORT(OC_Solver_DAETimeStepSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DAETimeStepSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DAETimeStepSet(solver,timeStep,err,error,*999)

    EXITS("OC_Solver_DAETimeStepSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DAETimeStepSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAETimeStepSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an object.
  SUBROUTINE OC_Solver_DAETimeStepSetObj(solver,timeStep,err)
    !DLLEXPORT(OC_Solver_DAETimeStepSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DAETimeStepSetObj",err,error,*999)

    CALL Solver_DAETimeStepSet(solver%solver,timeStep,err,error,*999)

    EXITS("OC_Solver_DAETimeStepSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DAETimeStepSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DAETimeStepSetObj

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicDegreeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)
    !DLLEXPORT(OC_Solver_DynamicDegreeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicDegreeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeGet(solver,degree,err,error,*999)

    EXITS("OC_Solver_DynamicDegreeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicDegreeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicDegreeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicDegreeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)
    !DLLEXPORT(OC_Solver_DynamicDegreeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicDegreeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeGet(solver,degree,err,error,*999)

    EXITS("OC_Solver_DynamicDegreeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicDegreeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicDegreeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicDegreeGetObj(solver,degree,err)
    !DLLEXPORT(OC_Solver_DynamicDegreeGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicDegreeGetObj",err,error,*999)

    CALL Solver_DynamicDegreeGet(solver%solver,degree,err,error,*999)

    EXITS("OC_Solver_DynamicDegreeGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicDegreeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicDegreeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicDegreeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)
    !DLLEXPORT(OC_Solver_DynamicDegreeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicDegreeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeSet(solver,degree,err,error,*999)

    EXITS("OC_Solver_DynamicDegreeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicDegreeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicDegreeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicDegreeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)
    !DLLEXPORT(OC_Solver_DynamicDegreeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicDegreeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicDegreeSet(solver,degree,err,error,*999)

    EXITS("OC_Solver_DynamicDegreeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicDegreeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicDegreeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicDegreeSetObj(solver,degree,err)
    !DLLEXPORT(OC_Solver_DynamicDegreeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OpenCMISS_DynamicDegreeTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicDegreeSetObj",err,error,*999)

    CALL Solver_DynamicDegreeSet(solver%solver,degree,err,error,*999)

    EXITS("OC_Solver_DynamicDegreeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicDegreeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicDegreeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicLinearityTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(OC_Solver_DynamicLinearityTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicLinearityTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinearityTypeGet(solver,linearityType,err,error,*999)

    EXITS("OC_Solver_DynamicLinearityTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicLinearityTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicLinearityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicLinearityTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearityType,err)
    !DLLEXPORT(OC_Solver_DynamicLinearityTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicLinearityTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinearityTypeGet(solver,linearityType,err,error,*999)

    EXITS("OC_Solver_DynamicLinearityTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicLinearityTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicLinearityTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicLinearityTypeGetObj(solver,linearityType,err)
    !DLLEXPORT(OC_Solver_DynamicLinearityTypeGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OpenCMISS_DynamicLinearityTypes,OpenCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicLinearityTypeGetObj",err,error,*999)

    CALL Solver_DynamicLinearityTypeGet(solver%solver,linearityType,err,error,*999)

    EXITS("OC_Solver_DynamicLinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicLinearityTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicLinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicNonlinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolverIndex,err)
    !DLLEXPORT(OC_Solver_DynamicNonlinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the solver index of the nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,nonlinearSolver

    ENTERS("OC_Solver_DynamicNonlinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(nonlinearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedNonlinearSolverGet(solver,nonlinearSolver,err,error,*999)
    !todo: get the solver index from nonlinear solver
    nonlinearSolverIndex=nonlinearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_DynamicNonlinearSolverGetNumber0")
    RETURN
999 ERRORS("OC_Solver_DynamicNonlinearSolverGetNumber0",err,error)
    EXITS("OC_Solver_DynamicNonlinearSolverGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicNonlinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicNonlinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolverIndex,err)
    !DLLEXPORT(OC_Solver_DynamicNonlinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the dynamic nonlinear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,nonlinearSolver

    ENTERS("OC_Solver_DynamicNonlinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(nonlinearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedNonlinearSolverGet(solver,nonlinearSolver,err,error,*999)
    !todo: get the solver index from nonlinear solver
    nonlinearSolverIndex=nonlinearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_DynamicNonlinearSolverGetNumber1")
    RETURN
999 ERRORS("OC_Solver_DynamicNonlinearSolverGetNumber1",err,error)
    EXITS("OC_Solver_DynamicNonlinearSolverGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicNonlinearSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicNonlinearSolverGetObj(solver,nonlinearSolver,err)
    !DLLEXPORT(OC_Solver_DynamicNonlinearSolverGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic nonlinear solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: nonlinearSolver  !<On return, the dynamic nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicNonlinearSolverGetObj",err,error,*999)

    CALL Solver_DynamicLinkedNonlinearSolverGet(solver%solver,nonlinearSolver%solver,err,error,*999)

    EXITS("OC_Solver_DynamicNonlinearSolverGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicNonlinearSolverGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicNonlinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicLinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(OC_Solver_DynamicLinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("OC_Solver_DynamicLinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_DynamicLinearSolverGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicLinearSolverGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicLinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(OC_Solver_DynamicLinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the dynamic linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("OC_Solver_DynamicLinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_DynamicLinearSolverGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicLinearSolverGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicLinearSolverGetObj(solver,linearSolver,err)
    !DLLEXPORT(OC_Solver_DynamicLinearSolverGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic linear solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: linearSolver !<On return, the dynamic linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicLinearSolverGetObj",err,error,*999)

    CALL Solver_DynamicLinkedLinearSolverGet(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("OC_Solver_DynamicLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicLinearSolverGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicSchemeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,scheme,err)
    !DLLEXPORT(OC_Solver_DynamicSchemeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OpenCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicSchemeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicSchemeSet(solver,scheme,err,error,*999)

    EXITS("OC_Solver_DynamicSchemeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicSchemeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicSchemeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicSchemeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,scheme,err)
    !DLLEXPORT(OC_Solver_DynamicSchemeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OpenCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicSchemeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicSchemeSet(solver,scheme,err,error,*999)

    EXITS("OC_Solver_DynamicSchemeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicSchemeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicSchemeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicSchemeSetObj(solver,scheme,err)
    !DLLEXPORT(OC_Solver_DynamicSchemeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OpenCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicSchemeSetObj",err,error,*999)

    CALL Solver_DynamicSchemeSet(solver%solver,scheme,err,error,*999)

    EXITS("OC_Solver_DynamicSchemeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicSchemeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicSchemeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicThetaSetNumber00(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,theta,err)
    !DLLEXPORT(OC_Solver_DynamicThetaSetNumber00)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicThetaSetNumber00",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,theta,err,error,*999)

    EXITS("OC_Solver_DynamicThetaSetNumber00")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicThetaSetNumber00",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicThetaSetNumber00

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicThetaSetNumber01(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,thetas,err)
    !DLLEXPORT(OC_Solver_DynamicThetaSetNumber01)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicThetaSetNumber01",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,thetas,err,error,*999)

    EXITS("OC_Solver_DynamicThetaSetNumber01")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicThetaSetNumber01",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicThetaSetNumber01

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicThetaSetNumber10(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,theta,err)
    !DLLEXPORT(OC_Solver_DynamicThetaSetNumber10)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicThetaSetNumber10",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,theta,err,error,*999)

    EXITS("OC_Solver_DynamicThetaSetNumber10")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicThetaSetNumber10",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicThetaSetNumber10

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicThetaSetNumber11(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,thetas,err)
    !DLLEXPORT(OC_Solver_DynamicThetaSetNumber11)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicThetaSetNumber11",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicThetaSet(solver,thetas,err,error,*999)

    EXITS("OC_Solver_DynamicThetaSetNumber11")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicThetaSetNumber11",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicThetaSetNumber11

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicThetaSetObj0(solver,theta,err)
    !DLLEXPORT(OC_Solver_DynamicThetaSetObj0)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicThetaSetObj0",err,error,*999)

    CALL Solver_DynamicThetaSet(solver%solver,theta,err,error,*999)

    EXITS("OC_Solver_DynamicThetaSetObj0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicThetaSetObj0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicThetaSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicThetaSetObj1(solver,thetas,err)
    !DLLEXPORT(OC_Solver_DynamicThetaSetObj1)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicThetaSetObj1",err,error,*999)

    CALL Solver_DynamicThetaSet(solver%solver,thetas,err,error,*999)

    EXITS("OC_Solver_DynamicThetaSetObj1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicThetaSetObj1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicThetaSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicTimesSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & currentTime,timeIncrement,err)
    !DLLEXPORT(OC_Solver_DynamicTimesSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicTimesSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicTimesSet(solver,currentTime,timeIncrement,err,error,*999)

    EXITS("OC_Solver_DynamicTimesSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicTimesSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicTimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE OC_Solver_DynamicTimesSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & currentTime,timeIncrement,err)
    !DLLEXPORT(OC_Solver_DynamicTimesSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_DynamicTimeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_DynamicTimesSet(solver,currentTime,timeIncrement,err,error,*999)

    EXITS("OC_Solver_DynamicTimesSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicTimesSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicTimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an object.
  SUBROUTINE OC_Solver_DynamicTimesSetObj(solver,currentTime,timeIncrement,err)
    !DLLEXPORT(OC_Solver_DynamicTimesSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_DynamicTimesSetObj",err,error,*999)

    CALL Solver_DynamicTimesSet(solver%solver,currentTime,timeIncrement,err,error,*999)

    EXITS("OC_Solver_DynamicTimesSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_DynamicTimesSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_DynamicTimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationArbitraryPathSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,arbitraryPath,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationArbitraryPathSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationArbitraryPathSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationArbitraryPathSet(solver,arbitraryPath,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationArbitraryPathSetNumber")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationArbitraryPathSetNumber",err,error)
    EXITS("OC_Solver_GeometricTransformationArbitraryPathSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationArbitraryPathSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationArbitraryPathSetObj(solver,arbitraryPath,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationArbitraryPathSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the arbitrary path for.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationArbitraryPathSetObj",err,error,*999)

    CALL Solver_GeometricTransformationArbitraryPathSet(solver%solver,arbitraryPath,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationArbitraryPathSetObj")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationArbitraryPathSetObj",err,error)
    EXITS("OC_Solver_GeometricTransformationArbitraryPathSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationArbitraryPathSetObj

  !
  !================================================================================================================================
  !

  !>Clear transformation a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationClearNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,err)    
    !DLLEXPORT(OC_Solver_GeometricTransformationClearNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationClearNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationClear(solver,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationClearNumber")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationClearNumber",err,error)
    EXITS("OC_Solver_GeometricTransformationClearNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationClearNumber

  !
  !================================================================================================================================
  !

  !>Clear transformation for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationClearObj(solver,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationClearObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to clear
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationClearObj",err,error,*999)

    CALL Solver_GeometricTransformationClear(solver%solver,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationClearObj")
    RETURN
999 ERRORSEXITS("OC_Solver_GeometricTransformationClearObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationClearObj

  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationFieldSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,regionUserNumber,fieldUserNumber,variableType,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationFieldSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number for the field
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationFieldSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(field)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_FieldGet(region,fieldUserNumber,field,err,error,*999)
    CALL Solver_GeometricTransformationFieldSet(solver,field,variableType,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationFieldSetNumber")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationFieldSetNumber",err,error)
    EXITS("OC_Solver_GeometricTransformationFieldSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationFieldSetObj(solver,field,variableType,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationFieldSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    TYPE(OC_FieldType), INTENT(IN) :: field !<The field for the solver to set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationFieldSetObj",err,error,*999)

    CALL Solver_GeometricTransformationFieldSet(solver%solver,field%field,variableType,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationFieldSetObj")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationFieldSetObj",err,error)
    EXITS("OC_Solver_GeometricTransformationFieldSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationFieldSetObj

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE OC_Solver_GeometricTransformationMatrixSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,matrix,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationMatrixSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationMatrixSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationMatrixSet(solver,1,matrix,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationMatrixSetNumber0")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationMatrixSetNumber0",err,error)
    EXITS("OC_Solver_GeometricTransformationMatrixSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationMatrixSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE OC_Solver_GeometricTransformationMatrixSetObj0(solver,matrix,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationMatrixSetObj0)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationMatrixSetObj0",err,error,*999)

    CALL Solver_GeometricTransformationMatrixSet(solver%solver,1,matrix,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationMatrixSetObj0")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationMatrixSetObj0",err,error)
    EXITS("OC_Solver_GeometricTransformationMatrixSetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationMatrixSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationMatrixSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,loadIncrementIdx,matrix,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationMatrixSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationMatrixSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationMatrixSet(solver,loadIncrementIdx,matrix,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationMatrixSetNumber1")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationMatrixSetNumber1",err,error)
    EXITS("OC_Solver_GeometricTransformationMatrixSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationMatrixSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationMatrixSetObj1(solver,loadIncrementIdx,matrix,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationMatrixSetObj1)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationMatrixSetObj1",err,error,*999)

    CALL Solver_GeometricTransformationMatrixSet(solver%solver,loadIncrementIdx,matrix,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationMatrixSetObj1")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationMatrixSetObj1",err,error)
    EXITS("OC_Solver_GeometricTransformationMatrixSetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationMatrixSetObj1

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,numberOfIncrements,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver,numberOfIncrements,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber",err,error)
    EXITS("OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationNoLoadIncrementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationNoLoadIncrementsSetObj(solver,numberOfIncrements,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationNoLoadIncrementsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationNoLoadIncrementsSetObj",err,error,*999)

    CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver%solver,numberOfIncrements,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationNoLoadIncrementsSetObj")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationNoLoadIncrementsSetObj",err,error)
    EXITS("OC_Solver_GeometricTransformationNoLoadIncrementsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationNoLoadIncrementsSetObj

  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE OC_Solver_GeometricTransformationRotationSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,pivotPoint,axis,angle,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationRotationSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationRotationSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationRotationSet(solver,1,pivotPoint,axis,angle,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationRotationSetNumber0")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationRotationSetNumber0",err,error)
    EXITS("OC_Solver_GeometricTransformationRotationSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationRotationSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE OC_Solver_GeometricTransformationRotationSetObj0(solver,pivotPoint,axis,angle,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationRotationSetObj0)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationRotationSetObj0",err,error,*999)

    CALL Solver_GeometricTransformationRotationSet(solver%solver,1,pivotPoint,axis,angle,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationRotationSetObj0")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationRotationSetObj0",err,error)
    EXITS("OC_Solver_GeometricTransformationRotationSetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationRotationSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationRotationSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,loadIncrementIdx,pivotPoint,axis,angle,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationRotationSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationRotationSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationRotationSet(solver,loadIncrementIdx,pivotPoint,axis,angle,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationRotationSetNumber1")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationRotationSetNumber1",err,error)
    EXITS("OC_Solver_GeometricTransformationRotationSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationRotationSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationRotationSetObj1(solver,loadIncrementIdx,pivotPoint,axis,angle,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationRotationSetObj1)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationRotationSetObj1",err,error,*999)

    CALL Solver_GeometricTransformationRotationSet(solver%solver,loadIncrementIdx,pivotPoint,axis,angle,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationRotationSetObj1")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationRotationSetObj1",err,error)
    EXITS("OC_Solver_GeometricTransformationRotationSetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationRotationSetObj1

  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationScalingsSetNumber(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,scalings,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationScalingsSetNumber)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationScalingsSetNumber",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationScalingsSet(solver,scalings,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationScalingsSetNumber")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationScalingsSetNumber",err,error)
    EXITS("OC_Solver_GeometricTransformationScalingsSetNumber")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationScalingsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationScalingsSetObj(solver,scalings,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationScalingsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationScalingsSetObj",err,error,*999)

    CALL Solver_GeometricTransformationScalingsSet(solver%solver,scalings,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationScalingsSetObj")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationScalingsSetObj",err,error)
    EXITS("OC_Solver_GeometricTransformationScalingsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationScalingsSetObj

  !
  !================================================================================================================================
  !

  !>Sets the translation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE OC_Solver_GeometricTransformationTranslationSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,translation,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationTranslationSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationTranslationSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationTranslationSet(solver,1,translation,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationTranslationSetNumber0")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationTranslationSetNumber0",err,error)
    EXITS("OC_Solver_GeometricTransformationTranslationSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationTranslationSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the translation vector for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE OC_Solver_GeometricTransformationTranslationSetObj0(solver,translation,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationTranslationSetObj0)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationTranslationSetObj0",err,error,*999)

    CALL Solver_GeometricTransformationTranslationSet(solver%solver,1,translation,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationTranslationSetObj0")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationTranslationSetObj0",err,error)
    EXITS("OC_Solver_GeometricTransformationTranslationSetObj0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationTranslationSetObj0

  !
  !================================================================================================================================
  !

  !>Sets the translation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE OC_Solver_GeometricTransformationTranslationSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,loadIncrementIdx,translation,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationTranslationSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_GeometricTransformationTranslationSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_GeometricTransformationTranslationSet(solver,loadIncrementIdx,translation,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationTranslationSetNumber1")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationTranslationSetNumber1",err,error)
    EXITS("OC_Solver_GeometricTransformationTranslationSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationTranslationSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the translation vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE OC_Solver_GeometricTransformationTranslationSetObj1(solver,loadIncrementIdx,translation,err)
    !DLLEXPORT(OC_Solver_GeometricTransformationTranslationSetObj1)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_GeometricTransformationTranslationSetObj1",err,error,*999)

    CALL Solver_GeometricTransformationTranslationSet(solver%solver,loadIncrementIdx,translation,err,error,*999)

    EXITS("OC_Solver_GeometricTransformationTranslationSetObj1")
    RETURN
999 ERRORS("OC_Solver_GeometricTransformationTranslationSetObj1",err,error)
    EXITS("OC_Solver_GeometricTransformationTranslationSetObj1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_GeometricTransformationTranslationSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelGetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelGetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelGetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("OC_Solver_LabelGetCNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelGetCNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelGetCNumber1(contextUserNUmber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelGetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelGetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("OC_Solver_LabelGetCNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelGetCNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an object.
  SUBROUTINE OC_Solver_LabelGetCObj(solver,label,err)
    !DLLEXPORT(OC_Solver_LabelGetCObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LabelGetCObj",err,error,*999)

    CALL Solver_LabelGet(solver%solver,label,err,error,*999)

    EXITS("OC_Solver_LabelGetCObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelGetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelGetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelGetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelGetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("OC_Solver_LabelGetVSNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelGetVSNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelGetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelGetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelGetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelGet(solver,label,err,error,*999)

    EXITS("OC_Solver_LabelGetVSNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelGetVSNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an object.
  SUBROUTINE OC_Solver_LabelGetVSObj(solver,label,err)
    !DLLEXPORT(OC_Solver_LabelGetVSObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LabelGetVSObj",err,error,*999)

    CALL Solver_LabelGet(solver%solver,label,err,error,*999)

    EXITS("OC_Solver_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelGetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelSetCNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelSetCNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelSetCNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,label,err,error,*999)

    EXITS("OC_Solver_LabelSetCNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelSetCNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelSetCNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelSetCNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelSetCNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,label,err,error,*999)

    EXITS("OC_Solver_LabelSetCNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelSetCNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an object.
  SUBROUTINE OC_Solver_LabelSetCObj(solver,label,err)
    !DLLEXPORT(OC_Solver_LabelSetCObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LabelSetCObj",err,error,*999)

    CALL Solver_LabelSet(solver%solver,label,err,error,*999)

    EXITS("OC_Solver_LabelSetCObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelSetCObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelSetVSNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelSetVSNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The solver identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelSetVSNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,CHAR(label),err,error,*999)

    EXITS("OC_Solver_LabelSetVSNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelSetVSNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE OC_Solver_LabelSetVSNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)
    !DLLEXPORT(OC_Solver_LabelSetVSNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LabelSetVSNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LabelSet(solver,CHAR(label),err,error,*999)

    EXITS("OC_Solver_LabelSetVSNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelSetVSNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a solver identified by an object.
  SUBROUTINE OC_Solver_LabelSetVSObj(solver,label,err)
    !DLLEXPORT(OC_Solver_LabelSetVSObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LabelSetVSObj",err,error,*999)

    CALL Solver_LabelSet(solver%solver,CHAR(label),err,error,*999)

    EXITS("OC_Solver_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LabelSetVSObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the type of library for a solver identified by an user number.
  SUBROUTINE OC_Solver_LibraryTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & libraryType,err)    
    !DLLEXPORT(OC_Solver_LibraryTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LibraryTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeGet(solver,libraryType,err,error,*999)

    EXITS("OC_Solver_LibraryTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LibraryTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LibraryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an user number.
  SUBROUTINE OC_Solver_LibraryTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & libraryType,err)
    !DLLEXPORT(OC_Solver_LibraryTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LibraryTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeGet(solver,libraryType,err,error,*999)

    EXITS("OC_Solver_LibraryTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LibraryTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LibraryTypeGetNumber1

  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an object.
  SUBROUTINE OC_Solver_LibraryTypeGetObj(solver,libraryType,err)
    !DLLEXPORT(OC_Solver_LibraryTypeGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LibraryTypeGetObj",err,error,*999)

    CALL Solver_LibraryTypeGet(solver%solver,libraryType,err,error,*999)

    EXITS("OC_Solver_LibraryTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LibraryTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LibraryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library for a solver identified by an user number.
  SUBROUTINE OC_Solver_LibraryTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & libraryType,err)
    !DLLEXPORT(OC_Solver_LibraryTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LibraryTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeSet(solver,libraryType,err,error,*999)

    EXITS("OC_Solver_LibraryTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LibraryTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LibraryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an user number.
  SUBROUTINE OC_Solver_LibraryTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & libraryType,err)
    !DLLEXPORT(OC_Solver_LibraryTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LibraryTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LibraryTypeSet(solver,libraryType,err,error,*999)

    EXITS("OC_Solver_LibraryTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LibraryTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LibraryTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an object.
  SUBROUTINE OC_Solver_LibraryTypeSetObj(solver,libraryType,err)
    !DLLEXPORT(OC_Solver_LibraryTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OpenCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LibraryTypeSetObj",err,error,*999)

    CALL Solver_LibraryTypeSet(solver%solver,libraryType,err,error,*999)

    EXITS("OC_Solver_LibraryTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LibraryTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LibraryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE OC_Solver_LinearDirectTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & directSolverType,err)
    !DLLEXPORT(OC_Solver_LinearDirectTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OpenCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearDirectTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearDirectTypeSet(solver,directSolverType,err,error,*999)

    EXITS("OC_Solver_LinearDirectTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearDirectTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearDirectTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE OC_Solver_LinearDirectTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & directSolverType,err)
    !DLLEXPORT(OC_Solver_LinearDirectTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OpenCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearDirectTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearDirectTypeSet(solver,directSolverType,err,error,*999)

    EXITS("OC_Solver_LinearDirectTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearDirectTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearDirectTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an object.
  SUBROUTINE OC_Solver_LinearDirectTypeSetObj(solver,directSolverType,err)
    !DLLEXPORT(OC_Solver_LinearDirectTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OpenCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearDirectTypeSetObj",err,error,*999)

    CALL Solver_LinearDirectTypeSet(solver%solver,directSolverType,err,error,*999)

    EXITS("OC_Solver_LinearDirectTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearDirectTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearDirectTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS ICNTL(icntl)=ivalue integer control parameters through the PETSc-MUMPS interface. Must be called after the boundary conditions have been set up.
  SUBROUTINE OC_Solver_MumpsSetIcntl(solver,icntl,ivalue,err)
    !DLLEXPORT(OC_Solver_MumpsSetIcntl)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS ICNTL integer control parameter
    INTEGER(INTG), INTENT(IN) :: ivalue !<The MUMPS ICNTL integer value to set: ICNTL(icntl)=ivalue
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_MumpsSetIcntl",err,error,*999)

    CALL Solver_MumpsSetIcntl(solver%solver,icntl,ivalue,err,error,*999)

    EXITS("OC_Solver_MumpsSetIcntl")
    RETURN
999 ERRORSEXITS("OC_Solver_MumpsSetIcntl",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_MumpsSetIcntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS CNTL(icntl)=val real/complex control parameters through the PETSc-MUMPS interface. Must be called after the boundary conditions have been set up.
  SUBROUTINE OC_Solver_MumpsSetCntl(solver,icntl,val,err)
    !DLLEXPORT(OC_Solver_MumpsSetCntl)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS CNTL integer control parameter
    REAL(DP), INTENT(IN) :: val !<The MUMPS CNTL real value to set: CNTL(icntl)=val
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_MumpsSetCntl",err,error,*999)

    CALL Solver_MumpsSetCntl(solver%solver,icntl,val,err,error,*999)

    EXITS("OC_Solver_MumpsSetCntl")
    RETURN
999 ERRORSEXITS("OC_Solver_MumpsSetCntl",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_MumpsSetCntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0",err,error)
    EXITS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1",err,error)
    EXITS("OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativeAbsoluteToleranceSetObj(solver,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeAbsoluteToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativeAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeAbsoluteToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeAbsoluteToleranceSetObj",err,error)
    EXITS("OC_Solver_LinearIterativeAbsoluteToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeDivergenceToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,divergenceTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeDivergenceToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeDivergenceToleranceSet(solver,divergenceTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber0",err,error)
    EXITS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeDivergenceToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeDivergenceToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,divergenceTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeDivergenceToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeDivergenceToleranceSet(solver,divergenceTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber1",err,error)
    EXITS("OC_Solver_LinearIterativeDivergenceToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeDivergenceToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativeDivergenceToleranceSetObj(solver,divergenceTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeDivergenceToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativeDivergenceToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeDivergenceToleranceSet(solver%solver,divergenceTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeDivergenceToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeDivergenceToleranceSetObj",err,error)
    EXITS("OC_Solver_LinearIterativeDivergenceToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeDivergenceToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeGMRESRestartSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,GMRESRestart,err)
    !DLLEXPORT(OC_Solver_LinearIterativeGMRESRestartSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the GMRES restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeGMRESRestartSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeGMRESRestartSet(solver,GMRESRestart,err,error,*999)

    EXITS("OC_Solver_LinearIterativeGMRESRestartSetNumber0")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeGMRESRestartSetNumber0",err,error)
    EXITS("OC_Solver_LinearIterativeGMRESRestartSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeGMRESRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeGMRESRestartSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,GMRESRestart,err)
    !DLLEXPORT(OC_Solver_LinearIterativeGMRESRestartSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeGMRESRestartSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeGMRESRestartSet(solver,GMRESRestart,err,error,*999)

    EXITS("OC_Solver_LinearIterativeGMRESRestartSetNumber1")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeGMRESRestartSetNumber1",err,error)
    EXITS("OC_Solver_LinearIterativeGMRESRestartSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeGMRESRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativeGMRESRestartSetObj(solver,GMRESRestart,err)
    !DLLEXPORT(OC_Solver_LinearIterativeGMRESRestartSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativeGMRESRestartSetObj",err,error,*999)

    CALL Solver_LinearIterativeGMRESRestartSet(solver%solver,GMRESRestart,err,error,*999)

    EXITS("OC_Solver_LinearIterativeGMRESRestartSetObj")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeGMRESRestartSetObj",err,error)
    EXITS("OC_Solver_LinearIterativeGMRESRestartSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeGMRESRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeMaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(OC_Solver_LinearIterativeMaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeMaximumIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_LinearIterativeMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeMaximumIterationsSetNumber0",err,error)
    EXITS("OC_Solver_LinearIterativeMaximumIterationsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeMaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(OC_Solver_LinearIterativeMaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeMaximumIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_LinearIterativeMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeMaximumIterationsSetNumber1",err,error)
    EXITS("OC_Solver_LinearIterativeMaximumIterationsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativeMaximumIterationsSetObj(solver,maximumIterations,err)
    !DLLEXPORT(OC_Solver_LinearIterativeMaximumIterationsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativeMaximumIterationsSetObj",err,error,*999)

    CALL Solver_LinearIterativeMaximumIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_LinearIterativeMaximumIterationsSetObj")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeMaximumIterationsSetObj",err,error)
    EXITS("OC_Solver_LinearIterativeMaximumIterationsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativePreconditionerTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,preconditionerType,err)
    !DLLEXPORT(OC_Solver_LinearIterativePreconditionerTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OpenCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativePreconditionerTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativePreconditionerTypeSet(solver,preconditionerType,err,error,*999)

    EXITS("OC_Solver_LinearIterativePreconditionerTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_LinearIterativePreconditionerTypeSetNumber0",err,error)
    EXITS("OC_Solver_LinearIterativePreconditionerTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativePreconditionerTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativePreconditionerTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,preconditionerType,err)
    !DLLEXPORT(OC_Solver_LinearIterativePreconditionerTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OpenCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativePreconditionerTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativePreconditionerTypeSet(solver,preconditionerType,err,error,*999)

    EXITS("OC_Solver_LinearIterativePreconditionerTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_LinearIterativePreconditionerTypeSetNumber1",err,error)
    EXITS("OC_Solver_LinearIterativePreconditionerTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativePreconditionerTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativePreconditionerTypeSetObj(solver,preconditionerType,err)
    !DLLEXPORT(OC_Solver_LinearIterativePreconditionerTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OpenCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativePreconditionerTypeSetObj",err,error,*999)

    CALL Solver_LinearIterativePreconditionerTypeSet(solver%solver,preconditionerType,err,error,*999)

    EXITS("OC_Solver_LinearIterativePreconditionerTypeSetObj")
    RETURN
999 ERRORS("OC_Solver_LinearIterativePreconditionerTypeSetObj",err,error)
    EXITS("OC_Solver_LinearIterativePreconditionerTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativePreconditionerTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeRelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeRelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeRelativeToleranceSetNumber0",err,error)
    EXITS("OC_Solver_LinearIterativeRelativeToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeRelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeRelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeRelativeToleranceSetNumber1",err,error)
    EXITS("OC_Solver_LinearIterativeRelativeToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativeRelativeToleranceSetObj(solver,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_LinearIterativeRelativeToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativeRelativeToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_LinearIterativeRelativeToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_LinearIterativeRelativeToleranceSetObj",err,error)
    EXITS("OC_Solver_LinearIterativeRelativeToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & iterativeSolverType,err)
    !DLLEXPORT(OC_Solver_LinearIterativeTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OpenCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeTypeSet(solver,iterativeSolverType,err,error,*999)

    EXITS("OC_Solver_LinearIterativeTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearIterativeTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearIterativeTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & iterativeSolverType,err)
    !DLLEXPORT(OC_Solver_LinearIterativeTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OpenCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearIterativeTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearIterativeTypeSet(solver,iterativeSolverType,err,error,*999)

    EXITS("OC_Solver_LinearIterativeTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearIterativeTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearIterativeTypeSetObj(solver,iterativeSolverType,err)
    !DLLEXPORT(OC_Solver_LinearIterativeTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OpenCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearIterativeTypeSetObj",err,error,*999)

    CALL Solver_LinearIterativeTypeSet(solver%solver,iterativeSolverType,err,error,*999)

    EXITS("OC_Solver_LinearIterativeTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearIterativeTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearIterativeTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearSolverType,err)
    !DLLEXPORT(OC_Solver_LinearTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OpenCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_LinearTypeSet(solver,linearSolverType,err,error,*999)

    EXITS("OC_Solver_LinearTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE OC_Solver_LinearTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearSolverType,err)
    !DLLEXPORT(OC_Solver_LinearTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OpenCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_LinearTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_LinearTypeSet(solver,linearSolverType,err,error,*999)

    EXITS("OC_Solver_LinearTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an object.
  SUBROUTINE OC_Solver_LinearTypeSetObj(solver,linearSolverType,err)
    !DLLEXPORT(OC_Solver_LinearTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OpenCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_LinearTypeSetObj",err,error,*999)

    CALL Solver_LinearTypeSet(solver%solver,linearSolverType,err,error,*999)

    EXITS("OC_Solver_LinearTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_LinearTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_LinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for an Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonAbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonAbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonAbsoluteToleranceSetNumber0",err,error)
    EXITS("OC_Solver_NewtonAbsoluteToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonAbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonAbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonAbsoluteToleranceSetNumber1",err,error)
    EXITS("OC_Solver_NewtonAbsoluteToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonAbsoluteToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_NewtonAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonAbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonAbsoluteToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchMonitorOutputSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchMonitorOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber0",err,error)
    EXITS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchMonitorOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchMonitorOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber1",err,error)
    EXITS("OC_Solver_NewtonLineSearchMonitorOutputSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_NewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchMonitorOutputSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_NewtonLineSearchMonitorOutputSet(solver%solver,monitorLinesearchFlag,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchMonitorOutputSetObj")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchMonitorOutputSetObj",err,error)
    EXITS("OC_Solver_NewtonLineSearchMonitorOutputSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonJacobianCalculationTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(OC_Solver_NewtonJacobianCalculationTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("OC_Solver_NewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonJacobianCalculationTypeSetNumber0",err,error)
    EXITS("OC_Solver_NewtonJacobianCalculationTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonJacobianCalculationTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(OC_Solver_NewtonJacobianCalculationTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("OC_Solver_NewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonJacobianCalculationTypeSetNumber1",err,error)
    EXITS("OC_Solver_NewtonJacobianCalculationTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)
    !DLLEXPORT(OC_Solver_NewtonJacobianCalculationTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL Solver_NewtonJacobianCalculationTypeSet(solver%solver,jacobianCalculationType,err,error,*999)

    EXITS("OC_Solver_NewtonJacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("OC_Solver_NewtonJacobianCalculationTypeSetObj",err,error)
    EXITS("OC_Solver_NewtonJacobianCalculationTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(OC_Solver_NewtonLinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("OC_Solver_NewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_NewtonLinearSolverGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLinearSolverGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & linearSolverIndex,err)
    !DLLEXPORT(OC_Solver_NewtonLinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("OC_Solver_NewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_NewtonLinearSolverGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLinearSolverGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonLinearSolverGetObj(solver,linearSolver,err)
    !DLLEXPORT(OC_Solver_NewtonLinearSolverGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the Newton linear solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: linearSolver !<On return, the Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonLinearSolverGetObj",err,error,*999)

    CALL Solver_NewtonLinkedLinearSolverGet(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("OC_Solver_NewtonLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLinearSolverGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonCellMLSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & cellMLSolverIndex,err)
    !DLLEXPORT(OC_Solver_NewtonCellMLSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("OC_Solver_NewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_NewtonCellMLSolverGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonCellMLSolverGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonCellMLSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & cellMLSolverIndex,err)
    !DLLEXPORT(OC_Solver_NewtonCellMLSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("OC_Solver_NewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_NewtonCellMLSolverGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonCellMLSolverGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonCellMLSolverGetObj(solver,CellMLSolver,err)
    !DLLEXPORT(OC_Solver_NewtonCellMLSolverGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the Newton CellML solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonCellMLSolverGetObj",err,error,*999)

    CALL Solver_NewtonLinkedCellMLSolverGet(solver%solver,CellMLSolver%solver,err,error,*999)

    EXITS("OC_Solver_NewtonCellMLSolverGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonCellMLSolverGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonCellMLSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonConvergenceTestTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, & 
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(OC_Solver_NewtonConvergenceTestTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("OC_Solver_NewtonConvergenceTestTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonConvergenceTestTypeSetNumber0",err,error)
    EXITS("OC_Solver_NewtonConvergenceTestTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonConvergenceTestTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(OC_Solver_NewtonConvergenceTestTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("OC_Solver_NewtonConvergenceTestTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonConvergenceTestTypeSetNumber1",err,error)
    EXITS("OC_Solver_NewtonConvergenceTestTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonConvergenceTestTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)
    !DLLEXPORT(OC_Solver_NewtonConvergenceTestTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_NewtonConvergenceTestTypeSet(solver%solver,convergenceTestType,err,error,*999)

    EXITS("OC_Solver_NewtonConvergenceTestTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonConvergenceTestTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for an Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchAlphaSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,alpha,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchAlphaSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchAlphaSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchAlphaSet(solver,alpha,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchAlphaSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchAlphaSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchAlphaSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchAlphaSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & alpha,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchAlphaSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchAlphaSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchAlphaSet(solver,alpha,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchAlphaSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchAlphaSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchAlphaSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_NewtonLineSearchAlphaSetObj(solver,alpha,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchAlphaSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonLineSearchAlphaSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchAlphaSet(solver%solver,alpha,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchAlphaSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchAlphaSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchAlphaSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchMaxStepSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchMaxStepSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchMaxStepSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchMaxStepSetNumber0",err,error)
    EXITS("OC_Solver_NewtonLineSearchMaxStepSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchMaxStepSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchMaxStepSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchMaxStepSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchMaxStepSetNumber1",err,error)
    EXITS("OC_Solver_NewtonLineSearchMaxStepSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_NewtonLineSearchMaxStepSetObj(solver,maxStep,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchMaxStepSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchMaxStepSet(solver%solver,maxStep,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchMaxStepSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchMaxStepSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchStepTolSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchStepTolSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchStepTolSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchStepTolSetNumber0",err,error)
    EXITS("OC_Solver_NewtonLineSearchStepTolSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchStepTolSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchStepTolSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchStepTolSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonLineSearchStepTolSetNumber1",err,error)
    EXITS("OC_Solver_NewtonLineSearchStepTolSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_NewtonLineSearchStepTolSetObj(solver,stepTol,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchStepTolSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonLineSearchStepTolSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchStepToleranceSet(solver%solver,stepTol,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchStepTolSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchStepTolSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchTypeSetNumber0(contextUserNUmber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & lineSearchType,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OpenCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonLineSearchTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & lineSearchType,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OpenCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_NewtonLineSearchTypeSetObj(solver,lineSearchType,err)
    !DLLEXPORT(OC_Solver_NewtonLineSearchTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OpenCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonLineSearchTypeSetObj",err,error,*999)

    CALL Solver_NewtonLinesearchTypeSet(solver%solver,lineSearchType,err,error,*999)

    EXITS("OC_Solver_NewtonLineSearchTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonLineSearchTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    EXITS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    EXITS("OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)
    !DLLEXPORT(OC_Solver_NewtonMaximumFunctionEvaluationsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver%solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("OC_Solver_NewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 ERRORS("OC_Solver_NewtonMaximumFunctionEvaluationsSetObj",err,error)
    EXITS("OC_Solver_NewtonMaximumFunctionEvaluationsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonMaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(OC_Solver_NewtonMaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_NewtonMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonMaximumIterationsSetNumber0",err,error)
    EXITS("OC_Solver_NewtonMaximumIterationsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonMaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(OC_Solver_NewtonMaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_NewtonMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonMaximumIterationsSetNumber1",err,error)
    EXITS("OC_Solver_NewtonMaximumIterationsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonMaximumIterationsSetObj(solver,maximumIterations,err)
    !DLLEXPORT(OC_Solver_NewtonMaximumIterationsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonMaximumIterationsSetObj",err,error,*999)

    CALL Solver_NewtonMaxNumberOfIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_NewtonMaximumIterationsSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonMaximumIterationsSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonRelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonRelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonRelativeToleranceSetNumber0",err,error)
    EXITS("OC_Solver_NewtonRelativeToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonRelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonRelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonRelativeToleranceSetNumber1",err,error)
    EXITS("OC_Solver_NewtonRelativeToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonRelativeToleranceSetObj(solver,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonRelativeToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonRelativeToleranceSetObj",err,error,*999)

    CALL Solver_NewtonRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonRelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonRelativeToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonSolutionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & solutionTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonSolutionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonSolutionToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonSolutionToleranceSetNumber0",err,error)
    EXITS("OC_Solver_NewtonSolutionToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonSolutionToleranceSetNumber1(contextUserNUmber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,solutionTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonSolutionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonSolutionToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonSolutionToleranceSetNumber1",err,error)
    EXITS("OC_Solver_NewtonSolutionToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonSolutionToleranceSetObj(solver,solutionTolerance,err)
    !DLLEXPORT(OC_Solver_NewtonSolutionToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonSolutionToleranceSetObj",err,error,*999)

    CALL Solver_NewtonSolutionToleranceSet(solver%solver,solutionTolerance,err,error,*999)

    EXITS("OC_Solver_NewtonSolutionToleranceSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonSolutionToleranceSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonTrustRegionDelta0SetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,delta0,err)
    !DLLEXPORT(OC_Solver_NewtonTrustRegionDelta0SetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("OC_Solver_NewtonTrustRegionDelta0SetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonTrustRegionDelta0SetNumber0",err,error)
    EXITS("OC_Solver_NewtonTrustRegionDelta0SetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonTrustRegionDelta0SetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,delta0,err)
    !DLLEXPORT(OC_Solver_NewtonTrustRegionDelta0SetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("OC_Solver_NewtonTrustRegionDelta0SetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonTrustRegionDelta0SetNumber1",err,error)
    EXITS("OC_Solver_NewtonTrustRegionDelta0SetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTrustRegionDelta0SetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an object.
  SUBROUTINE OC_Solver_NewtonTrustRegionDelta0SetObj(solver,delta0,err)
    !DLLEXPORT(OC_Solver_NewtonTrustRegionDelta0SetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL Solver_NewtonTrustregionDelta0Set(solver%solver,delta0,err,error,*999)

    EXITS("OC_Solver_NewtonTrustRegionDelta0SetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonTrustRegionDelta0SetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonTrustRegionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,tolerance,err)
    !DLLEXPORT(OC_Solver_NewtonTrustRegionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("OC_Solver_NewtonTrustRegionToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_NewtonTrustRegionToleranceSetNumber0",err,error)
    EXITS("OC_Solver_NewtonTrustRegionToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonTrustRegionToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,tolerance,err)
    !DLLEXPORT(OC_Solver_NewtonTrustRegionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTrustregionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("OC_Solver_NewtonTrustRegionToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_NewtonTrustRegionToleranceSetNumber1",err,error)
    EXITS("OC_Solver_NewtonTrustRegionToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an object.
  SUBROUTINE OC_Solver_NewtonTrustRegionToleranceSetObj(solver,tolerance,err)
    !DLLEXPORT(OC_Solver_NewtonTrustRegionToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL Solver_NewtonTrustregionToleranceSet(solver%solver,tolerance,err,error,*999)

    EXITS("OC_Solver_NewtonTrustRegionToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_NewtonTrustRegionToleranceSetObj",err,error)
    EXITS("OC_Solver_NewtonTrustRegionToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & newtonSolveType,err)
    !DLLEXPORT(OC_Solver_NewtonTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OpenCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTypeSet(solver,newtonSolveType,err,error,*999)

    EXITS("OC_Solver_NewtonTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE OC_Solver_NewtonTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & newtonSolveType,err)
    !DLLEXPORT(OC_Solver_NewtonTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OpenCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NewtonTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NewtonTypeSet(solver,newtonSolveType,err,error,*999)

    EXITS("OC_Solver_NewtonTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an object.
  SUBROUTINE OC_Solver_NewtonTypeSetObj(solver,newtonSolveType,err)
    !DLLEXPORT(OC_Solver_NewtonTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OpenCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NewtonTypeSetObj",err,error,*999)

    CALL Solver_NewtonTypeSet(solver%solver,newtonSolveType,err,error,*999)

    EXITS("OC_Solver_NewtonTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NewtonTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NewtonTypeSetObj

  !
  !================================================================================================================================
  !
  !>Sets/changes the absolute tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonAbsoluteToleranceSet(solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonAbsoluteToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonAbsoluteToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonAbsoluteToleranceSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonAbsoluteToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,monitorLinesearchFlag,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver,monitorLinesearchFlag,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver%solver,monitorLinesearchFlag,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,jacobianCalculationType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver,jacobianCalculationType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OpenCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver%solver,jacobianCalculationType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLinearSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,linearSolverIndex,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLinearSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("OC_Solver_QuasiNewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLinearSolverGetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLinearSolverGetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonLinearSolverGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLinearSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,linearSolverIndex,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLinearSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Quasi-Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,linearSolver

    ENTERS("OC_Solver_QuasiNewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(linearSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedLinearSolverGet(solver,linearSolver,err,error,*999)
    !todo: get the solver index from linear solver
    linearSolverIndex=linearSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLinearSolverGetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLinearSolverGetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonLinearSolverGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonLinearSolverGetObj(solver,linearSolver,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLinearSolverGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton linear solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: linearSolver !<On return, the Quasi-Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonLinearSolverGetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinkedLinearSolverGet(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonLinearSolverGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonCellMLSolverGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,cellMLSolverIndex,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonCellMLSolverGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("OC_Solver_QuasiNewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_QuasiNewtonCellMLSolverGetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonCellMLSolverGetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonCellMLSolverGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonCellMLSolverGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,cellMLSolverIndex,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonCellMLSolverGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: cellMLSolverIndex !<On return, the Quasi-Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver,cellMLSolver

    ENTERS("OC_Solver_QuasiNewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(cellMLSolver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinkedCellMLSolverGet(solver,cellMLSolver,err,error,*999)
    !todo: get the solver index from CellML solver
    cellMLSolverIndex=cellMLSolver%globalNumber
    CALL FlagError("Not implemented.",err,error,*999)

    EXITS("OC_Solver_QuasiNewtonCellMLSolverGetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonCellMLSolverGetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonCellMLSolverGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonCellMLSolverGetObj(solver,CellMLSolver,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonCellMLSolverGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton CellML solver for.
    TYPE(OC_SolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Quasi-Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonCellMLSolverGetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinkedCellMLSolverGet(solver%solver,CellMLSolver%solver,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonCellMLSolverGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonCellMLSolverGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonCellMLSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,convergenceTestType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonConvergenceTestTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonConvergenceTestTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver%solver,convergenceTestType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonConvergenceTestTypeSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonConvergenceTestTypeSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonConvergenceTestTypeSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maxStep,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchMaxStepSet(solver,maxStep,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchMaxStepSetObj(solver,maxStep,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchMaxStepSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinesearchMaxStepSet(solver%solver,maxStep,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchMaxStepSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchMaxStepSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchMaxStepSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,stepTol,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchStepToleranceSet(solver,stepTol,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchStepTolSetObj(solver,stepTol,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchStepTolSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonLineSearchStepTolSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinesearchStepToleranceSet(solver%solver,stepTol,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchStepTolSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchStepTolSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchStepTolSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,lineSearchType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OpenCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,lineSearchType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OpenCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonLinesearchTypeSet(solver,lineSearchType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonLineSearchTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonLineSearchTypeSetObj(solver,lineSearchType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonLineSearchTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OpenCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonLineSearchTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLinesearchTypeSet(solver%solver,lineSearchType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonLineSearchTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonLineSearchTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,maximumFunctionEvaluations,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver%solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonMaximumIterationsSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonMaximumIterationsSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonMaximumIterationsSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,maximumIterations,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonMaximumIterationsSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonMaxNumberOfIterationsSet(solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonMaximumIterationsSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonMaximumIterationsSetObj(solver,maximumIterations,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonMaximumIterationsSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonMaximumIterationsSetObj",err,error,*999)

    CALL Solver_QuasiNewtonMaxNumberOfIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonMaximumIterationsSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonMaximumIterationsSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonMaximumIterationsSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonRelativeToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRelativeToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonRelativeToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRelativeToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRelativeToleranceSet(solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonRelativeToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonRelativeToleranceSetObj(solver,relativeTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRelativeToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonRelativeToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRelativeToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonRelativeToleranceSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonRelativeToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonSolutionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,solutionTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonSolutionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonSolutionToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,solutionTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonSolutionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolutionToleranceSet(solver,solutionTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonSolutionToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonSolutionToleranceSetObj(solver,solutionTolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonSolutionToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonSolutionToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonSolutionToleranceSet(solver%solver,solutionTolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonSolutionToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonSolutionToleranceSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonSolutionToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,delta0,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,delta0,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustregionDelta0Set(solver,delta0,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonTrustRegionDelta0SetObj(solver,delta0,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTrustRegionDelta0SetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL Solver_QuasiNewtonTrustregionDelta0Set(solver%solver,delta0,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTrustRegionDelta0SetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonTrustRegionDelta0SetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonTrustRegionDelta0SetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,tolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,tolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver,tolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonTrustRegionToleranceSetObj(solver,tolerance,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTrustRegionToleranceSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver%solver,tolerance,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTrustRegionToleranceSetObj")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonTrustRegionToleranceSetObj",err,error)
    EXITS("OC_Solver_QuasiNewtonTrustRegionToleranceSetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonRestartSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,quasiNewtonRestart,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRestartSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonRestartSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartNumberSet(solver,quasiNewtonRestart,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRestartSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonRestartSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonRestartSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,quasiNewtonRestart,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRestartSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonRestartSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartNumberSet(solver,quasiNewtonRestart,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRestartSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonRestartSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonRestartSetObj(solver,quasiNewtonRestart,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRestartSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonRestartSetObj",err,error,*999)

    CALL Solver_QuasiNewtonRestartNumberSet(solver%solver,quasiNewtonRestart,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRestartSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonRestartSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonRestartTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,quasiNewtonRestartType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRestartTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonRestartTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartTypeSet(solver,quasiNewtonRestartType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRestartTypeSetNumber0")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonRestartTypeSetNumber0",err,error)
    EXITS("OC_Solver_QuasiNewtonRestartTypeSetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRestartTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonRestartTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,quasiNewtonRestartType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRestartTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonRestartTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonRestartTypeSet(solver,quasiNewtonRestartType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRestartTypeSetNumber1")
    RETURN
999 ERRORS("OC_Solver_QuasiNewtonRestartTypeSetNumber1",err,error)
    EXITS("OC_Solver_QuasiNewtonRestartTypeSetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRestartTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonRestartTypeSetObj(solver,quasiNewtonRestartType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonRestartTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonRestartTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonRestartTypeSet(solver%solver,quasiNewtonRestartType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonRestartTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonRestartTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonRestartTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonScaleTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,quasiNewtonScaleType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonScaleTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonScaleTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonScaleTypeSet(solver,quasiNewtonScaleType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonScaleTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonScaleTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonScaleTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonScaleTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,quasiNewtonScaleType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonScaleTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonScaleTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonScaleTypeSet(solver,quasiNewtonScaleType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonScaleTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonScaleTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonScaleTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonScaleTypeSetObj(solver,quasiNewtonScaleType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonScaleTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonScaleTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonScaleTypeSet(solver%solver,quasiNewtonScaleType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonScaleTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonScaleTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonScaleTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonSolveTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,quasiNewtonSolveType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonSolveTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonSolveTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolveTypeSet(solver,quasiNewtonSolveType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonSolveTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonSolveTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonSolveTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonSolveTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,quasiNewtonSolveType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonSolveTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonSolveTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonSolveTypeSet(solver,quasiNewtonSolveType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonSolveTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonSolveTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonSolveTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonSolveTypeSetObj(solver,quasiNewtonSolveType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonSolveTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OpenCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonSolveTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonSolveTypeSet(solver%solver,quasiNewtonSolveType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonSolveTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonSolveTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonSolveTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,quasiNewtonType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OpenCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTypeSet(solver,quasiNewtonType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE OC_Solver_QuasiNewtonTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,quasiNewtonType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OpenCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_QuasiNewtonTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_QuasiNewtonTypeSet(solver,quasiNewtonType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE OC_Solver_QuasiNewtonTypeSetObj(solver,quasiNewtonType,err)
    !DLLEXPORT(OC_Solver_QuasiNewtonTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OpenCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_QuasiNewtonTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonTypeSet(solver%solver,quasiNewtonType,err,error,*999)

    EXITS("OC_Solver_QuasiNewtonTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_QuasiNewtonTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_QuasiNewtonTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE OC_Solver_NonlinearTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolveType,err)
    !DLLEXPORT(OC_Solver_NonlinearTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OpenCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NonlinearTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_NonlinearTypeSet(solver,nonlinearSolveType,err,error,*999)

    EXITS("OC_Solver_NonlinearTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_NonlinearTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NonlinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE OC_Solver_NonlinearTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolveType,err)
    !DLLEXPORT(OC_Solver_NonlinearTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OpenCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_NonlinearTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_NonlinearTypeSet(solver,nonlinearSolveType,err,error,*999)

    EXITS("OC_Solver_NonlinearTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_NonlinearTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NonlinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an object.
  SUBROUTINE OC_Solver_NonlinearTypeSetObj(solver,nonlinearSolveType,err)
    !DLLEXPORT(OC_Solver_NonlinearTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OpenCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_NonlinearTypeSetObj",err,error,*999)

    CALL Solver_NonlinearTypeSet(solver%solver,nonlinearSolveType,err,error,*999)

    EXITS("OC_Solver_NonlinearTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_NonlinearTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_NonlinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an user number.
  SUBROUTINE OC_Solver_OutputTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & outputType,err)
    !DLLEXPORT(OC_Solver_OutputTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OpenCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_OutputTypeSet(solver,outputType,err,error,*999)

    EXITS("OC_Solver_OutputTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_OutputTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of output for a solver identified by an user number.
  SUBROUTINE OC_Solver_OutputTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & outputType,err)
    !DLLEXPORT(OC_Solver_OutputTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OpenCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_OutputTypeSet(solver,outputType,err,error,*999)

    EXITS("OC_Solver_OutputTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_OutputTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_OutputTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an object.
  SUBROUTINE OC_Solver_OutputTypeSetObj(solver,outputType,err)
    !DLLEXPORT(OC_Solver_OutputTypeSetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OpenCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_OutputTypeSetObj",err,error,*999)

    CALL Solver_OutputTypeSet(solver%solver,outputType,err,error,*999)

    EXITS("OC_Solver_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_OutputTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE OC_Solver_SolverEquationsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(OC_Solver_SolverEquationsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations%solverEquations,err,error,*999)

    EXITS("OC_Solver_SolverEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("OC_Solver_SolverEquationsGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE OC_Solver_SolverEquationsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & solverEquations,err)
    !DLLEXPORT(OC_Solver_SolverEquationsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver

    ENTERS("OC_Solver_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations%solverEquations,err,error,*999)

    EXITS("OC_Solver_SolverEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("OC_Solver_SolverEquationsGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_SolverEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an object.
  SUBROUTINE OC_Solver_SolverEquationsGetObj(solver,solverEquations,err)
    !DLLEXPORT(OC_Solver_SolverEquationsGetObj)

    !Argument variables
    TYPE(OC_SolverType), INTENT(IN) :: solver !<The solver to get the solver equations for.
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_Solver_SolverEquationsGetObj",err,error,*999)

    CALL Solver_SolverEquationsGet(solver%solver,solverEquations%solverEquations,err,error,*999)

    EXITS("OC_Solver_SolverEquationsGetObj")
    RETURN
999 ERRORSEXITS("OC_Solver_SolverEquationsGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Solver_SolverEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_EquationsSetAddNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)
    !DLLEXPORT(OC_SolverEquations_EquationsSetAddNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_EquationsSetAddNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL SolverEquations_EquationsSetAdd(solverEquations,equationsSet,equationsSetIndex,err,error,*999)

    EXITS("OC_SolverEquations_EquationsSetAddNumber0")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_EquationsSetAddNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_EquationsSetAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_EquationsSetAddNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)
    !DLLEXPORT(OC_SolverEquations_EquationsSetAddNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(EquationsSetType), POINTER :: equationsSet
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_EquationsSetAddNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,regionUserNumber,region,err,error,*999)
    CALL Region_EquationsSetGet(region,equationsSetUserNumber,equationsSet,err,error,*999)
    CALL SolverEquations_EquationsSetAdd(solverEquations,equationsSet,equationsSetIndex,err,error,*999)

    EXITS("OC_SolverEquations_EquationsSetAddNumber1")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_EquationsSetAddNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_EquationsSetAddNumber1

  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an object.
  SUBROUTINE OC_SolverEquations_EquationsSetAddObj(solverEquations,equationsSet,equationsSetIndex,err)
    !DLLEXPORT(OC_SolverEquations_EquationsSetAddObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(OC_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_EquationsSetAddObj",err,error,*999)

    CALL SolverEquations_EquationsSetAdd(solverEquations%solverEquations,equationsSet%equationsSet,equationsSetIndex, &
      & err,error,*999)

    EXITS("OC_SolverEquations_EquationsSetAddObj")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_EquationsSetAddObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_EquationsSetAddObj

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_InterfaceConditionAddNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)
    !DLLEXPORT(OC_SolverEquations_InterfaceConditionAddNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: interfaceRegion
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_InterfaceConditionAddNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(interfaceRegion)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,interfaceRegion,err,error,*999)
    CALL Region_InterfaceGet(interfaceRegion,interfaceUserNumber,interface,err,error,*999)
    CALL Interface_InterfaceConditionGet(interface,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL SolverEquations_InterfaceConditionAdd(solverEquations,interfaceCondition,interfaceConditionIndex,err,error,*999)

    EXITS("OC_SolverEquations_InterfaceConditionAddNumber0")
    RETURN
999 ERRORS("OC_SolverEquations_InterfaceConditionAddNumber0",err,error)
    EXITS("OC_SolverEquations_InterfaceConditionAddNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_InterfaceConditionAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_InterfaceConditionAddNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)
    !DLLEXPORT(OC_SolverEquations_InterfaceConditionAddNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containting the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditions to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(InterfaceType), POINTER :: interface
    TYPE(InterfaceConditionType), POINTER :: interfaceCondition
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(RegionType), POINTER :: interfaceRegion
    TYPE(RegionsType), POINTER :: regions
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_InterfaceConditionAddNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(regions)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(interfaceRegion)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL Region_Get(regions,interfaceRegionUserNumber,interfaceRegion,err,error,*999)
    CALL Region_InterfaceGet(interfaceRegion,interfaceUserNumber,INTERFACE,err,error,*999)
    CALL Interface_InterfaceConditionGet(INTERFACE,interfaceConditionUserNumber,interfaceCondition,err,error,*999)
    CALL SolverEquations_InterfaceConditionAdd(solverEquations,interfaceCondition,interfaceConditionIndex,err,error,*999)

    EXITS("OC_SolverEquations_InterfaceConditionAddNumber1")
    RETURN
999 ERRORS("OC_SolverEquations_InterfaceConditionAddNumber1",err,error)
    EXITS("OC_SolverEquations_InterfaceConditionAddNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_InterfaceConditionAddNumber1

  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an object.
  SUBROUTINE OC_SolverEquations_InterfaceConditionAddObj(solverEquations,interfaceCondition,interfaceConditionIndex,err)
    !DLLEXPORT(OC_SolverEquations_InterfaceConditionAddObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(OC_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_InterfaceConditionAddObj",err,error,*999)

    CALL SolverEquations_InterfaceConditionAdd(solverEquations%solverEquations,interfaceCondition%interfaceCondition, &
      & interfaceConditionIndex,err,error,*999)

    EXITS("OC_SolverEquations_InterfaceConditionAddObj")
    RETURN
999 ERRORS("OC_SolverEquations_InterfaceConditionAddObj",err,error)
    EXITS("OC_SolverEquations_InterfaceConditionAddObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_InterfaceConditionAddObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SparsityTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(OC_SolverEquations_SparsityTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type for the solver equations. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SparsityTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeGet(solverEquations,sparsityType,err,error,*999)

    EXITS("OC_SolverEquations_SparsityTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SparsityTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SparsityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SparsityTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(OC_SolverEquations_SparsityTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the solver equations. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SparsityTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeGet(solverEquations,sparsityType,err,error,*999)

    EXITS("OC_SolverEquations_SparsityTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SparsityTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SparsityTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for solver equations identified by an object.
  SUBROUTINE OC_SolverEquations_SparsityTypeGetObj(solverEquations,sparsityType,err)
    !DLLEXPORT(OC_SolverEquations_SparsityTypeGetObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type for the solver equtaions. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_SparsityTypeGetObj",err,error,*999)

    CALL SolverEquations_SparsityTypeGet(solverEquations%solverEquations,sparsityType,err,error,*999)

    EXITS("OC_SolverEquations_SparsityTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SparsityTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SparsityTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(OC_SolverEquations_SparsityTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SparsityTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeSet(solverEquations,sparsityType,err,error,*999)

    EXITS("OC_SolverEquations_SparsityTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SparsityTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SparsityTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & sparsityType,err)
    !DLLEXPORT(OC_SolverEquations_SparsityTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SparsityTypeSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SparsityTypeSet(solverEquations,sparsityType,err,error,*999)

    EXITS("OC_SolverEquations_SparsityTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SparsityTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SparsityTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an object.
  SUBROUTINE OC_SolverEquations_SparsityTypeSetObj(solverEquations,sparsityType,err)
    !DLLEXPORT(OC_SolverEquations_SparsityTypeSetObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OpenCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_SparsityTypeSetObj",err,error,*999)

    CALL SolverEquations_SparsityTypeSet(solverEquations%solverEquations,sparsityType,err,error,*999)

    EXITS("OC_SolverEquations_SparsityTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SparsityTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SymmetryTypeGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(OC_SolverEquations_SymmetryTypeGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the  type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the symmetry type for.
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the solver equations symmetry type. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SymmetryTypeGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeGet(solverEquations,symmetryType,err,error,*999)

    EXITS("OC_SolverEquations_SymmetryTypeGetNumber0")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SymmetryTypeGetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SymmetryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SymmetryTypeGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(OC_SolverEquations_SymmetryTypeGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the symmetry type for.
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the symmetry type for the solver equations. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("OC_SolverEquations_SymmetryTypeGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    NULLIFY(solverMatrices)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeGet(solverEquations,symmetryType,err,error,*999)

    EXITS("OC_SolverEquations_SymmetryTypeGetNumber1")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SymmetryTypeGetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SymmetryTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the symmetry type for solver equations identified by an object.
  SUBROUTINE OC_SolverEquations_SymmetryTypeGetObj(solverEquations,symmetryType,err)
    !DLLEXPORT(OC_SolverEquations_SymmetryTypeGetObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the symmetry type for.
    INTEGER(INTG), INTENT(OUT) :: symmetryType !<On return, the symmetry type for the solver equations. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_SymmetryTypeGetObj",err,error,*999)

    CALL SolverEquations_SymmetryTypeGet(solverEquations%solverEquations,symmetryType,err,error,*999)

    EXITS("OC_SolverEquations_SymmetryTypeGetObj")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SymmetryTypeGetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SymmetryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SymmetryTypeSetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(OC_SolverEquations_SymmetryTypeSetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the  type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The symmetry type to set. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SymmetryTypeSetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeSet(solverEquations,symmetryType,err,error,*999)

    EXITS("OC_SolverEquations_SymmetryTypeSetNumber0")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SymmetryTypeSetNumber0",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SymmetryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry type for solver equations identified by an user number.
  SUBROUTINE OC_SolverEquations_SymmetryTypeSetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & symmetryType,err)
    !DLLEXPORT(OC_SolverEquations_SymmetryTypeSetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The symmetry type to set. \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverType), POINTER :: solver
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_SymmetryTypesSetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverGet(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
    CALL Solver_SolverEquationsGet(solver,solverEquations,err,error,*999)
    CALL SolverEquations_SymmetryTypeSet(solverEquations,symmetryType,err,error,*999)

    EXITS("OC_SolverEquations_SymmetryTypeSetNumber1")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SymmetryTypeSetNumber1",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SymmetryTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the symmetry types for solver equations identified by an object.
  SUBROUTINE OC_SolverEquations_SymmetryTypeSetObj(solverEquations,symmetryType,err)
    !DLLEXPORT(OC_SolverEquations_SymmetryTypeSetObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the symmetry type for.
    INTEGER(INTG), INTENT(IN) :: symmetryType !<The symmetry type to set for the solver equations \see OpenCMISS_SolverEquationsSymmetryTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_SymmetryTypeSetObj",err,error,*999)

    CALL SolverEquations_SymmetryTypeSet(solverEquations%solverEquations,symmetryType,err,error,*999)

    EXITS("OC_SolverEquations_SymmetryTypeSetObj")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_SymmetryTypeSetObj",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_SymmetryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateFinishNumber0(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifier,solverIndex,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsCreateFinishNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber0")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber0",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateFinishNumber0

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateFinishNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsCreateFinishNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber1")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber1",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsCreateFinishNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateFinishNumber1

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations
  SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateFinishObj(solverEquations,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsCreateFinishObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations containing the boundary conditions to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_BoundaryConditionsCreateFinishObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations%solverEquations,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsCreateFinishObj")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsCreateFinishObj",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsCreateFinishObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateStartNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsCreateStartNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions

    ENTERS("OC_SolverEquations_BoundaryConditionsCreateStartNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations,boundaryConditions,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsCreateStartNumber0")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsCreateStartNumber0",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsCreateStartNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateStartNumber0

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateStartNumber1(contextUserNumber,problemUserNumber, &
    & controlLoopIdentifiers,solverIndex,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsCreateStartNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations
    TYPE(BoundaryConditionsType), POINTER :: boundaryConditions

    ENTERS("OC_SolverEquations_BoundaryConditionsCreateStartNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations,boundaryConditions,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsCreateStartNumber1")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsCreateStartNumber1",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsCreateStartNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateStartNumber1

  !
  !================================================================================================================================
  !

  !>Start the creation of the boundary conditions for the solver equations
  SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateStartObj(solverEquations,boundaryConditions,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsCreateStartObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(INOUT) :: solverEquations !<The solver equations containing the boundary conditions to start.
    TYPE(OC_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, the created boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("OC_SolverEquations_BoundaryConditionsCreateStartObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations%solverEquations, &
      & boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsCreateStartObj")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsCreateStartObj",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsCreateStartObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE OC_SolverEquations_BoundaryConditionsGetNumber0(contextUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,boundaryConditions,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsGetNumber0)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(OC_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_BoundaryConditionsGetNumber0",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsGetNumber0")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsGetNumber0",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsGetNumber0")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsGetNumber0

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE OC_SolverEquations_BoundaryConditionsGetNumber1(contextUserNumber,problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,boundaryConditions,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsGetNumber1)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the problem.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(OC_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(ProblemType), POINTER :: problem
    TYPE(ProblemsType), POINTER :: problems
    TYPE(SolverEquationsType), POINTER :: solverEquations

    ENTERS("OC_SolverEquations_BoundaryConditionsGetNumber1",err,error,*999)

    NULLIFY(context)
    NULLIFY(problems)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_ProblemsGet(context,problems,err,error,*999)
    CALL Problem_Get(problems,problemUserNumber,problem,err,error,*999)
    CALL Problem_SolverEquationsGet(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
    CALL SolverEquations_BoundaryConditionsGet(solverEquations,boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsGetNumber1")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsGetNumber1",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsGetNumber1")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsGetNumber1

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations
  SUBROUTINE OC_SolverEquations_BoundaryConditionsGetObj(solverEquations,boundaryConditions,err)
    !DLLEXPORT(OC_SolverEquations_BoundaryConditionsGetObj)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    TYPE(OC_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_SolverEquations_BoundaryConditionsGetObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsGet(solverEquations%solverEquations,boundaryConditions%boundaryConditions, &
      & err,error,*999)

    EXITS("OC_SolverEquations_BoundaryConditionsGetObj")
    RETURN
999 ERRORS("OC_SolverEquations_BoundaryConditionsGetObj",err,error)
    EXITS("OC_SolverEquations_BoundaryConditionsGetObj")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_BoundaryConditionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of solver matrices for the solver equations
  SUBROUTINE OC_SolverEquations_NumberOfMatricesGet(solverEquations,numberOfMatrices,err)
    !DLLEXPORT(OC_SolverEquations_NumberOfMatricesGet)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the number of matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of matrices for the solver equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("OC_SolverEquations_NumberOfMatricesGet",err,error,*999)

    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_NumberOfSolverMatricesGet(solverMatrices,numberOfMatrices,err,error,*999)

    EXITS("OC_SolverEquations_NumberOfMatricesGet")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_NumberOfMatricesGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_NumberOfMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a solver distributed matrix from the solver equations matrices
  SUBROUTINE OC_SolverEquations_MatrixGet(solverEquations,matrixIndex,distributedMatrix,err)
    !DLLEXPORT(OC_SolverEquations_MatrixGet)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the distributed matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: distributedMatrix !<On return, the requested solver distributed matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix

    ENTERS("OC_SolverEquations_MatrixGet",err,error,*999)

    NULLIFY(solverMatrices)
    NULLIFY(solverMatrix)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_SolverMatrixGet(solverMatrices,matrixIndex,solverMatrix,err,error,*999)
    CALL SolverMatrix_SolverDistributedMatrixGet(solverMatrix,distributedMatrix%distributedMatrix,err,error,*999)

    EXITS("OC_SolverEquations_MatrixGet")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_MatrixGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_MatrixGet

  !
  !================================================================================================================================
  !

  !>Get the Jacobian distributed matrix from the solver equations matrices for nonlinear solver equations
  SUBROUTINE OC_SolverEquations_JacobianMatrixGet(solverEquations,distributedMatrix,err)
    !DLLEXPORT(OC_SolverEquations_JacobianMatrixGet)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the Jacobian matrix for
    TYPE(OC_DistributedMatrixType), INTENT(INOUT) :: distributedMatrix !<On return, the solver equations Jacobian distributed matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix

    ENTERS("OC_SolverEquations_JacobianMatrixGet",err,error,*999)

    NULLIFY(solverMatrices)
    NULLIFY(solverMatrix)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_SolverMatrixGet(solverMatrices,1,solverMatrix,err,error,*999)
    CALL SolverMatrix_SolverDistributedMatrixGet(solverMatrix,distributedMatrix%distributedMatrix,err,error,*999)

    EXITS("OC_SolverEquations_JacobianMatrixGet")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_JacobianMatrixGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get the distributed vector assiciated with a solver matrix from the solver equations matrices
  SUBROUTINE OC_SolverEquations_VectorGet(solverEquations,matrixIndex,distributedVector,err)
    !DLLEXPORT(OC_SolverEquations_VectorGet)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the distributed vector for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get the vector for
    TYPE(OC_DistributedVectorType), INTENT(INOUT) :: distributedVector !<On return, the requested solver matrix distributed vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices
    TYPE(SolverMatrixType), POINTER :: solverMatrix

    ENTERS("OC_SolverEquations_VectorGet",err,error,*999)

    NULLIFY(solverMatrices)
    NULLIFY(solverMatrix)    
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_SolverMatrixGet(solverMatrices,matrixIndex,solverMatrix,err,error,*999)
    CALL SolverMatrix_SolverDistributedVectorGet(solverMatrix,distributedVector%distributedVector,err,error,*999)

    EXITS("OC_SolverEquations_VectorGet")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_VectorGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_VectorGet

  !
  !================================================================================================================================
  !

  !>Get the residual distributed vector from the solver equations for nonlinear problems
  SUBROUTINE OC_SolverEquations_ResidualVectorGet(solverEquations,residualVector,err)
    !DLLEXPORT(OC_SolverEquations_ResidualVectorGet)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the residual vector for
    TYPE(OC_DistributedVectorType), INTENT(INOUT) :: residualVector !<On return, the solver residual distributed vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("OC_SolverEquations_ResidualVectorGet",err,error,*999)

    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_ResidualDistributedVectorGet(solverMatrices,residualVector%distributedVector,err,error,*999)

    EXITS("OC_SolverEquations_ResidualVectorGet")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_ResidualVectorGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side distributed vector from the solver equations
  SUBROUTINE OC_SolverEquations_RHSVectorGet(solverEquations,rhsVector,err)
    !DLLEXPORT(OC_SolverEquations_RHSVectorGet)

    !Argument variables
    TYPE(OC_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the right hand side distributed vector for
    TYPE(OC_DistributedVectorType), INTENT(INOUT) :: rhsVector !<On return, the solver right hand side distributed vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(SolverMatricesType), POINTER :: solverMatrices

    ENTERS("OC_SolverEquations_RHSVectorGet",err,error,*999)

    NULLIFY(solverMatrices)
    CALL SolverEquations_SolverMatricesGet(solverEquations%solverEquations,solverMatrices,err,error,*999)
    CALL SolverMatrices_RHSDistributedVectorGet(solverMatrices,rhsVector%distributedVector,err,error,*999)

    EXITS("OC_SolverEquations_RHSVectorGet")
    RETURN
999 ERRORSEXITS("OC_SolverEquations_RHSVectorGet",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_SolverEquations_RHSVectorGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given region.
  SUBROUTINE OC_Region_UserNumberGet(region,userNumber,err)
    !DLLEXPORT(OC_Region_UserNumberGet)
    !Argument variables
    TYPE(OC_RegionType), INTENT(IN) :: region !<The region to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The region's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_Region_UserNumberGet",err,error,*999)

    CALL Region_UserNumberGet(region%region,userNumber,err,error,*999)

    EXITS("OC_Region_UserNumberGet")
    RETURN
999 ERRORS("OC_Region_UserNumberGet",err,error)
    EXITS("OC_Region_UserNumberGet")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Region_UserNumberGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given mesh.
  SUBROUTINE OC_Mesh_UserNumberGet(mesh,userNumber,err)
    !DLLEXPORT(OC_Mesh_UserNumberGet)
    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !<The mesh to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The mesh's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_Mesh_UserNumberGet",err,error,*999)

    CALL Mesh_UserNumberGet(mesh%mesh,userNumber,err,error,*999)

    EXITS("OC_Mesh_UserNumberGet")
    RETURN
999 ERRORS("OC_Mesh_UserNumberGet",err,error)
    EXITS("OC_Mesh_UserNumberGet")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Mesh_UserNumberGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given basis.
  SUBROUTINE OC_Basis_UserNumberGet(basis,userNumber,err)
    !DLLEXPORT(OC_Basis_UserNumberGet)
    !Argument variables
    TYPE(OC_BasisType), INTENT(IN) :: basis !<The basis to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The basis's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local Variables

    ENTERS("OC_Basis_UserNumberGet",err,error,*999)

    CALL Basis_UserNumberGet(basis%basis,userNumber,err,error,*999)

    EXITS("OC_Basis_UserNumberGet")
    RETURN
999 ERRORS("OC_Basis_UserNumberGet",err,error)
    EXITS("OC_Basis_UserNumberGet")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_Basis_UserNumberGet

  !
  !================================================================================================================================
  !

  !>Update the bioelectrics geometric field by interpolating the finite elasticity geometric field
  SUBROUTINE OC_BioelectricsFiniteElasticity_UpdateGeometricField(controlLoop,calcClosestGaussPoint,err)
    !DLLEXPORT(OC_BioelectricsFiniteElasticity_UpdateGeometricField)

    !Argument variables
    TYPE(OC_ControlLoopType), INTENT(INOUT) :: controlLoop !<The bioelectrics control loop
    LOGICAL, INTENT(IN) :: calcClosestGaussPoint
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_BioelectricsFiniteElasticity_UpdateGeometricField",err,error,*999)

    CALL BioelectricFiniteElasticity_UpdateGeometricField(controlLoop%controlLoop,calcClosestGaussPoint,err,error,*999)

    EXITS("OC_BioelectricsFiniteElasticity_UpdateGeometricField")
    RETURN
999 ERRORS("OC_BioelectricsFiniteElasticity_UpdateGeometricField",err,error)
    EXITS("OC_BioelectricsFiniteElasticity_UpdateGeometricField")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_BioelectricsFiniteElasticity_UpdateGeometricField

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE OC_FieldML_InputCreateFromFileVS( filename, fieldml, err )
    !DLLEXPORT(OC_FieldML_InputCreateFromFileVS)
    !Arguments
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputCreateFromFileVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCreateFromFileVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputCreateFromFileVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCreateFromFileVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE OC_FieldML_InputCreateFromFileC( filename, fieldml, err )
    !DLLEXPORT(OC_FieldML_InputCreateFromFileC)
    !Arguments
    CHARACTER(LEN=*), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputCreateFromFileC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCreateFromFileC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputCreateFromFileC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCreateFromFileC

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputMeshCreateStartObjVS( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !DLLEXPORT(OC_FieldML_InputMeshCreateStartObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(OC_RegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(OC_MeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputMeshCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh%mesh, meshNumber, region%region, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputMeshCreateStartObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputMeshCreateStartObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputMeshCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputMeshCreateStartNumberVS( fieldml, meshArgumentName, meshNumber, contextUserNumber, &
    & regionNumber, err )
    !DLLEXPORT(OC_FieldML_InputMeshCreateStartNumberVS)

    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_InputMeshCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh, meshNumber, region, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputMeshCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputMeshCreateStartNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputMeshCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputMeshCreateStartObjC( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !DLLEXPORT(OC_FieldML_InputMeshCreateStartObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(OC_RegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(OC_MeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputMeshCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh%mesh, meshNumber, region%region, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputMeshCreateStartObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputMeshCreateStartObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputMeshCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputMeshCreateStartNumberC( fieldml, meshArgumentName, meshNumber, contextUserNumber, &
    & regionNumber, err )
    !DLLEXPORT(OC_FieldML_InputMeshCreateStartNumberC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_InputMeshCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions,regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh, meshNumber, region, &
      & err, error, *999)

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputMeshCreateStartNumberC")
    RETURN
999 ERRORS("OC_FieldML_InputMeshCreateStartNumberC",err,error)
    EXITS("OC_FieldML_InputMeshCreateStartNumberC")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputMeshCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartObjVS( fieldml, evaluatorName, userNumber, context, coordinateSystem, &
    & err )
    !DLLEXPORT(OC_FieldML_InputCoordinateSystemCreateStartObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context for the coordinate system.
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_FieldML_InputCoordinateSystemCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(coordinateSystems)
    CALL Context_CoordinateSystemsGet(context%context,coordinateSystems,err,error,*999)

    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, evaluatorName, coordinateSystems, &
      & coordinateSystem%coordinateSystem,userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCoordinateSystemCreateStartObjVS")
    RETURN
999 ERRORS("OC_FieldML_InputCoordinateSystemCreateStartObjVS",err,error)
    EXITS("OC_FieldML_InputCoordinateSystemCreateStartObjVS")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartNumberVS( fieldml, evaluatorName, userNumber, contextUserNumber, err )
    !DLLEXPORT(OC_FieldML_InputCoordinateSystemCreateStartNumberVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context for the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_FieldML_InputCoordinateSystemCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(coordinateSystems)
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, evaluatorName, coordinateSystems, coordinateSystem, &
      & userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCoordinateSystemCreateStartNumberVS")
    RETURN
999 ERRORS("OC_FieldML_InputCoordinateSystemCreateStartNumberVS",err,error)
    EXITS("OC_FieldML_InputCoordinateSystemCreateStartNumberVS")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartObjC( fieldml, evaluatorName, userNumber, context, &
    & coordinateSystem, err )
    !DLLEXPORT(OC_FieldML_InputCoordinateSystemCreateStartObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(OC_ContextType), INTENT(IN) :: context !<The context for the coordinate system.
    TYPE(OC_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_FieldML_InputCoordinateSystemCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(coordinateSystems)
    CALL Context_CoordinateSystemsGet(context%context,coordinateSystems,err,error,*999)

    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, var_str(evaluatorName), coordinateSystems, &
      & coordinateSystem%coordinateSystem, userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCoordinateSystemCreateStartObjC")
    RETURN
999 ERRORS("OC_FieldML_InputCoordinateSystemCreateStartObjC",err,error)
    EXITS("OC_FieldML_InputCoordinateSystemCreateStartObjC")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartNumberC( fieldml, evaluatorName, userNumber, contextUserNumber, err )
    !DLLEXPORT(OC_FieldML_InputCoordinateSystemCreateStartNumberC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !< The user number of the context for the cordinate systems
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(CoordinateSystemType), POINTER :: coordinateSystem
    TYPE(CoordinateSystemsType), POINTER :: coordinateSystems

    ENTERS("OC_FieldML_InputCoordinateSystemCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(coordinateSystems)    
    NULLIFY(coordinateSystem)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_CoordinateSystemsGet(context,coordinateSystems,err,error,*999)
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, var_str(evaluatorName), coordinateSystems, &
      & coordinateSystem, userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCoordinateSystemCreateStartNumberC")
    RETURN
999 ERRORS("OC_FieldML_InputCoordinateSystemCreateStartNumberC",err,error)
    EXITS("OC_FieldML_InputCoordinateSystemCreateStartNumberC")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCoordinateSystemCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputBasisCreateStartNumberVS( fieldml, evaluatorName, userNumber, contextUserNumber, err )
    !DLLEXPORT(OC_FieldML_InputBasisCreateStartNumberVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !< The user number of the context to create the basis in.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_FieldML_InputBasisCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY( basis )
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basisFunctions, &
      & basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputBasisCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputBasisCreateStartNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputBasisCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputBasisCreateStartObjVS( fieldml, evaluatorName, userNumber, context, basis, err )
    !DLLEXPORT(OC_FieldML_InputBasisCreateStartObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(OC_ContextType), INTENT(IN) :: context !< The context to create the basis function on. 
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_FieldML_InputBasisCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(basisFunctions)
    CALL Context_BasisFunctionsGet(context%context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basisFunctions,  &
      & basis%basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputBasisCreateStartObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputBasisCreateStartObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputBasisCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputBasisCreateStartNumberC( fieldml, evaluatorName, userNumber, contextUserNumber,err )
    !DLLEXPORT(OC_FieldML_InputBasisCreateStartNumberC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context on which to create the basis
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(BasisType), POINTER :: basis
    TYPE(BasisFunctionsType), POINTER :: basisFunctions
    TYPE(ContextType), POINTER :: context

    ENTERS("OC_FieldML_InputBasisCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(basisFunctions)
    NULLIFY( basis )
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)
    CALL Context_BasisFunctionsGet(context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basisFunctions, &
      & basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputBasisCreateStartNumberC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputBasisCreateStartNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputBasisCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputBasisCreateStartObjC( fieldml, evaluatorName, userNumber, context, basis, err )
    !DLLEXPORT(OC_FieldML_InputBasisCreateStartObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(OC_ContextType), INTENT(IN) :: context !< The context to create the basis for. 
    TYPE(OC_BasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(BasisFunctionsType), POINTER :: basisFunctions

    ENTERS("OC_FieldML_InputBasisCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(basisFunctions)
    CALL Context_BasisFunctionsGet(context%context,basisFunctions,err,error,*999)
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basisFunctions,  &
      & basis%basis, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputBasisCreateStartObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputBasisCreateStartObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputBasisCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputNodesCreateStartNumberVS( fieldml, nodesArgumentName, contextUserNumber, regionNumber, nodes, err )
    !DLLEXPORT(OC_FieldML_InputNodesCreateStartNumberVS)

    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(OC_NodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_InputNodesCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputNodesCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputNodesCreateStartNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputNodesCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputNodesCreateStartObjVS( fieldml, nodesArgumentName, region, nodes, err )
    !DLLEXPORT(OC_FieldML_InputNodesCreateStartObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(OC_RegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(OC_NodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputNodesCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START(fieldml%fieldmlInfo, nodesArgumentName, region%region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputNodesCreateStartObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputNodesCreateStartObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputNodesCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputNodesCreateStartNumberC( fieldml, nodesArgumentName, contextUserNumber, regionNumber, nodes, err )
    !DLLEXPORT(OC_FieldML_InputNodesCreateStartNumberC)

    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(OC_NodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_InputNodesCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputNodesCreateStartNumberC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputNodesCreateStartNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputNodesCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputNodesCreateStartObjC( fieldml, nodesArgumentName, region, nodes, err )
    !DLLEXPORT(OC_FieldML_InputNodesCreateStartObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(OC_RegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(OC_NodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputNodesCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region%region, nodes%nodes, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputNodesCreateStartObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputNodesCreateStartObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputNodesCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE OC_FieldML_InputCreateMeshComponentObjVS( fieldml, mesh, componentNumber, evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputCreateMeshComponentObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(OC_MeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputCreateMeshComponentObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%mesh, componentNumber, evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCreateMeshComponentObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputCreateMeshComponentObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCreateMeshComponentObjVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE OC_FieldML_InputCreateMeshComponentNumberVS( fieldml, contextUserNumber, regionNumber, meshNumber, &
    & componentNumber, evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputCreateMeshComponentNumberVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("CMISSFieldML_InputCreateMeshComponentNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet(region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, evaluatorName, err, error, *999 )

#else

    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)

#endif

    EXITS("OC_FieldML_InputCreateMeshComponentNumberVS")
    RETURN
999 ERRORS("OC_FieldML_InputCreateMeshComponentNumberVS",err,error)
    EXITS("OC_FieldML_InputCreateMeshComponentNumberVS")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCreateMeshComponentNumberVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE OC_FieldML_InputCreateMeshComponentObjC( fieldml, mesh, componentNumber, evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputCreateMeshComponentObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(OC_MeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputCreateMeshComponentObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%mesh, componentNumber, var_str(evaluatorName), &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCreateMeshComponentObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputCreateMeshComponentObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCreateMeshComponentObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE OC_FieldML_InputCreateMeshComponentNumberC( fieldml, contextUserNumber, regionNumber, meshNumber, &
    & componentNumber, evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputCreateMeshComponentNumberC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("CMISSFieldML_InputCreateMeshComponentNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputCreateMeshComponentNumberC")
    RETURN
999 ERRORS("OC_FieldML_InputCreateMeshComponentNumberC",err,error)
    EXITS("OC_FieldML_InputCreateMeshComponentNumberC")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputCreateMeshComponentNumberC

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldCreateStartObjVS( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputFieldCreateStartObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(OC_RegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputFieldCreateStartObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%region, decomposition%decomposition, fieldNumber, &
      & field%field, variableType, evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldCreateStartObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputFieldCreateStartObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldCreateStartNumberVS( fieldml, contextUserNumber, regionNumber, meshNumber, &
    & decompositionNumber, fieldNumber,variableType, evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputFieldCreateStartNumberVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(MeshType), POINTER :: mesh
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_InputFieldCreateStartNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )
    CALL Mesh_DecompositionGet( mesh, decompositionNumber, decomposition, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputFieldCreateStartNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldCreateStartObjC( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputFieldCreateStartObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(OC_RegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(OC_DecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputFieldCreateStartObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%region, decomposition%decomposition, fieldNumber, &
      & field%field, variableType, var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldCreateStartObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputFieldCreateStartObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldCreateStartNumberC( fieldml, contextUserNumber, regionNumber, meshNumber, decompositionNumber, &
    & fieldNumber,variableType, evaluatorName, err )
    !DLLEXPORT(OC_FieldML_InputFieldCreateStartNumberC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(DecompositionType), POINTER :: decomposition
    TYPE(FieldType), POINTER :: field
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_InputFieldCreateStartNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(decomposition)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )
    CALL Mesh_DecompositionGet( mesh, decompositionNumber, decomposition, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldCreateStartNumberC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputFieldCreateStartNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldParametersUpdateObjVS( fieldml, field, evaluatorName, variableType, &
    & setType, err )
    !DLLEXPORT(OC_FieldML_InputFieldParametersUpdateObjVS)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !< On return, the field object.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputFieldParametersUpdateObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field%field, variableType, &
      &  setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldParametersUpdateObjVS")
    RETURN
999 ERRORS("OC_FieldML_InputFieldParametersUpdateObjVS",err,error)
    EXITS("OC_FieldML_InputFieldParametersUpdateObjVS")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldParametersUpdateObjVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldParametersUpdateNumberVS( fieldml, contextUserNumber, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !DLLEXPORT(OC_FieldML_InputFieldParametersUpdateNumberVS)

    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_InputFieldParametersUpdateNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet(region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldParametersUpdateNumberVS")
    RETURN
999 ERRORS("OC_FieldML_InputFieldParametersUpdateNumberVS",err,error)
    EXITS("OC_FieldML_InputFieldParametersUpdateNumberVS")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldParametersUpdateNumberVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldParametersUpdateObjC( fieldml, field, evaluatorName, &
    & variableType, setType, err )
    !DLLEXPORT(OC_FieldML_InputFieldParametersUpdateObjC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(OC_FieldType), INTENT(INOUT) :: field !< On return, the field object.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_InputFieldParametersUpdateObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field%field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldParametersUpdateObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_InputFieldParametersUpdateObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldParametersUpdateObjC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE OC_FieldML_InputFieldParametersUpdateNumberC( fieldml, contextUserNumber, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !DLLEXPORT(OC_FieldML_InputFieldParametersUpdateNumberC)
    !Arguments
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Local variables
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_InputFieldParametersUpdateNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet(region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_InputFieldParametersUpdateNumberC")
    RETURN
999 ERRORS("OC_FieldML_InputFieldParametersUpdateNumberC",err,error)
    EXITS("OC_FieldML_InputFieldParametersUpdateNumberC")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_InputFieldParametersUpdateNumberC

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE OC_FieldML_OutputWriteVS( fieldml, filename, err )
    !DLLEXPORT(OC_FieldML_OutputWriteVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputWriteVS",err,error,*999)

#ifdef WITH_FIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FlagError( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputWriteVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputWriteVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputWriteVS

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE OC_FieldML_OutputWriteC( fieldml, filename, err )
    !DLLEXPORT(OC_FieldML_OutputWriteC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputWriteC",err,error,*999)

#ifdef WITH_FIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FlagError( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputWriteC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputWriteC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputWriteC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE OC_FieldML_OutputAddFieldNoTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldNoTypeObjVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(OC_FieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputAddFieldNoTypeObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldNoTypeObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldNoTypeObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldNoTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE OC_FieldML_OutputAddFieldNoTypeNumberVS( fieldml, baseName, dofFormat, contextUserNumber, regionNumber, &
    & fieldNumber,variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldNoTypeNumberVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_OutputAddFieldNoTypeNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldNoTypeNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldNoTypeNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldNoTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE OC_FieldML_OutputAddFieldWithTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldWithTypeObjVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(OC_FieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputAddFieldWithTypeObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldWithTypeObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldWithTypeObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldWithTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE OC_FieldML_OutputAddFieldWithTypeNumberVS( fieldml, baseName, dofFormat, contextUserNumber, regionNumber,  &
    & fieldNumber,variableType, setType, typeHandle, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldWithTypeNumberVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_OutputAddFieldWithTypeNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldWithTypeNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldWithTypeNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldWithTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE OC_FieldML_OutputAddFieldNoTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldNoTypeObjC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(OC_FieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputAddFieldNoTypeObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldNoTypeObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldNoTypeObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldNoTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE OC_FieldML_OutputAddFieldNoTypeNumberC( fieldml, baseName, dofFormat, contextUserNumber, regionNumber, &
    & fieldNumber,variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldNoTypeNumberC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_OutputAddFieldNoTypeNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldNoTypeNumberC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldNoTypeNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldNoTypeNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE OC_FieldML_OutputAddFieldWithTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldWithTypeObjC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(OC_FieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputAddFieldWithTypeObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%field, variableType, &
      & typeHandle, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldWithTypeObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldWithTypeObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldWithTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE OC_FieldML_OutputAddFieldWithTypeNumberC( fieldml, baseName, dofFormat, contextUserNumber, regionNumber, &
    & fieldNumber, variableType, setType, typeHandle, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldWithTypeNumberC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(FieldType), POINTER :: field
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_OutputAddFieldWithTypeNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, typeHandle, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldWithTypeNumberC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldWithTypeNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldWithTypeNumberC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE OC_FieldML_OutputCreateObjVS( mesh, location, baseName, connectivityFormat, fieldml, err )
    !DLLEXPORT(OC_FieldML_OutputCreateObjVS)
    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputCreateObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputCreateObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputCreateObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputCreateObjVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE OC_FieldML_OutputCreateNumberVS( contextUserNumber, regionNumber, meshNumber, location, baseName, &
    & connectivityFormat, fieldml, err )
    !DLLEXPORT(OC_FieldML_OutputCreateNumberVS)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_OutputCreateNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputCreateNumberVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputCreateNumberVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputCreateNumberVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE OC_FieldML_OutputCreateObjC( mesh, location, baseName, connectivityFormat, fieldml, err )
    !DLLEXPORT(OC_FieldML_OutputCreateObjC)
    !Argument variables
    TYPE(OC_MeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputCreateObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputCreateObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputCreateObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputCreateObjC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE OC_FieldML_OutputCreateNumberC( contextUserNumber, regionNumber, meshNumber, location, baseName, &
    & connectivityFormat, fieldml, err )
    !DLLEXPORT(OC_FieldML_OutputCreateNumberC)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(MeshType), POINTER :: mesh
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions

    ENTERS("OC_FieldML_OutputCreateNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(mesh)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_MeshGet( region, meshNumber, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputCreateNumberC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputCreateNumberC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputCreateNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE OC_FieldML_OutputAddFieldComponentsObjVS( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldComponentsObjVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(OC_FieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputAddFieldComponentsObjVS",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field%field, &
      & fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldComponentsObjVS")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldComponentsObjVS",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldComponentsObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE OC_FieldML_OutputAddFieldComponentsNumberVS( fieldml, typeHandle, baseName, dofFormat, contextUserNumber,  &
    & regionNumber, fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldComponentsNumberVS)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_OutputAddFieldComponentsNumberVS",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field, fieldComponentNumbers,&
      & variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldComponentsNumberVS")
    RETURN
999 ERRORS("OC_FieldML_OutputAddFieldComponentsNumberVS",err,error)
    EXITS("OC_FieldML_OutputAddFieldComponentsNumberVS")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldComponentsNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE OC_FieldML_OutputAddFieldComponentsObjC( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldComponentsObjC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(OC_FieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("OC_FieldML_OutputAddFieldComponentsObjC",err,error,*999)

#ifdef WITH_FIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field%field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldComponentsObjC")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddFieldComponentsObjC",err,error)
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldComponentsObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE OC_FieldML_OutputAddFieldComponentsNumberC( fieldml, typeHandle, baseName, dofFormat, contextUserNumber, &
    & regionNumber,fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !DLLEXPORT(OC_FieldML_OutputAddFieldComponentsNumberC)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: contextUserNumber !<The user number of the context with the region
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(ContextType), POINTER :: context
    TYPE(RegionType), POINTER :: region
    TYPE(RegionsType), POINTER :: regions
    TYPE(FieldType), POINTER :: field

    ENTERS("OC_FieldML_OutputAddFieldComponentsNumberC",err,error,*999)

#ifdef WITH_FIELDML

    NULLIFY(context)
    NULLIFY(regions)
    NULLIFY(region)
    NULLIFY(field)    
    CALL Context_Get(contexts,contextUserNumber,context,err,error,*999)    
    CALL Context_RegionsGet(context,regions,err,error,*999)
    CALL Region_Get(regions, regionNumber, region, err, error, *999 )
    CALL Region_FieldGet( region, fieldNumber, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddFieldComponentsNumberC")
    RETURN
999 ERRORS("OC_FieldML_OutputAddFieldComponentsNumberC",err,error)
    EXITS("OC_FieldML_OutputAddFieldComponentsNumberC")
    CALL OC_HandleError(err,error)
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddFieldComponentsNumberC

  !
  !================================================================================================================================
  !

  !>Import a FieldML object from the library into the current session.
  SUBROUTINE OC_FieldML_OutputAddImport( fieldml, name, handle, err )
    !DLLEXPORT(OC_FieldML_OutputAddImport)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: name !< The name of the object to import.
    INTEGER(INTG), INTENT(OUT) :: handle !< A handle to the newly imported FieldML object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Locals
    TYPE(VARYING_STRING) :: stringName

    ENTERS("OC_FieldML_OutputAddImport",err,error,*999)

#ifdef WITH_FIELDML

    stringName = name

    handle = FIELDML_OUTPUT_ADD_IMPORT( fieldml%fieldmlInfo, stringName, err, error )
    IF(err/=0) GOTO 999

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldML_OutputAddImport")
    RETURN
999 ERRORSEXITS("OC_FieldML_OutputAddImport",err,error)
    CALL OC_HandleError( err, error )
    RETURN

  END SUBROUTINE OC_FieldML_OutputAddImport

  !
  !================================================================================================================================
  !

  !>Finalises a Fieldml context.
  SUBROUTINE OC_FieldMLIO_Finalise( fieldml, err )
    !DLLEXPORT(OC_FieldMLIO_Finalise)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_FieldMLIO_Finalise", err, error, *999 )

#ifdef WITH_FIELDML

    CALL FIELDML_IO_FINALISE( fieldml%fieldmlInfo, err, error, *999  )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldMLIO_Finalise")
    RETURN
999 ERRORSEXITS("OC_FieldMLIO_Finalise",err,error)
    CALL OC_HandleError( err, error )
    RETURN

  END SUBROUTINE OC_FieldMLIO_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a Fieldml context.
  SUBROUTINE OC_FieldMLIO_Initialise( fieldml, err )
    !DLLEXPORT(OC_FieldMLIO_Initialise)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_FieldMLIO_Initialise", err, error, *999 )

#ifdef WITH_FIELDML

    NULLIFY( fieldml%fieldmlInfo )

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldMLIO_Initialise")
    RETURN
999 ERRORSEXITS("OC_FieldMLIO_Initialise",err,error)
    CALL OC_HandleError( err, error )
    RETURN

  END SUBROUTINE OC_FieldMLIO_Initialise

  !
  !================================================================================================================================
  !

  !>Get the session handle from a Fieldml context.
  SUBROUTINE OC_FieldMLIO_GetSession( fieldml, sessionHandle, err )
    !DLLEXPORT(OC_FieldMLIO_GetSession)
    !Argument variables
    TYPE(OC_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context whose session handle is to be returned.
    INTEGER(INTG), INTENT(OUT) :: sessionHandle !<The session handle.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("OC_FieldMLIO_GetSession", err, error, *999 )

#ifdef WITH_FIELDML

    sessionHandle = fieldml%fieldmlInfo%FML_HANDLE

#else
    CALL FlagError("Must compile with WITH_FIELDML ON to use FieldML functionality.",err,error,*999)
#endif

    EXITS("OC_FieldMLIO_GetSession")
    RETURN
999 ERRORSEXITS("OC_FieldMLIO_GetSession",err,error)
    CALL OC_HandleError( err, error )
    RETURN

  END SUBROUTINE OC_FieldMLIO_GetSession

  !
  !================================================================================================================================
  !


END MODULE OpenCMISS
